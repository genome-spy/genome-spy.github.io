import{_ as Y,L as J}from"./index-9VfcUAh4.js";import{b as K}from"./index-X47Qq1Ab.js";import{L as P}from"./__vite-browser-external-_eDSiqyj.js";import{u as F,L as G,a as Q}from"./long-GBRvvkNx.js";import"./_commonjsHelpers-5FjdjvmD.js";function H(a){if(a.greaterThan(Number.MAX_SAFE_INTEGER)||a.lessThan(Number.MIN_SAFE_INTEGER))throw new Error("integer overflow");return a.toNumber()}class Z extends Error{}function L(a){if(a&&a.aborted){if(typeof DOMException<"u")throw new DOMException("aborted","AbortError");{const e=new Z("aborted");throw e.code="ERR_ABORTED",e}}}function ee(a,e){return e.minv.blockPosition-a.maxv.blockPosition<65e3&&e.maxv.blockPosition-a.minv.blockPosition<5e6}function j(a,e){const t=[];let n=null;return a.length===0?a:(a.sort(function(i,r){const s=i.minv.blockPosition-r.minv.blockPosition;return s!==0?s:i.minv.dataPosition-r.minv.dataPosition}),a.forEach(i=>{(!e||i.maxv.compareTo(e)>0)&&(n===null?(t.push(i),n=i):ee(n,i)?i.maxv.compareTo(n.maxv)>0&&(n.maxv=i.maxv):(t.push(i),n=i))}),t)}class M{constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}static min(...e){let t,n=0;for(;!t;n+=1)t=e[n];for(;n<e.length;n+=1)t.compareTo(e[n])>0&&(t=e[n]);return t}}function T(a,e=0,t=!1){if(t)throw new Error("big-endian virtual file offsets not implemented");return new M(a[e+7]*1099511627776+a[e+6]*4294967296+a[e+5]*16777216+a[e+4]*65536+a[e+3]*256+a[e+2],a[e+1]<<8|a[e])}class B{constructor(e,t,n,i=void 0){this.minv=e,this.maxv=t,this.bin=n,this._fetchedSize=i}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return this._fetchedSize!==void 0?this._fetchedSize:this.maxv.blockPosition+65536-this.minv.blockPosition}}class X{constructor({filehandle:e,renameRefSeqs:t=n=>n}){this.filehandle=e,this.renameRefSeq=t}async getMetadata(e={}){const{indices:t,...n}=await this.parse(e);return n}_findFirstData(e,t){return e?e.compareTo(t)>0?t:e:t}async parse(e={}){return this.parseP||(this.parseP=this._parse(e).catch(t=>{throw this.parseP=void 0,t})),this.parseP}async hasRefSeq(e,t={}){var n;return!!(!((n=(await this.parse(t)).indices[e])===null||n===void 0)&&n.binIndex)}}const te=21578324,q=14;function ne(a,e){return a+=1,e-=1,[[0,0],[1+(a>>26),1+(e>>26)],[9+(a>>23),9+(e>>23)],[73+(a>>20),73+(e>>20)],[585+(a>>17),585+(e>>17)],[4681+(a>>14),4681+(e>>14)]]}class z extends X{async lineCount(e,t={}){const n=await this.parse(t);if(!n)return-1;const i=n.refNameToId[e];if(!n.indices[i])return-1;const{stats:s}=n.indices[i];return s?s.lineCount:-1}async _parse(e={}){const t=await this.filehandle.readFile(e),n=await F(t);if(L(e.signal),n.readUInt32LE(0)!==te)throw new Error("Not a TBI file");const i=n.readInt32LE(4),r=n.readInt32LE(8),s=r&65536?"zero-based-half-open":"1-based-closed",f={0:"generic",1:"SAM",2:"VCF"}[r&15];if(!f)throw new Error(`invalid Tabix preset format flags ${r}`);const c={ref:n.readInt32LE(12),start:n.readInt32LE(16),end:n.readInt32LE(20)},m=n.readInt32LE(24),l=5,d=((1<<(l+1)*3)-1)/7,b=2**(14+l*3),w=m?String.fromCharCode(m):null,u=n.readInt32LE(28),I=n.readInt32LE(32),{refNameToId:x,refIdToName:p}=this._parseNameBytes(n.slice(36,36+I));let h=36+I,g;return{indices:new Array(i).fill(0).map(()=>{const N=n.readInt32LE(h);h+=4;const S={};let E;for(let v=0;v<N;v+=1){const _=n.readUInt32LE(h);if(h+=4,_>d+1)throw new Error("tabix index contains too many bins, please use a CSI index");if(_===d+1){const k=n.readInt32LE(h);h+=4,k===2&&(E=this.parsePseudoBin(n,h)),h+=16*k}else{const k=n.readInt32LE(h);h+=4;const $=new Array(k);for(let D=0;D<k;D+=1){const V=T(n,h),W=T(n,h+8);h+=16,g=this._findFirstData(g,V),$[D]=new B(V,W,_)}S[_]=$}}const y=n.readInt32LE(h);h+=4;const A=new Array(y);for(let v=0;v<y;v+=1)A[v]=T(n,h),h+=8,g=this._findFirstData(g,A[v]);return{binIndex:S,linearIndex:A,stats:E}}),metaChar:w,maxBinNumber:d,maxRefLength:b,skipLines:u,firstDataLine:g,columnNumbers:c,coordinateType:s,format:f,refIdToName:p,refNameToId:x,maxBlockSize:65536}}parsePseudoBin(e,t){return{lineCount:H(G.fromBytesLE(e.slice(t+16,t+24),!0))}}_parseNameBytes(e){let t=0,n=0;const i=[],r={};for(let s=0;s<e.length;s+=1)if(!e[s]){if(n<s){let o=e.toString("utf8",n,s);o=this.renameRefSeq(o),i[t]=o,r[o]=t}n=s+1,t+=1}return{refNameToId:r,refIdToName:i}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const r=await this.parse(i);if(!r)return[];const s=r.refNameToId[e],o=r.indices[s];if(!o)return[];(o.linearIndex.length?o.linearIndex[t>>q>=o.linearIndex.length?o.linearIndex.length-1:t>>q]:new M(0,0))||console.warn("querying outside of possible tabix range");const c=ne(t,n),m=[];for(const[u,I]of c)for(let x=u;x<=I;x++)if(o.binIndex[x])for(const p of o.binIndex[x])m.push(new B(p.minv,p.maxv,x));const l=o.linearIndex.length;let d=null;const b=Math.min(t>>14,l-1),w=Math.min(n>>14,l-1);for(let u=b;u<=w;++u){const I=o.linearIndex[u];I&&(!d||I.compareTo(d)<0)&&(d=I)}return j(m,d)}}const ie=21582659,re=38359875;function oe(a,e){return a*2**e}function O(a,e){return Math.floor(a/2**e)}class U extends X{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e,t={}){const n=await this.parse(t);if(!n)return-1;const i=n.refNameToId[e];if(!n.indices[i])return-1;const{stats:s}=n.indices[i];return s?s.lineCount:-1}indexCov(){throw new Error("CSI indexes do not support indexcov")}parseAuxData(e,t){const n=e.readInt32LE(t),i=n&65536?"zero-based-half-open":"1-based-closed",r={0:"generic",1:"SAM",2:"VCF"}[n&15];if(!r)throw new Error(`invalid Tabix preset format flags ${n}`);const s={ref:e.readInt32LE(t+4),start:e.readInt32LE(t+8),end:e.readInt32LE(t+12)},o=e.readInt32LE(t+16),f=o?String.fromCharCode(o):null,c=e.readInt32LE(t+20),m=e.readInt32LE(t+24),{refIdToName:l,refNameToId:d}=this._parseNameBytes(e.slice(t+28,t+28+m));return{refIdToName:l,refNameToId:d,skipLines:c,metaChar:f,columnNumbers:s,format:r,coordinateType:i}}_parseNameBytes(e){let t=0,n=0;const i=[],r={};for(let s=0;s<e.length;s+=1)if(!e[s]){if(n<s){let o=e.toString("utf8",n,s);o=this.renameRefSeq(o),i[t]=o,r[o]=t}n=s+1,t+=1}return{refNameToId:r,refIdToName:i}}async _parse(e={}){const t=await F(await this.filehandle.readFile(e));let n;if(t.readUInt32LE(0)===ie)n=1;else if(t.readUInt32LE(0)===re)n=2;else throw new Error("Not a CSI file");this.minShift=t.readInt32LE(4),this.depth=t.readInt32LE(8),this.maxBinNumber=((1<<(this.depth+1)*3)-1)/7;const i=2**(this.minShift+this.depth*3),r=t.readInt32LE(12),s=r&&r>=30?this.parseAuxData(t,16):{refIdToName:[],refNameToId:{},metaChar:null,columnNumbers:{ref:0,start:1,end:2},coordinateType:"zero-based-half-open",format:"generic"},o=t.readInt32LE(16+r);let f,c=16+r+4;const m=new Array(o).fill(0).map(()=>{const l=t.readInt32LE(c);c+=4;const d={};let b;for(let w=0;w<l;w+=1){const u=t.readUInt32LE(c);if(u>this.maxBinNumber)b=this.parsePseudoBin(t,c+4),c+=4+8+4+16+16;else{const I=T(t,c+4);f=this._findFirstData(f,I);const x=t.readInt32LE(c+12);c+=16;const p=new Array(x);for(let h=0;h<x;h+=1){const g=T(t,c),C=T(t,c+8);c+=16,p[h]=new B(g,C,u)}d[u]=p}}return{binIndex:d,stats:b}});return{...s,csi:!0,refCount:o,maxBlockSize:65536,firstDataLine:f,csiVersion:n,indices:m,depth:this.depth,maxBinNumber:this.maxBinNumber,maxRefLength:i}}parsePseudoBin(e,t){return{lineCount:H(G.fromBytesLE(e.slice(t+28,t+36),!0))}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const r=await this.parse(i);if(!r)return[];const s=r.refNameToId[e],o=r.indices[s];if(!o)return[];const f=this.reg2bins(t,n),c=[];for(const[m,l]of f)for(let d=m;d<=l;d++)if(o.binIndex[d])for(const b of o.binIndex[d])c.push(new B(b.minv,b.maxv,d));return j(c,new M(0,0))}reg2bins(e,t){e-=1,e<1&&(e=1),t>2**50&&(t=2**34),t-=1;let n=0,i=0,r=this.minShift+this.depth*3;const s=[];for(;n<=this.depth;r-=3,i+=oe(1,n*3),n+=1){const o=i+O(e,r),f=i+O(t,r);if(f-o+s.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);s.push([o,f])}return s}}const R=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function se(a){return new Promise(e=>setTimeout(e,a))}class he{constructor({path:e,filehandle:t,tbiPath:n,tbiFilehandle:i,csiPath:r,csiFilehandle:s,yieldTime:o=500,chunkSizeLimit:f=5e7,renameRefSeqs:c=l=>l,chunkCacheSize:m=5*2**20}){if(t)this.filehandle=t;else if(e)this.filehandle=new P(e);else throw new TypeError("must provide either filehandle or path");if(i)this.index=new z({filehandle:i,renameRefSeqs:c});else if(s)this.index=new U({filehandle:s,renameRefSeqs:c});else if(n)this.index=new z({filehandle:new P(n),renameRefSeqs:c});else if(r)this.index=new U({filehandle:new P(r),renameRefSeqs:c});else if(e)this.index=new z({filehandle:new P(`${e}.tbi`),renameRefSeqs:c});else throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath");this.chunkSizeLimit=f,this.renameRefSeq=c,this.yieldTime=o,this.chunkCache=new Y({cache:new J({maxSize:Math.floor(m/65536)}),fill:(l,d)=>this.readChunk(l,{signal:d})})}async getLines(e,t,n,i){var r;let s,o={},f;if(i===void 0)throw new TypeError("line callback must be provided");if(typeof i=="function"?f=i:(o=i,f=i.lineCallback,s=i.signal),e===void 0)throw new TypeError("must provide a reference sequence name");if(!f)throw new TypeError("line callback must be provided");const c=await this.index.getMetadata(o);L(s);const m=t??0,l=n??c.maxRefLength;if(!(m<=l))throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");if(m===l)return;const d=await this.index.blocksForRange(e,m,l,o);L(s);for(const w of d){const u=w.fetchedSize();if(u>this.chunkSizeLimit)throw new Error(`Too much data. Chunk size ${u.toLocaleString()} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit.toLocaleString()}.`)}let b=Date.now();for(const w of d){let u;const{buffer:I,cpositions:x,dpositions:p}=await this.chunkCache.get(w.toString(),w,s);L(s);let h=0,g=0;for(;h<I.length;){const C=I.indexOf(`
`,h);if(C===-1)break;const N=I.slice(h,C),S=(r=R==null?void 0:R.decode(N))!==null&&r!==void 0?r:N.toString();if(p){for(;h+w.minv.dataPosition>=p[g++];);g--}const{startCoordinate:E,overlaps:y}=this.checkLine(c,e,m,l,S);if(u!==void 0&&E!==void 0&&u>E)throw new Error(`Lines not sorted by start coordinate (${u} > ${E}), this file is not usable with Tabix.`);if(u=E,y)f(S.trim(),x[g]*256+(h-p[g])+w.minv.dataPosition+1);else if(E!==void 0&&E>=l)return;this.yieldTime&&b-Date.now()>this.yieldTime&&(b=Date.now(),L(s),await se(1)),h=C+1}}}async getMetadata(e={}){return this.index.getMetadata(e)}async getHeaderBuffer(e={}){const{firstDataLine:t,metaChar:n,maxBlockSize:i}=await this.getMetadata(e);L(e.signal);const r=((t==null?void 0:t.blockPosition)||0)+i,s=await this._readRegion(0,r,e),o=await F(s);if(n){let f=-1;const c=`
`.charCodeAt(0),m=n.charCodeAt(0);for(let l=0;l<o.length&&!(l===f+1&&o[l]!==m);l+=1)o[l]===c&&(f=l);return o.slice(0,f+1)}return o}async getHeader(e={}){return(await this.getHeaderBuffer(e)).toString("utf8")}async getReferenceSequenceNames(e={}){return(await this.getMetadata(e)).refIdToName}checkLine(e,t,n,i,r){const{columnNumbers:s,metaChar:o,coordinateType:f,format:c}=e;if(o&&r.startsWith(o))return{overlaps:!1};let{ref:m,start:l,end:d}=s;m||(m=0),l||(l=0),d||(d=0),c==="VCF"&&(d=8);const b=Math.max(m,l,d);let w=1,u=0,I="",x=-1/0;for(let p=0;p<r.length+1;p+=1)if(r[p]==="	"||p===r.length){if(w===m){if(this.renameRefSeq(r.slice(u,p))!==t)return{overlaps:!1}}else if(w===l){if(x=parseInt(r.slice(u,p),10),f==="1-based-closed"&&(x-=1),x>=i)return{startCoordinate:x,overlaps:!1};if((d===0||d===l)&&x+1<=n)return{startCoordinate:x,overlaps:!1}}else if(c==="VCF"&&w===4)I=r.slice(u,p);else if(w===d&&(c==="VCF"?this._getVcfEnd(x,I,r.slice(u,p)):parseInt(r.slice(u,p),10))<=n)return{overlaps:!1};if(u=p+1,w+=1,w>b)break}return{startCoordinate:x,overlaps:!0}}_getVcfEnd(e,t,n){let i=e+t.length;const r=n.includes("SVTYPE=TRA");if(n[0]!=="."&&!r){let s=";";for(let o=0;o<n.length;o+=1){if(s===";"&&n.slice(o,o+4)==="END="){let f=n.indexOf(";",o);f===-1&&(f=n.length),i=parseInt(n.slice(o+4,f),10);break}s=n[o]}}else if(r)return e+1;return i}async lineCount(e,t={}){return this.index.lineCount(e,t)}async _readRegion(e,t,n={}){const i=K.Buffer.alloc(t),{bytesRead:r,buffer:s}=await this.filehandle.read(i,0,t,e,n);return s.slice(0,r)}async readChunk(e,t={}){const n=await this._readRegion(e.minv.blockPosition,e.fetchedSize(),t);return Q(n,e)}}export{U as CSI,z as TBI,he as TabixIndexedFile};
