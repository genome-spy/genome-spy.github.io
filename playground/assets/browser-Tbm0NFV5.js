class f{constructor(e){this.blob=e}async read(e,r=0){if(!e)return new Uint8Array(0);const s=r,n=s+e,a=this.blob.slice(s,n);return a.bytes?a.bytes():new Uint8Array(await a.arrayBuffer())}async readFile(e){const r=typeof e=="string"?e:e==null?void 0:e.encoding;if(r==="utf8")return this.blob.text();if(r)throw new Error(`unsupported encoding: ${r}`);return this.blob.bytes?this.blob.bytes():new Uint8Array(await this.blob.arrayBuffer())}async stat(){return{size:this.blob.size}}async close(){}}function d(i){return(typeof i=="object"&&i!==null&&"message"in i?i.message:`${i}`).replace(/\.$/,"")}class u{constructor(e,r={}){this.baseOverrides={},this.url=e;const s=r.fetch||globalThis.fetch.bind(globalThis);r.overrides&&(this.baseOverrides=r.overrides),this.fetchImplementation=s}async fetch(e,r){const s=a=>new Error(`${d(a)} fetching ${e}`,{cause:a});let n;try{n=await this.fetchImplementation(e,r)}catch(a){if(`${a}`.includes("Failed to fetch")){console.warn(`generic-filehandle: refetching ${e} to attempt to work around chrome CORS header caching bug`);try{n=await this.fetchImplementation(e,{...r,cache:"reload"})}catch(c){throw s(c)}}else throw s(a)}return n}async read(e,r,s={}){if(e===0)return new Uint8Array(0);const{headers:n={},signal:a,overrides:c={}}=s;e<1/0?n.range=`bytes=${r}-${r+e-1}`:e===1/0&&r!==0&&(n.range=`bytes=${r}-`);const t=await this.fetch(this.url,{...this.baseOverrides,...c,headers:{...this.baseOverrides.headers,...c.headers,...n},method:"GET",redirect:"follow",mode:"cors",signal:a});if(!t.ok)throw new Error(`HTTP ${t.status} fetching ${this.url}`);if(t.status===200&&r===0||t.status===206){const l=t.headers.get("content-range"),o=/\/(\d+)$/.exec(l||"");o!=null&&o[1]&&(this._stat={size:parseInt(o[1],10)});const h=t.bytes?await t.bytes():new Uint8Array(await t.arrayBuffer());return h.byteLength<=e?h:h.subarray(0,e)}throw new Error(t.status===200?`${this.url} fetch returned status 200, expected 206`:`HTTP ${t.status} fetching ${this.url}`)}async readFile(e={}){let r,s;if(typeof e=="string")r=e,s={};else{r=e.encoding;const{encoding:l,...o}=e;s=o}const{headers:n={},signal:a,overrides:c={}}=s,t=await this.fetch(this.url,{...this.baseOverrides,...c,headers:{...this.baseOverrides.headers,...c.headers,...n},method:"GET",redirect:"follow",mode:"cors",signal:a});if(!t.ok)throw new Error(`HTTP ${t.status} fetching ${this.url}`);if(r==="utf8")return t.text();if(r)throw new Error(`unsupported encoding: ${r}`);return t.bytes?t.bytes():new Uint8Array(await t.arrayBuffer())}async stat(){if(!this._stat&&(await this.read(10,0),!this._stat))throw new Error(`unable to determine size of file at ${this.url}`);return this._stat}async close(){}}class w{readFile(){throw new Error("unimplemented")}read(){throw new Error("unimplemented")}close(){throw new Error("unimplemented")}}export{f as BlobFile,w as LocalFile,u as RemoteFile};
