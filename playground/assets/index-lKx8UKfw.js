import{L as g}from"./__vite-browser-external-_eDSiqyj.js";import{b as w}from"./index-X47Qq1Ab.js";import{L as x,u as E}from"./long-GBRvvkNx.js";import"./_commonjsHelpers-5FjdjvmD.js";const m=1;class _{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else if(t)this.filehandle=new g(t);else throw new TypeError("either filehandle or path must be defined")}_readLongWithOverflow(e,t=0,i=!0){const n=x.fromBytesLE(e.slice(t,t+8),i);if(n.greaterThan(Number.MAX_SAFE_INTEGER)||n.lessThan(Number.MIN_SAFE_INTEGER))throw new TypeError("integer overflow");return n.toNumber()}_getIndex(){return this.index||(this.index=this._readIndex()),this.index}async _readIndex(){let e=w.Buffer.allocUnsafe(8);await this.filehandle.read(e,0,8,0);const t=this._readLongWithOverflow(e,0,!0);if(!t)return[[0,0]];const i=new Array(t+1);i[0]=[0,0];const n=8*2*t;if(n>Number.MAX_SAFE_INTEGER)throw new TypeError("integer overflow");e=w.Buffer.allocUnsafe(n),await this.filehandle.read(e,0,n,8);for(let s=0;s<t;s+=1){const r=this._readLongWithOverflow(e,s*16),a=this._readLongWithOverflow(e,s*16+8);i[s+1]=[r,a]}return i}async getLastBlock(){const e=await this._getIndex();if(e.length)return e[e.length-1]}async getRelevantBlocksForRead(e,t){const i=t+e;if(e===0)return[];const n=await this._getIndex(),s=[],r=(h,u)=>{const p=h[m],b=u?u[m]:1/0;return p<=t&&b>t?0:p<t?-1:1};let a=0,f=n.length-1,o=Math.floor(n.length/2),d=r(n[o],n[o+1]);for(;d!==0;)d>0?f=o-1:d<0&&(a=o+1),o=Math.ceil((f-a)/2)+a,d=r(n[o],n[o+1]);s.push(n[o]);let c=o+1;for(;c<n.length&&(s.push(n[c]),!(n[c][m]>=i));c+=1);return s[s.length-1][m]<i&&s.push([]),s}}class y{constructor({filehandle:e,path:t,gziFilehandle:i,gziPath:n}){if(e)this.filehandle=e;else if(t)this.filehandle=new g(t);else throw new TypeError("either filehandle or path must be defined");if(!i&&!n&&!t)throw new TypeError("either gziFilehandle or gziPath must be defined");this.gzi=new _({filehandle:i,path:!i&&!n&&t?n:`${t}.gzi`})}async stat(){const e=await this.filehandle.stat();return Object.assign(e,{size:await this.getUncompressedFileSize(),blocks:void 0,blksize:void 0})}async getUncompressedFileSize(){const[,e]=await this.gzi.getLastBlock(),{size:t}=await this.filehandle.stat(),i=w.Buffer.allocUnsafe(4),{bytesRead:n}=await this.filehandle.read(i,0,4,t-28-4);if(n!==4)throw new Error("read error");const s=i.readUInt32LE(0);return e+s}async _readAndUncompressBlock(e,[t],[i]){let n=i;n||(n=(await this.filehandle.stat()).size);const s=n-t;return await this.filehandle.read(e,0,s,t),await E(e.slice(0,s))}async read(e,t,i,n){const s=await this.gzi.getRelevantBlocksForRead(i,n),r=w.Buffer.allocUnsafe(32768*2);let a=t,f=0;for(let o=0;o<s.length-1;o+=1){const d=await this._readAndUncompressBlock(r,s[o],s[o+1]),[,c]=s[o],h=c>=n?0:n-c,u=Math.min(n+i,c+d.length)-c;h>=0&&h<d.length&&(d.copy(e,a,h,u),a+=u-h,f+=u-h)}return{bytesRead:f,buffer:e}}}function S(l,e){return l.offset+l.lineBytes*Math.floor(e/l.lineLength)+e%l.lineLength}async function I(l,e){const t=await l.readFile(e);if(!(t&&t.length))throw new Error("No data read from FASTA index (FAI) file");let i=0,n;const s=t.toString("utf8").split(/\r?\n/).filter(r=>/\S/.test(r)).map(r=>r.split("	")).filter(r=>r[0]!=="").map(r=>((!n||n.name!==r[0])&&(n={name:r[0],id:i},i+=1),{id:n.id,name:r[0],length:+r[1],start:0,end:+r[1],offset:+r[2],lineLength:+r[3],lineBytes:+r[4]}));return{name:Object.fromEntries(s.map(r=>[r.name,r])),id:Object.fromEntries(s.map(r=>[r.id,r]))}}class B{constructor({fasta:e,fai:t,path:i,faiPath:n,chunkSizeLimit:s=1e6}){if(e)this.fasta=e;else if(i)this.fasta=new g(i);else throw new Error("Need to pass filehandle for fasta or path to localfile");if(t)this.fai=t;else if(n)this.fai=new g(n);else if(i)this.fai=new g(`${i}.fai`);else throw new Error("Need to pass filehandle for  or path to localfile");this.chunkSizeLimit=s}async _getIndexes(e){return this.indexes||(this.indexes=I(this.fai,e)),this.indexes}async getSequenceNames(e){return Object.keys((await this._getIndexes(e)).name)}async getSequenceSizes(e){const t={},i=await this._getIndexes(e),n=Object.values(i.id);for(let s=0;s<n.length;s+=1)t[n[s].name]=n[s].length;return t}async getSequenceSize(e,t){var i;return(i=(await this._getIndexes(t)).name[e])===null||i===void 0?void 0:i.length}async hasReferenceSequence(e,t){return!!(await this._getIndexes(t)).name[e]}async getResiduesById(e,t,i,n){const s=(await this._getIndexes(n)).id[e];if(s)return this._fetchFromIndexEntry(s,t,i,n)}async getResiduesByName(e,t,i,n){const s=(await this._getIndexes(n)).name[e];if(s)return this._fetchFromIndexEntry(s,t,i,n)}async getSequence(e,t,i,n){return this.getResiduesByName(e,t,i,n)}async _fetchFromIndexEntry(e,t=0,i,n){let s=i;if(t<0)throw new TypeError("regionStart cannot be less than 0");if((s===void 0||s>e.length)&&(s=e.length),t>=s)return"";const r=S(e,t),a=S(e,s)-r;if(a>this.chunkSizeLimit)throw new Error(`data size of ${a.toLocaleString()} bytes exceeded chunk size limit of ${this.chunkSizeLimit.toLocaleString()} bytes`);const f=Buffer.allocUnsafe(a);return await this.fasta.read(f,0,a,r,n),f.toString("utf8").replace(/\s+/g,"")}}class O extends B{constructor({fasta:e,path:t,fai:i,faiPath:n,gzi:s,gziPath:r,chunkSizeLimit:a}){super({fasta:e,path:t,fai:i,faiPath:n,chunkSizeLimit:a}),e&&s?this.fasta=new y({filehandle:e,gziFilehandle:s}):t&&r&&(this.fasta=new y({path:t,gziPath:r}))}}function L(l){return l.split(">").filter(e=>/\S/.test(e)).map(e=>{const[t,...i]=e.split(`
`),[n,...s]=t.split(" "),r=i.join("").replace(/\s/g,"");return{id:n,description:s.join(" "),sequence:r}})}class v{constructor({fasta:e,path:t}){if(e)this.fasta=e;else if(t)this.fasta=new g(t);else throw new Error("Need to pass fasta or path");this.data=this.fasta.readFile().then(i=>{const n=i.toString("utf8");return L(n)})}async fetch(e,t,i){const s=(await this.data).find(a=>a.id===e),r=i-t;if(!s)throw new Error(`no sequence with id ${e} exists`);return s.sequence.substr(t,r)}async getSequenceNames(){return(await this.data).map(t=>t.id)}}export{O as BgzipIndexedFasta,v as FetchableSmallFasta,B as IndexedFasta,L as parseSmallFasta};
