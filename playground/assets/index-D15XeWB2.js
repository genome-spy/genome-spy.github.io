import{g as l}from"./_commonjsHelpers-C932wzq6.js";class d{}class f{constructor(){this.signals=new Set,this.abortController=new AbortController}addSignal(t=new d){if(this.signal.aborted)throw new Error("cannot add a signal, already aborted!");this.signals.add(t),t.aborted?this.handleAborted(t):typeof t.addEventListener=="function"&&t.addEventListener("abort",()=>{this.handleAborted(t)})}handleAborted(t){this.signals.delete(t),this.signals.size===0&&this.abortController.abort()}get signal(){return this.abortController.signal}abort(){this.abortController.abort()}}class u{constructor(){this.callbacks=new Set}addCallback(t=()=>{}){this.callbacks.add(t),t(this.currentMessage)}callback(t){this.currentMessage=t;for(const e of this.callbacks)e(t)}}class n{constructor({fill:t,cache:e}){if(typeof t!="function")throw new TypeError("must pass a fill function");if(typeof e!="object")throw new TypeError("must pass a cache object");if(typeof e.get!="function"||typeof e.set!="function"||typeof e.delete!="function")throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");this.cache=e,this.fillCallback=t}static isAbortException(t){return t.name==="AbortError"||t.code==="ERR_ABORTED"||t.message==="AbortError: aborted"||t.message==="Error: aborted"}evict(t,e){this.cache.get(t)===e&&this.cache.delete(t)}fill(t,e,r,a){const s=new f,c=new u;c.addCallback(a);const i={aborter:s,promise:this.fillCallback(e,s.signal,o=>{c.callback(o)}),settled:!1,statusReporter:c,get aborted(){return this.aborter.signal.aborted}};i.aborter.addSignal(r),i.aborter.signal.addEventListener("abort",()=>{i.settled||this.evict(t,i)}),i.promise.then(()=>{i.settled=!0},()=>{i.settled=!0,this.evict(t,i)}).catch(o=>{throw console.error(o),o}),this.cache.set(t,i)}static checkSinglePromise(t,e){function r(){if(e!=null&&e.aborted)throw Object.assign(new Error("aborted"),{code:"ERR_ABORTED"})}return t.then(a=>(r(),a),a=>{throw r(),a})}has(t){return this.cache.has(t)}get(t,e,r,a){if(!r&&e instanceof AbortSignal)throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");const s=this.cache.get(t);return s?s.aborted&&!s.settled?(this.evict(t,s),this.get(t,e,r,a)):s.settled?s.promise:(s.aborter.addSignal(r),s.statusReporter.addCallback(a),n.checkSinglePromise(s.promise,r)):(this.fill(t,e,r,a),n.checkSinglePromise(this.cache.get(t).promise,r))}delete(t){const e=this.cache.get(t);e&&(e.settled||e.aborter.abort(),this.cache.delete(t))}clear(){const t=this.cache.keys();let e=0;for(let r=t.next();!r.done;r=t.next())this.delete(r.value),e+=1;return e}}class b{constructor(t={}){if(!(t.maxSize&&t.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");this.maxSize=t.maxSize,this.cache=new Map,this.oldCache=new Map,this._size=0}_set(t,e){this.cache.set(t,e),this._size++,this._size>=this.maxSize&&(this._size=0,this.oldCache=this.cache,this.cache=new Map)}get(t){if(this.cache.has(t))return this.cache.get(t);if(this.oldCache.has(t)){const e=this.oldCache.get(t);return this.oldCache.delete(t),this._set(t,e),e}}set(t,e){return this.cache.has(t)?this.cache.set(t,e):this._set(t,e),this}has(t){return this.cache.has(t)||this.oldCache.has(t)}peek(t){if(this.cache.has(t))return this.cache.get(t);if(this.oldCache.has(t))return this.oldCache.get(t)}delete(t){const e=this.cache.delete(t);return e&&this._size--,this.oldCache.delete(t)||e}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}*keys(){for(const[t]of this)yield t}*values(){for(const[,t]of this)yield t}*[Symbol.iterator](){for(const t of this.cache)yield t;for(const t of this.oldCache){const[e]=t;this.cache.has(e)||(yield t)}}get size(){let t=0;for(const e of this.oldCache.keys())this.cache.has(e)||t++;return this._size+t}}var g=b;const p=l(g);export{n as A,p as L};
