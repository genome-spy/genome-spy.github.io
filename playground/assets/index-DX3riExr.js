import{A as te}from"./AbortablePromiseCache-Bzbqdtb1.js";import{I as Y,Z}from"./inflate-Ce7owuqY.js";import{LocalFile as E,RemoteFile as D}from"./browser-ChAEM03c.js";import{L as H}from"./index-DybQiFD5.js";function ne(s){let e=0;for(const t of s)e+=t.length;return e}function K(s,e){const t=new Uint8Array(e??ne(s));let n=0;for(const i of s)t.set(i,n),n+=i.length;return t}async function V(s){try{let e,t=0,n;const i=[];let o=0;do{const a=s.subarray(t);if(n=new Y(void 0),{strm:e}=n,n.push(a,Z),n.err)throw new Error(n.msg);t+=e.next_in;const r=n.result;i.push(r),o+=r.length}while(e.avail_in);return K(i,o)}catch(e){throw/incorrect header check/.exec(`${e}`)?new Error("problem decompressing block: incorrect gzip header check"):e}}async function ie(s,e,t){try{let n;const{minv:i,maxv:o}=e;let a=i.blockPosition,r=i.dataPosition;const l=[],m=[],c=[];let u=0,f=!1,g=0;do{const b=s.subarray(a-i.blockPosition),I=a.toString();let x,h;const p=t==null?void 0:t.get(I);if(p)x=p.buffer,h=p.nextIn,f=!0;else{const d=new Y(void 0);if({strm:n}=d,d.push(b,Z),d.err)throw new Error(d.msg);x=d.result,h=n.next_in,f=!1,t==null||t.set(I,{buffer:x,nextIn:h})}l.push(x);let w=x.length;m.push(a),c.push(r),l.length===1&&i.dataPosition&&(l[0]=l[0].subarray(i.dataPosition),w=l[0].length);const k=a;if(a+=h,r+=w,k>=o.blockPosition){l[u]=l[u].subarray(0,o.blockPosition===i.blockPosition?o.dataPosition-i.dataPosition+1:o.dataPosition+1),g+=l[u].length,m.push(a),c.push(r);break}g+=w,u++}while(f?a<s.length+i.blockPosition:n.avail_in);return{buffer:K(l,g),cpositions:m,dpositions:c}}catch(n){throw/incorrect header check/.exec(`${n}`)?new Error("problem decompressing block: incorrect gzip header check"):n}}class L{constructor(e,t,n,i){this.minv=e,this.maxv=t,this.bin=n,this._fetchedSize=i}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return this._fetchedSize!==void 0?this._fetchedSize:this.maxv.blockPosition+65536-this.minv.blockPosition}}class X{constructor({filehandle:e,renameRefSeqs:t=n=>n}){this.filehandle=e,this.renameRefSeq=t}async getMetadata(e={}){const{indices:t,...n}=await this.parse(e);return n}_findFirstData(e,t){return e?e.compareTo(t)>0?t:e:t}async parse(e={}){return this.parseP||(this.parseP=this._parse(e).catch(t=>{throw this.parseP=void 0,t})),this.parseP}async hasRefSeq(e,t={}){var i;return!!((i=(await this.parse(t)).indices[e])!=null&&i.binIndex)}_parseNameBytes(e){let t=0,n=0;const i=[],o={},a=new TextDecoder("utf8");for(let r=0;r<e.length;r+=1)if(!e[r]){if(n<r){const l=this.renameRefSeq(a.decode(e.subarray(n,r)));i[t]=l,o[l]=t}n=r+1,t+=1}return{refNameToId:o,refIdToName:i}}}const W=65536,re=W*W;function J(s,e=0){const t=s[e]|s[e+1]<<8|s[e+2]<<16|s[e+3]<<24;return((s[e+4]|s[e+5]<<8|s[e+6]<<16|s[e+7]<<24)>>>0)*re+(t>>>0)}class se extends Error{}function B(s){if(s&&s.aborted)if(typeof DOMException>"u"){const e=new se("aborted");throw e.code="ERR_ABORTED",e}else throw new DOMException("aborted","AbortError")}function oe(s,e){return e.minv.blockPosition-s.maxv.blockPosition<65e3&&e.maxv.blockPosition-s.minv.blockPosition<5e6}function Q(s,e){const t=[];let n;if(s.length===0)return s;s.sort(function(i,o){const a=i.minv.blockPosition-o.minv.blockPosition;return a===0?i.minv.dataPosition-o.minv.dataPosition:a});for(const i of s)(!e||i.maxv.compareTo(e)>0)&&(n===void 0?(t.push(i),n=i):oe(n,i)?i.maxv.compareTo(n.maxv)>0&&(n.maxv=i.maxv):(t.push(i),n=i));return t}class ${constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}}function T(s,e=0){return new $(s[e+7]*1099511627776+s[e+6]*4294967296+s[e+5]*16777216+s[e+4]*65536+s[e+3]*256+s[e+2],s[e+1]<<8|s[e])}const ae=21582659,ce=38359875,le={0:"generic",1:"SAM",2:"VCF"};function fe(s,e){return s*2**e}function G(s,e){return Math.floor(s/2**e)}class R extends X{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e,t={}){const n=await this.parse(t),i=n.refNameToId[e];if(i===void 0||!n.indices[i])return-1;const{stats:a}=n.indices[i];return a?a.lineCount:-1}indexCov(){throw new Error("CSI indexes do not support indexcov")}parseAuxData(e,t){const n=new DataView(e.buffer),i=n.getInt32(t,!0),o=i&65536?"zero-based-half-open":"1-based-closed",a=le[i&15];if(!a)throw new Error(`invalid Tabix preset format flags ${i}`);const r={ref:n.getInt32(t+4,!0),start:n.getInt32(t+8,!0),end:n.getInt32(t+12,!0)},l=n.getInt32(t+16,!0),m=l?String.fromCharCode(l):void 0,c=n.getInt32(t+20,!0),u=n.getInt32(t+24,!0),{refIdToName:f,refNameToId:g}=this._parseNameBytes(e.subarray(t+28,t+28+u));return{refIdToName:f,refNameToId:g,skipLines:c,metaChar:m,columnNumbers:r,format:a,coordinateType:o}}async _parse(e={}){const t=await V(await this.filehandle.readFile(e)),n=new DataView(t.buffer);let i;if(n.getUint32(0,!0)===ae)i=1;else if(n.getUint32(0,!0)===ce)i=2;else throw new Error("Not a CSI file");this.minShift=n.getInt32(4,!0),this.depth=n.getInt32(8,!0),this.maxBinNumber=((1<<(this.depth+1)*3)-1)/7;const o=2**(this.minShift+this.depth*3),a=n.getInt32(12,!0),r=a&&a>=30?this.parseAuxData(t,16):{refIdToName:[],refNameToId:{},metaChar:void 0,columnNumbers:{ref:0,start:1,end:2},coordinateType:"zero-based-half-open",format:"generic"},l=n.getInt32(16+a,!0);let m,c=16+a+4;const u=new Array(l).fill(0).map(()=>{const f=n.getInt32(c,!0);c+=4;const g={};let b;for(let I=0;I<f;I+=1){const x=n.getUint32(c,!0);if(x>this.maxBinNumber)b=this.parsePseudoBin(t,c+4),c+=48;else{const h=T(t,c+4);m=this._findFirstData(m,h);const p=n.getInt32(c+12,!0);c+=16;const w=new Array(p);for(let k=0;k<p;k+=1){const d=T(t,c),C=T(t,c+8);c+=16,w[k]=new L(d,C,x)}g[x]=w}}return{binIndex:g,stats:b}});return{...r,csi:!0,refCount:l,maxBlockSize:65536,firstDataLine:m,csiVersion:i,indices:u,depth:this.depth,maxBinNumber:this.maxBinNumber,maxRefLength:o}}parsePseudoBin(e,t){return{lineCount:J(e,t+28)}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const o=await this.parse(i),a=o.refNameToId[e];if(a===void 0)return[];const r=o.indices[a];if(!r)return[];const l=this.reg2bins(t,n),m=[];for(const[c,u]of l)for(let f=c;f<=u;f++)if(r.binIndex[f])for(const g of r.binIndex[f])m.push(new L(g.minv,g.maxv,f));return Q(m,new $(0,0))}reg2bins(e,t){e-=1,e<1&&(e=1),t>2**50&&(t=2**34),t-=1;let n=0,i=0,o=this.minShift+this.depth*3;const a=[];for(;n<=this.depth;o-=3,i+=fe(1,n*3),n+=1){const r=i+G(e,o),l=i+G(t,o);if(l-r+a.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);a.push([r,l])}return a}}const he=21578324,j=14;function de(s,e){return s+=1,e-=1,[[0,0],[1+(s>>26),1+(e>>26)],[9+(s>>23),9+(e>>23)],[73+(s>>20),73+(e>>20)],[585+(s>>17),585+(e>>17)],[4681+(s>>14),4681+(e>>14)]]}class _ extends X{async lineCount(e,t={}){var a;const n=await this.parse(t),i=n.refNameToId[e];return i===void 0||!n.indices[i]?-1:((a=n.indices[i].stats)==null?void 0:a.lineCount)??-1}async _parse(e={}){const t=await this.filehandle.readFile(e),n=await V(t);B(e.signal);const i=new DataView(n.buffer);if(i.getUint32(0,!0)!==he)throw new Error("Not a TBI file");const a=i.getUint32(4,!0),r=i.getUint32(8,!0),l=r&65536?"zero-based-half-open":"1-based-closed",c={0:"generic",1:"SAM",2:"VCF"}[r&15];if(!c)throw new Error(`invalid Tabix preset format flags ${r}`);const u={ref:i.getInt32(12,!0),start:i.getInt32(16,!0),end:i.getInt32(20,!0)},f=i.getInt32(24,!0),g=5,b=((1<<(g+1)*3)-1)/7,I=2**(14+g*3),x=f?String.fromCharCode(f):void 0,h=i.getInt32(28,!0),p=i.getInt32(32,!0),{refNameToId:w,refIdToName:k}=this._parseNameBytes(n.slice(36,36+p));let d=36+p,C;return{indices:new Array(a).fill(0).map(()=>{const P=i.getInt32(d,!0);d+=4;const S={};let A;for(let v=0;v<P;v+=1){const F=i.getUint32(d,!0);if(d+=4,F>b+1)throw new Error("tabix index contains too many bins, please use a CSI index");if(F===b+1){const N=i.getInt32(d,!0);d+=4,N===2&&(A=this.parsePseudoBin(n,d)),d+=16*N}else{const N=i.getInt32(d,!0);d+=4;const U=new Array(N);for(let M=0;M<N;M+=1){const q=T(n,d),ee=T(n,d+8);d+=16,C=this._findFirstData(C,q),U[M]=new L(q,ee,F)}S[F]=U}}const O=i.getInt32(d,!0);d+=4;const z=new Array(O);for(let v=0;v<O;v+=1)z[v]=T(n,d),d+=8,C=this._findFirstData(C,z[v]);return{binIndex:S,linearIndex:z,stats:A}}),metaChar:x,maxBinNumber:b,maxRefLength:I,skipLines:h,firstDataLine:C,columnNumbers:u,coordinateType:l,format:c,refIdToName:k,refNameToId:w,maxBlockSize:65536}}parsePseudoBin(e,t){return{lineCount:J(e,t+16)}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const o=await this.parse(i),a=o.refNameToId[e];if(a===void 0)return[];const r=o.indices[a];if(!r)return[];(r.linearIndex.length>0?r.linearIndex[t>>j>=r.linearIndex.length?r.linearIndex.length-1:t>>j]:new $(0,0))||console.warn("querying outside of possible tabix range");const m=de(t,n),c=[];for(const[I,x]of m)for(let h=I;h<=x;h++)if(r.binIndex[h])for(const p of r.binIndex[h])c.push(new L(p.minv,p.maxv,h));const u=r.linearIndex.length;let f;const g=Math.min(t>>14,u-1),b=Math.min(n>>14,u-1);for(let I=g;I<=b;++I){const x=r.linearIndex[I];x&&(!f||x.compareTo(f)<0)&&(f=x)}return Q(c,f)}}class pe{constructor({path:e,filehandle:t,url:n,tbiPath:i,tbiUrl:o,tbiFilehandle:a,csiPath:r,csiUrl:l,csiFilehandle:m,renameRefSeqs:c=f=>f,chunkCacheSize:u=5*2**20}){if(this.cache=new H({maxSize:1e3}),t)this.filehandle=t;else if(e)this.filehandle=new E(e);else if(n)this.filehandle=new D(n);else throw new TypeError("must provide either filehandle or path");if(a)this.index=new _({filehandle:a,renameRefSeqs:c});else if(m)this.index=new R({filehandle:m,renameRefSeqs:c});else if(i)this.index=new _({filehandle:new E(i),renameRefSeqs:c});else if(r)this.index=new R({filehandle:new E(r),renameRefSeqs:c});else if(e)this.index=new _({filehandle:new E(`${e}.tbi`),renameRefSeqs:c});else if(l)this.index=new R({filehandle:new D(l)});else if(o)this.index=new _({filehandle:new D(o)});else if(n)this.index=new _({filehandle:new D(`${n}.tbi`)});else throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl");this.renameRefSeq=c,this.chunkCache=new te({cache:new H({maxSize:Math.floor(u/65536)}),fill:(f,g)=>this.readChunk(f,{signal:g})})}calculateFileOffset(e,t,n,i,o){return e[n]*256+(i-t[n])+o+1}async getLines(e,t,n,i){let o,a={},r;typeof i=="function"?r=i:(a=i,r=i.lineCallback,o=i.signal);const l=await this.index.getMetadata(a);B(o);const m=t??0,c=n??l.maxRefLength;if(!(m<=c))throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");if(m===c)return;const u=await this.index.blocksForRange(e,m,c,a);B(o);const f=new TextDecoder("utf8");for(const g of u){const{buffer:b,cpositions:I,dpositions:x}=await this.chunkCache.get(g.toString(),g,o);B(o);let h=0,p=0;const w=f.decode(b);if(b.length==w.length)for(;h<w.length;){const d=w.indexOf(`
`,h);if(d===-1)break;const C=w.slice(h,d);if(x){const S=h+g.minv.dataPosition;for(;p<x.length&&S>=x[p];)p++}const{startCoordinate:y,overlaps:P}=this.checkLine(l,e,m,c,C);if(P)r(C,this.calculateFileOffset(I,x,p,h,g.minv.dataPosition));else if(y!==void 0&&y>=c)return;h=d+1}else for(;h<b.length;){const d=b.indexOf(10,h);if(d===-1)break;const C=b.slice(h,d),y=f.decode(C);if(x){const A=h+g.minv.dataPosition;for(;p<x.length&&A>=x[p];)p++}const{startCoordinate:P,overlaps:S}=this.checkLine(l,e,m,c,y);if(S)r(y,this.calculateFileOffset(I,x,p,h,g.minv.dataPosition));else if(P!==void 0&&P>=c)return;h=d+1}}}async getMetadata(e={}){return this.index.getMetadata(e)}async getHeaderBuffer(e={}){const{firstDataLine:t,metaChar:n,maxBlockSize:i}=await this.getMetadata(e);B(e.signal);const o=((t==null?void 0:t.blockPosition)||0)+i,a=await this.filehandle.read(o,0,e),r=await V(a);if(n){let l=-1;const m=10,c=n.charCodeAt(0);for(let u=0,f=r.length;u<f;u++){const g=r[u];if(u===l+1&&g!==c)break;g===m&&(l=u)}return r.subarray(0,l+1)}return r}async getHeader(e={}){const t=new TextDecoder("utf8"),n=await this.getHeaderBuffer(e);return t.decode(n)}async getReferenceSequenceNames(e={}){return(await this.getMetadata(e)).refIdToName}checkLine(e,t,n,i,o){const{columnNumbers:a,metaChar:r,coordinateType:l,format:m}=e;if(r&&o.startsWith(r))return{overlaps:!1};let{ref:c,start:u,end:f}=a;c||(c=0),u||(u=0),f||(f=0),m==="VCF"&&(f=8);const g=Math.max(c,u,f);let b=1,I=0,x="",h=-1/0;const p=o.length;for(let w=0;w<p+1;w++)if(o[w]==="	"||w===p){if(b===c){if(this.renameRefSeq(o.slice(I,w))!==t)return{overlaps:!1}}else if(b===u){if(h=Number.parseInt(o.slice(I,w),10),l==="1-based-closed"&&(h-=1),h>=i)return{startCoordinate:h,overlaps:!1};if((f===0||f===u)&&h+1<=n)return{startCoordinate:h,overlaps:!1}}else if(m==="VCF"&&b===4)x=o.slice(I,w);else if(b===f&&(m==="VCF"?this._getVcfEnd(h,x,o.slice(I,w)):Number.parseInt(o.slice(I,w),10))<=n)return{overlaps:!1};if(b===g)break;I=w+1,b+=1}return{startCoordinate:h,overlaps:!0}}_getVcfEnd(e,t,n){let i=e+t.length;const o=n.includes("SVTYPE=TRA");if(n[0]!=="."&&!o){const r=/(?:^|;)END=([^;]+)/.exec(n);r&&(i=Number.parseInt(r[1],10))}else if(o)return e+1;return i}async lineCount(e,t={}){return this.index.lineCount(e,t)}async readChunk(e,t={}){const n=await this.filehandle.read(e.fetchedSize(),e.minv.blockPosition,t);return ie(n,e,this.cache)}}export{R as CSI,_ as TBI,pe as TabixIndexedFile};
