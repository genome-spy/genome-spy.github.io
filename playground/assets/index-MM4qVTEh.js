import{A as J}from"./AbortablePromiseCache-Bzbqdtb1.js";import{u as E,Q as U,a as K}from"./unzip-CkEvYgev.js";import{LocalFile as F,RemoteFile as M}from"./browser-Tbm0NFV5.js";class L{constructor(e,t,n,i){this.minv=e,this.maxv=t,this.bin=n,this._fetchedSize=i}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return this._fetchedSize!==void 0?this._fetchedSize:this.maxv.blockPosition+65536-this.minv.blockPosition}}class j{constructor({filehandle:e,renameRefSeqs:t=n=>n}){this.filehandle=e,this.renameRefSeq=t}async getMetadata(e={}){const{indices:t,...n}=await this.parse(e);return n}_findFirstData(e,t){return e?e.compareTo(t)>0?t:e:t}async parse(e={}){return this.parseP||(this.parseP=this._parse(e).catch(t=>{throw this.parseP=void 0,t})),this.parseP}async hasRefSeq(e,t={}){var i;return!!((i=(await this.parse(t)).indices[e])!=null&&i.binIndex)}_parseNameBytes(e){let t=0,n=0;const i=[],o={},r=new TextDecoder("utf8");for(let s=0;s<e.length;s+=1)if(!e[s]){if(n<s){const c=this.renameRefSeq(r.decode(e.subarray(n,s)));i[t]=c,o[c]=t}n=s+1,t+=1}return{refNameToId:o,refIdToName:i}}}const H=65536,Z=H*H;function Q(a,e=0){const t=a[e]|a[e+1]<<8|a[e+2]<<16|a[e+3]<<24;return((a[e+4]|a[e+5]<<8|a[e+6]<<16|a[e+7]<<24)>>>0)*Z+(t>>>0)}function ee(a,e){return e.minv.blockPosition-a.maxv.blockPosition<65e3&&e.maxv.blockPosition-a.minv.blockPosition<5e6}function X(a,e){const t=[];let n;if(a.length===0)return a;a.sort(function(i,o){const r=i.minv.blockPosition-o.minv.blockPosition;return r===0?i.minv.dataPosition-o.minv.dataPosition:r});for(const i of a)(!e||i.maxv.compareTo(e)>0)&&(n===void 0?(t.push(i),n=i):ee(n,i)?i.maxv.compareTo(n.maxv)>0&&(n.maxv=i.maxv):(t.push(i),n=i));return t}class O{constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}}function A(a,e=0){return new O(a[e+7]*1099511627776+a[e+6]*4294967296+a[e+5]*16777216+a[e+4]*65536+a[e+3]*256+a[e+2],a[e+1]<<8|a[e])}const te=21582659,ne=38359875,ie={0:"generic",1:"SAM",2:"VCF"};function se(a,e){return a*2**e}function W(a,e){return Math.floor(a/2**e)}class q extends j{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e,t={}){const n=await this.parse(t),i=n.refNameToId[e];if(i===void 0||!n.indices[i])return-1;const{stats:r}=n.indices[i];return r?r.lineCount:-1}indexCov(){throw new Error("CSI indexes do not support indexcov")}parseAuxData(e,t){const n=new DataView(e.buffer),i=n.getInt32(t,!0),o=i&65536?"zero-based-half-open":"1-based-closed",r=ie[i&15];if(!r)throw new Error(`invalid Tabix preset format flags ${i}`);const s={ref:n.getInt32(t+4,!0),start:n.getInt32(t+8,!0),end:n.getInt32(t+12,!0)},c=n.getInt32(t+16,!0),m=c?String.fromCharCode(c):void 0,f=n.getInt32(t+20,!0),x=n.getInt32(t+24,!0),{refIdToName:d,refNameToId:l}=this._parseNameBytes(e.subarray(t+28,t+28+x));return{refIdToName:d,refNameToId:l,skipLines:f,metaChar:m,columnNumbers:s,format:r,coordinateType:o}}async _parse(e={}){const t=await E(await this.filehandle.readFile(e)),n=new DataView(t.buffer);let i;if(n.getUint32(0,!0)===te)i=1;else if(n.getUint32(0,!0)===ne)i=2;else throw new Error("Not a CSI file");this.minShift=n.getInt32(4,!0),this.depth=n.getInt32(8,!0),this.maxBinNumber=((1<<(this.depth+1)*3)-1)/7;const o=2**(this.minShift+this.depth*3),r=n.getInt32(12,!0),s=r&&r>=30?this.parseAuxData(t,16):{refIdToName:[],refNameToId:{},metaChar:void 0,columnNumbers:{ref:0,start:1,end:2},coordinateType:"zero-based-half-open",format:"generic"},c=n.getInt32(16+r,!0);let m,f=16+r+4;const x=new Array(c).fill(0).map(()=>{const d=n.getInt32(f,!0);f+=4;const l={};let h;for(let b=0;b<d;b+=1){const k=n.getUint32(f,!0);if(k>this.maxBinNumber)h=this.parsePseudoBin(t,f+4),f+=48;else{const w=A(t,f+4);m=this._findFirstData(m,w);const p=n.getInt32(f+12,!0);f+=16;const I=new Array(p);for(let g=0;g<p;g+=1){const u=A(t,f),S=A(t,f+8);f+=16,I[g]=new L(u,S,k)}l[k]=I}}return{binIndex:l,stats:h}});return{...s,csi:!0,refCount:c,maxBlockSize:65536,firstDataLine:m,csiVersion:i,indices:x,depth:this.depth,maxBinNumber:this.maxBinNumber,maxRefLength:o}}parsePseudoBin(e,t){return{lineCount:Q(e,t+28)}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const o=await this.parse(i),r=o.refNameToId[e];if(r===void 0)return[];const s=o.indices[r];if(!s)return[];const c=this.reg2bins(t,n),m=[];for(const[f,x]of c)for(let d=f;d<=x;d++)if(s.binIndex[d])for(const l of s.binIndex[d])m.push(new L(l.minv,l.maxv,d));return X(m,new O(0,0))}reg2bins(e,t){e-=1,e<1&&(e=1),t>2**50&&(t=2**34),t-=1;let n=0,i=0,o=this.minShift+this.depth*3;const r=[];for(;n<=this.depth;o-=3,i+=se(1,n*3),n+=1){const s=i+W(e,o),c=i+W(t,o);if(c-s+r.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);r.push([s,c])}return r}}const re=21578324,G=14;function ae(a,e){return a+=1,e-=1,[[0,0],[1+(a>>26),1+(e>>26)],[9+(a>>23),9+(e>>23)],[73+(a>>20),73+(e>>20)],[585+(a>>17),585+(e>>17)],[4681+(a>>14),4681+(e>>14)]]}class R extends j{async lineCount(e,t={}){var r;const n=await this.parse(t),i=n.refNameToId[e];return i===void 0||!n.indices[i]?-1:((r=n.indices[i].stats)==null?void 0:r.lineCount)??-1}async _parse(e={}){const t=await this.filehandle.readFile(e),n=await E(t),i=new DataView(n.buffer);if(i.getUint32(0,!0)!==re)throw new Error("Not a TBI file");const r=i.getUint32(4,!0),s=i.getUint32(8,!0),c=s&65536?"zero-based-half-open":"1-based-closed",f={0:"generic",1:"SAM",2:"VCF"}[s&15];if(!f)throw new Error(`invalid Tabix preset format flags ${s}`);const x={ref:i.getInt32(12,!0),start:i.getInt32(16,!0),end:i.getInt32(20,!0)},d=i.getInt32(24,!0),l=5,h=((1<<(l+1)*3)-1)/7,b=2**(14+l*3),k=d?String.fromCharCode(d):void 0,w=i.getInt32(28,!0),p=i.getInt32(32,!0),{refNameToId:I,refIdToName:g}=this._parseNameBytes(n.slice(36,36+p));let u=36+p,S;return{indices:new Array(r).fill(0).map(()=>{const T=i.getInt32(u,!0);u+=4;const N={};let _;for(let v=0;v<T;v+=1){const y=i.getUint32(u,!0);if(u+=4,y>h+1)throw new Error("tabix index contains too many bins, please use a CSI index");if(y===h+1){const P=i.getInt32(u,!0);u+=4,P===2&&(_=this.parsePseudoBin(n,u)),u+=16*P}else{const P=i.getInt32(u,!0);u+=4;const D=new Array(P);for(let V=0;V<P;V+=1){const $=A(n,u),Y=A(n,u+8);u+=16,S=this._findFirstData(S,$),D[V]=new L($,Y,y)}N[y]=D}}const z=i.getInt32(u,!0);u+=4;const B=new Array(z);for(let v=0;v<z;v+=1)B[v]=A(n,u),u+=8,S=this._findFirstData(S,B[v]);return{binIndex:N,linearIndex:B,stats:_}}),metaChar:k,maxBinNumber:h,maxRefLength:b,skipLines:w,firstDataLine:S,columnNumbers:x,coordinateType:c,format:f,refIdToName:g,refNameToId:I,maxBlockSize:65536}}parsePseudoBin(e,t){return{lineCount:Q(e,t+16)}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const o=await this.parse(i),r=o.refNameToId[e];if(r===void 0)return[];const s=o.indices[r];if(!s)return[];(s.linearIndex.length>0?s.linearIndex[t>>G>=s.linearIndex.length?s.linearIndex.length-1:t>>G]:new O(0,0))||console.warn("querying outside of possible tabix range");const m=ae(t,n),f=[];for(const[b,k]of m)for(let w=b;w<=k;w++)if(s.binIndex[w])for(const p of s.binIndex[w])f.push(new L(p.minv,p.maxv,w));const x=s.linearIndex.length;let d;const l=Math.min(t>>14,x-1),h=Math.min(n>>14,x-1);for(let b=l;b<=h;++b){const k=s.linearIndex[b];k&&(!d||k.compareTo(d)<0)&&(d=k)}return X(f,d)}}class he{constructor({path:e,filehandle:t,url:n,tbiPath:i,tbiUrl:o,tbiFilehandle:r,csiPath:s,csiUrl:c,csiFilehandle:m,renameRefSeqs:f,chunkCacheSize:x=5*2**20}){this.cache=new U({maxSize:1e3});const d=f??(l=>l);if(t)this.filehandle=t;else if(e)this.filehandle=new F(e);else if(n)this.filehandle=new M(n);else throw new TypeError("must provide either filehandle or path");if(r)this.index=new R({filehandle:r,renameRefSeqs:d});else if(m)this.index=new q({filehandle:m,renameRefSeqs:d});else if(i)this.index=new R({filehandle:new F(i),renameRefSeqs:d});else if(s)this.index=new q({filehandle:new F(s),renameRefSeqs:d});else if(e)this.index=new R({filehandle:new F(`${e}.tbi`),renameRefSeqs:d});else if(c)this.index=new q({filehandle:new M(c)});else if(o)this.index=new R({filehandle:new M(o)});else if(n)this.index=new R({filehandle:new M(`${n}.tbi`)});else throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl");this.renameRefSeq=d,this.hasCustomRenameRefSeq=f!==void 0,this.chunkCache=new J({cache:new U({maxSize:Math.floor(x/65536)}),fill:(l,h)=>this.readChunk(l,{signal:h})})}calculateFileOffset(e,t,n,i,o){return e[n]*256+(i-t[n])+o+1}async getLines(e,t,n,i){var I;let o,r={},s;typeof i=="function"?s=i:(r=i,s=i.lineCallback,o=i.signal);const c=await this.index.getMetadata(r),m=t??0,f=n??c.maxRefLength;if(!(m<=f))throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");if(m===f)return;const x=await this.index.blocksForRange(e,m,f,r),d=new TextDecoder("utf8"),l=c.format==="VCF",h={ref:c.columnNumbers.ref||0,start:c.columnNumbers.start||0,end:l?8:c.columnNumbers.end||0},b=Math.max(h.ref,h.start,h.end),k=(I=c.metaChar)==null?void 0:I.charCodeAt(0),w=c.coordinateType==="1-based-closed"?-1:0,p=!this.hasCustomRenameRefSeq;for(const g of x){const{buffer:u,cpositions:S,dpositions:C}=await this.chunkCache.get(g.toString(),g,o);let T=0,N=0;const _=d.decode(u);if(u.length==_.length)for(;T<_.length;){const B=_.indexOf(`
`,T);if(B===-1)break;const v=_.slice(T,B);if(C){const P=T+g.minv.dataPosition;for(;N<C.length&&P>=C[N];)N++}const y=this.checkLine(e,m,f,v,h.ref,h.start,h.end,b,k,w,l,p);if(y===null)return;y!==void 0&&s(v,this.calculateFileOffset(S,C,N,T,g.minv.dataPosition),y.start,y.end),T=B+1}else for(;T<u.length;){const B=u.indexOf(10,T);if(B===-1)break;const v=u.slice(T,B),y=d.decode(v);if(C){const D=T+g.minv.dataPosition;for(;N<C.length&&D>=C[N];)N++}const P=this.checkLine(e,m,f,y,h.ref,h.start,h.end,b,k,w,l,p);if(P===null)return;P!==void 0&&s(y,this.calculateFileOffset(S,C,N,T,g.minv.dataPosition),P.start,P.end),T=B+1}}}async getMetadata(e={}){return this.index.getMetadata(e)}async getHeaderBuffer(e={}){const{firstDataLine:t,metaChar:n,maxBlockSize:i}=await this.getMetadata(e),o=((t==null?void 0:t.blockPosition)||0)+i,r=await this.filehandle.read(o,0,e),s=await E(r);if(n){let c=-1;const m=10,f=n.charCodeAt(0);for(let x=0,d=s.length;x<d;x++){const l=s[x];if(x===c+1&&l!==f)break;l===m&&(c=x)}return s.subarray(0,c+1)}return s}async getHeader(e={}){const t=new TextDecoder("utf8"),n=await this.getHeaderBuffer(e);return t.decode(n)}async getReferenceSequenceNames(e={}){return(await this.getMetadata(e)).refIdToName}checkLine(e,t,n,i,o,r,s,c,m,f,x,d){if(m!==void 0&&i.charCodeAt(0)===m)return;if(i.length<500){const I=i.split("	"),g=I[o-1];if(!(d?g===e:this.renameRefSeq(g)===e))return;const S=+I[r-1]+f;if(S>=n)return null;let C;return s===0||s===r?C=S+1:x?C=this._getVcfEnd(S,I[3],I[s-1]):C=+I[s-1],C<=t?void 0:{start:S,end:C}}let l=-1;const h=[-1];for(let I=0;I<c;I++){const g=i.indexOf("	",l+1);if(g===-1){h.push(i.length);break}h.push(g),l=g}const b=i.slice(h[o-1]+1,h[o]);if(!(d?b===e:this.renameRefSeq(b)===e))return;const w=+i.slice(h[r-1]+1,h[r])+f;if(w>=n)return null;let p;if(s===0||s===r?p=w+1:x?p=this._getVcfEnd(w,i.slice(h[3]+1,h[4]),i.slice(h[s-1]+1,h[s])):p=+i.slice(h[s-1]+1,h[s]),!(p<=t))return{start:w,end:p}}_getVcfEnd(e,t,n){let i=e+t.length;if(n.includes("SVTYPE=TRA"))return e+1;if(n[0]!=="."){const r=n.indexOf("END=");if(r!==-1&&(r===0||n[r-1]===";")){const s=r+4;let c=n.indexOf(";",s);c===-1&&(c=n.length),i=Number.parseInt(n.slice(s,c),10)}}return i}async lineCount(e,t={}){return this.index.lineCount(e,t)}async readChunk(e,t={}){const n=await this.filehandle.read(e.fetchedSize(),e.minv.blockPosition,t);return K(n,e,this.cache)}}export{q as CSI,R as TBI,he as TabixIndexedFile};
