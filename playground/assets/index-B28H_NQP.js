var _=Object.defineProperty;var I=(r,e,t)=>e in r?_(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var h=(r,e,t)=>I(r,typeof e!="symbol"?e+"":e,t);import{LocalFile as d}from"./browser-Tbm0NFV5.js";import{I as b,Z as F}from"./inflate-b6xj_GGs.js";const w=65536,S=w*w;function g(r,e=0){const t=r[e]|r[e+1]<<8|r[e+2]<<16|r[e+3]<<24;return((r[e+4]|r[e+5]<<8|r[e+6]<<16|r[e+7]<<24)>>>0)*S+(t>>>0)}const u=1;function m(r,e,t){const n=e[u],s=t?t[u]:1/0;return n<=r&&s>r?0:n<r?-1:1}class B{constructor({filehandle:e}){h(this,"filehandle");h(this,"index");this.filehandle=e}_getIndex(){return this.index||(this.index=this._readIndex().catch(e=>{throw this.index=void 0,e})),this.index}async _readIndex(){const e=await this.filehandle.read(8,0),t=g(e);if(!t)return[[0,0]];const n=new Array(t+1);n[0]=[0,0];const s=16*t;if(s>Number.MAX_SAFE_INTEGER)throw new TypeError("integer overflow");const i=await this.filehandle.read(s,8);for(let a=0;a<t;a+=1){const o=g(i,a*16),c=g(i,a*16+8);n[a+1]=[o,c]}return n}async getLastBlock(){return(await this._getIndex()).at(-1)}async getRelevantBlocksForRead(e,t){const n=t+e;if(e===0)return[];const s=await this._getIndex(),i=[];let a=0,o=s.length-1,c=Math.floor(s.length/2),l=m(t,s[c],s[c+1]);for(;l!==0;)l>0?o=c-1:l<0&&(a=c+1),c=Math.ceil((o-a)/2)+a,l=m(t,s[c],s[c+1]);i.push(s[c]);let f=c+1;for(;f<s.length&&(i.push(s[f]),!(s[f][u]>=n));f+=1);return i[i.length-1][u]<n&&i.push([]),i}}function E(r){let e=0;for(const t of r)e+=t.length;return e}function y(r,e){const t=new Uint8Array(e??E(r));let n=0;for(const s of r)t.set(s,n),n+=s.length;return t}async function k(r){try{let e,t=0,n;const s=[];let i=0;do{const a=r.subarray(t);if(n=new b(void 0),{strm:e}=n,n.push(a,F),n.err)throw new Error(n.msg);t+=e.next_in;const o=n.result;s.push(o),i+=o.length}while(e.avail_in);return y(s,i)}catch(e){throw/incorrect header check/.exec(`${e}`)?new Error("problem decompressing block: incorrect gzip header check"):e}}class p{constructor({filehandle:e,gziFilehandle:t}){h(this,"filehandle");h(this,"gzi");this.filehandle=e,this.gzi=new B({filehandle:t})}async _readAndUncompressBlock(e,t){let n=t;n||(n=(await this.filehandle.stat()).size);const s=n-e,i=await this.filehandle.read(s,e);return k(i)}async read(e,t){const n=await this.gzi.getRelevantBlocksForRead(e,t),s=[];for(let i=0;i<n.length-1;i+=1){const a=await this._readAndUncompressBlock(n[i][0],n[i+1][0]),[,o]=n[i],c=o>=t?0:t-o,l=Math.min(t+e,o+a.length)-o;c>=0&&c<a.length&&s.push(a.subarray(c,l))}return y(s)}}function x(r,e){return r.offset+r.lineBytes*Math.floor(e/r.lineLength)+e%r.lineLength}async function z(r,e={}){const t=new TextDecoder("utf8");return Object.fromEntries(t.decode(await r.readFile(e)).split(/\r?\n/).map(n=>n.trim()).filter(n=>!!n).map(n=>n.split("	")).map(n=>{var s;if((s=n[0])!=null&&s.startsWith(">"))throw new Error("found > in sequence name, might have supplied FASTA file for the FASTA index");return[n[0],{name:n[0],length:+n[1],start:0,end:+n[1],offset:+n[2],lineLength:+n[3],lineBytes:+n[4]}]}))}class N{constructor({fasta:e,fai:t,path:n,faiPath:s}){if(e)this.fasta=e;else if(n)this.fasta=new d(n);else throw new Error("Need to pass filehandle for fasta or path to localfile");if(t)this.fai=t;else if(s)this.fai=new d(s);else if(n)this.fai=new d(`${n}.fai`);else throw new Error("Need to pass filehandle for  or path to localfile")}async _getIndexes(e){return this.indexes||(this.indexes=z(this.fai,e).catch(t=>{throw this.indexes=void 0,t})),this.indexes}async getSequenceNames(e){return Object.keys(await this._getIndexes(e))}async getSequenceSizes(e){const t={},n=await this._getIndexes(e);for(const s of Object.values(n))t[s.name]=s.length;return t}async getSequenceSize(e,t){var s;return(s=(await this._getIndexes(t))[e])==null?void 0:s.length}async hasReferenceSequence(e,t){return!!(await this._getIndexes(t))[e]}async getResiduesByName(e,t,n,s){const i=(await this._getIndexes(s))[e];return i?this._fetchFromIndexEntry(i,t,n,s):void 0}async getSequence(e,t,n,s){return this.getResiduesByName(e,t,n,s)}async _fetchFromIndexEntry(e,t=0,n,s){let i=n;if(t<0)throw new TypeError("regionStart cannot be less than 0");if((i===void 0||i>e.length)&&(i=e.length),t>=i)return"";const a=x(e,t),o=x(e,i)-a,l=new TextDecoder("utf8").decode(await this.fasta.read(o,a,s)).replace(/\s+/g,"");if(/[^\x20-\x7e]/.test(l.slice(0,1e3)))throw new Error("Non-ASCII characters detected in sequence. The file may be gzip compressed. Use BgzipIndexedFasta for bgzip files, or decompress the file.");return l}}class O extends N{constructor({fasta:e,path:t,fai:n,faiPath:s,gzi:i,gziPath:a}){super({fasta:e,path:t,fai:n,faiPath:s}),e&&i?this.fasta=new p({filehandle:e,gziFilehandle:i}):t&&a&&(this.fasta=new p({filehandle:new d(t),gziFilehandle:new d(a)}))}}function A(r){return r.split(">").filter(e=>/\S/.test(e)).map(e=>{const[t,...n]=e.split(`
`),[s,...i]=t.split(" "),a=n.join("").replace(/\s/g,"");return{id:s,description:i.join(" "),sequence:a}})}class R{constructor({fasta:e,path:t}){if(e)this.fasta=e;else if(t)this.fasta=new d(t);else throw new Error("Need to pass fasta or path");this.data=this.fasta.readFile().then(n=>{const i=new TextDecoder("utf8").decode(n);return A(i)})}async fetch(e,t,n){const i=(await this.data).find(o=>o.id===e),a=n-t;if(!i)throw new Error(`no sequence with id ${e} exists`);return i.sequence.slice(t,a)}async getSequenceNames(){return(await this.data).map(t=>t.id)}}export{O as BgzipIndexedFasta,R as FetchableSmallFasta,N as IndexedFasta,A as parseSmallFasta};
