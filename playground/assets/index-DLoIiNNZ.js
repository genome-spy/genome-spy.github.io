function S(m,t,e){const r=Object.create(null),o=e.length,s=t.length,c=9,i=58;let n=0;if(m==="GT"){for(let l=0;l<o;l++){const d=n;for(;n<s&&t.charCodeAt(n)!==c;)n++;r[e[l]]=t.slice(d,n),n++}return r}const a=m.indexOf("GT");if(a===-1)return r;if(a===0){for(let l=0;l<o;l++){const d=n;for(;n<s&&t.charCodeAt(n)!==i&&t.charCodeAt(n)!==c;)n++;for(r[e[l]]=t.slice(d,n);n<s&&t.charCodeAt(n)!==c;)n++;n++}return r}let u=0;for(let l=0;l<a;l++)m.charCodeAt(l)===i&&u++;for(let l=0;l<o;l++){const d=n;let f=n;for(;f<s&&t.charCodeAt(f)!==c;)f++;let y=0,b=d;for(let p=d;p<=f;p++)if(p===f||t.charCodeAt(p)===i){if(y===u){r[e[l]]=t.slice(b,p);break}y++,b=p+1}n=f+1}return r}function R(m){const t=[],e=[];let r=!1,o=!1;const s=m.length;for(let c=0;c<s;c++){const i=m[c];i==='"'?(r=!r,e.push(i)):i==="["?(o=!0,e.push(i)):i==="]"?(o=!1,e.push(i)):i===","&&!r&&!o?(t.push(e.join("").trim()),e.length=0):e.push(i)}return e.length>0&&t.push(e.join("").trim()),t}function E(m,t){const e=m.indexOf(t);return[m.slice(0,e),m.slice(e+1)]}function F(m){const t=m.slice(1,-1),e=R(t),r=[];for(let o=0;o<e.length;o++){const s=e[o],[c,i]=E(s,"=");if(i&&i.startsWith("[")&&i.endsWith("]")){const n=i.slice(1,-1).split(",");for(let a=0;a<n.length;a++)n[a]=n[a].trim();r.push([c,n])}else i&&i.startsWith('"')&&i.endsWith('"')?r.push([c,i.slice(1,-1)]):r.push([c,i])}return Object.fromEntries(r)}const A={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function C(m){try{return decodeURIComponent(m)}catch{return m}}class L{constructor({header:t="",strict:e=!0}){if(!t.length)throw new Error("empty header received");const r=t.split(/[\r\n]+/).filter(Boolean);if(!r.length)throw new Error("no non-empty header lines specified");this.strict=e,this.metadata={INFO:{...A.InfoFields},FORMAT:{...A.GenotypeFields},ALT:{...A.AltTypes},FILTER:{...A.FilterTypes}};let o;for(let n=0;n<r.length;n++){const a=r[n];if(a.startsWith("#"))a.startsWith("##")?this.parseMetadata(a):o=a;else throw new Error(`Bad line in header:
${a}`)}if(!o)throw new Error("No format line found in header");const s=o.trim().split("	"),c=s.slice(0,8),i=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(s.length<8)throw new Error(`VCF header missing columns:
${o}`);if(c.length!==i.length||!c.every((n,a)=>n===i[a]))throw new Error(`VCF column headers not correct:
${o}`);this.samples=s.slice(9)}parseInfo(t){const e={},r=t.includes("%"),o=t.split(";"),s=this.metadata.INFO,c=o.length;for(let i=0;i<c;i++){const n=o[i],a=n.indexOf("="),u=a===-1?n:n.slice(0,a),l=a===-1?void 0:n.slice(a+1),d=s[u]?.Type;if(d==="Flag")e[u]=!0;else if(!l)e[u]=!0;else{const f=d==="Integer"||d==="Float",y=l.split(","),b=y.length;if(r){const p=[];for(let h=0;h<b;h++){const D=y[h];if(D===".")p.push(void 0);else{const g=C(D);p.push(f?Number(g):g)}}e[u]=p}else{const p=[];for(let h=0;h<b;h++){const D=y[h];D==="."?p.push(void 0):p.push(f?Number(D):D)}e[u]=p}}}return e}parseSamples(t,e){const r={};if(t){const o=e.split("	"),s=t.split(":"),c=this.metadata.FORMAT,i=[];for(let u=0;u<s.length;u++){const l=c[s[u]]?.Type;i.push(l==="Integer"||l==="Float")}const n=s.length,a=this.samples.length;for(let u=0;u<a;u++){const l=this.samples[u],d={},f=o[u],y=f.length;let b=0,p=0;for(let h=0;h<=y;h++)if(h===y||f[h]===":"){const D=f.slice(b,h);if(D===""||D===".")d[s[p]]=void 0;else{const g=D.split(","),T=[];if(i[p])for(let N=0;N<g.length;N++){const I=g[N];T.push(I==="."?void 0:+I)}else for(let N=0;N<g.length;N++){const I=g[N];T.push(I==="."?void 0:I)}d[s[p]]=T}if(b=h+1,p+=1,p>=n)break}r[l]=d}}return r}parseMetadata(t){const e=/^##(.+?)=(.*)/.exec(t.trim());if(!e)throw new Error(`Line is not a valid metadata line: ${t}`);const[r,o]=e.slice(1,3),s=r;if(o?.startsWith("<")){s in this.metadata||(this.metadata[s]={});const[c,i]=this.parseStructuredMetaVal(o);c?this.metadata[s][c]=i:this.metadata[s]=i}else this.metadata[s]=o}parseStructuredMetaVal(t){const e=F(t),r=e.ID;return delete e.ID,"Number"in e&&(Number.isNaN(Number(e.Number))||(e.Number=Number(e.Number))),[r,e]}getMetadata(...t){let e=this.metadata;const r=t.length;for(let o=0;o<r;o++)if(e=e[t[o]],!e)return e;return e}parseLine(t){let e=0,r=0;for(;e<t.length&&r<9;)t[e]==="	"&&(r+=1),e+=1;const o=r===9?e-1:e,s=t.slice(0,o).split("	"),c=t.slice(o+1),[i,n,a,u,l,d,f]=s,y=i,b=+n,p=a==="."?void 0:a.split(";"),h=u,D=l==="."?void 0:l.split(","),g=d==="."?void 0:+d,T=f==="."?void 0:f.split(";"),N=s[8];if(this.strict&&!s[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const I=s[7]===void 0||s[7]==="."?{}:this.parseInfo(s[7]);return{CHROM:y,POS:b,ALT:D,INFO:I,REF:h,FILTER:T?.length===1&&T[0]==="PASS"?"PASS":T,ID:p,QUAL:g,FORMAT:N,SAMPLES:()=>this.parseSamples(s[8]??"",c),GENOTYPES:()=>S(s[8]??"",c,this.samples)}}}export{L as default};
