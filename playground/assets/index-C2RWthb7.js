const h={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function v(b){try{return decodeURIComponent(b)}catch{return b}}class M{constructor({header:a="",strict:r=!0}){if(!a.length)throw new Error("empty header received");const n=a.split(/[\r\n]+/).filter(o=>o);if(!n.length)throw new Error("no non-empty header lines specified");this.strict=r,this.metadata=JSON.parse(JSON.stringify({INFO:h.InfoFields,FORMAT:h.GenotypeFields,ALT:h.AltTypes,FILTER:h.FilterTypes}));let e;if(n.forEach(o=>{if(o.startsWith("#"))o.startsWith("##")?this.parseMetadata(o):e=o;else throw new Error(`Bad line in header:
${o}`)}),!e)throw new Error("No format line found in header");const t=e.trim().split("	"),s=t.slice(0,8),i=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(t.length<8)throw new Error(`VCF header missing columns:
${e}`);if(s.length!==i.length||!s.every((o,p)=>o===i[p]))throw new Error(`VCF column headers not correct:
${e}`);this.samples=t.slice(9)}parseSamples(a,r){const n={};if(a){const e=r.split("	"),t=a.split(":"),s=t.map(i=>{const o=this.getMetadata("FORMAT",i,"Type");return o==="Integer"||o==="Float"});for(let i=0;i<this.samples.length;i++){const o=this.samples[i];n[o]={};const p=e[i].split(":");for(let c=0;c<p.length;c++){const m=p[c];n[o][t[c]]=m===""||m==="."?void 0:m.split(",").map(u=>u==="."?void 0:s[c]?+u:u)}}}return n}parseGenotypesOnly(a,r){const n=r.split("	"),e={};let t=0;const s=a.split(":");if(s.length===1)for(const i of this.samples)e[i]=n[t++];else{const i=s.findIndex(o=>o==="GT");if(i===0)for(const o of this.samples){const p=n[t++],c=p.indexOf(":");c!==-1?e[o]=p.slice(0,c):console.warn("unknown")}else for(const o of this.samples){const p=n[t++].split(":");e[o]=p[i]}}return e}parseMetadata(a){const r=/^##(.+?)=(.*)/.exec(a.trim());if(!r)throw new Error(`Line is not a valid metadata line: ${a}`);const[n,e]=r.slice(1,3),t=n;if(e!=null&&e.startsWith("<")){t in this.metadata||(this.metadata[t]={});const[s,i]=this.parseStructuredMetaVal(e);this.metadata[t][s]=i}else this.metadata[t]=e}parseStructuredMetaVal(a){const r=this.parseKeyValue(a.replace(/^<|>$/g,""),","),n=r.ID;return delete r.ID,"Number"in r&&(Number.isNaN(Number(r.Number))||(r.Number=Number(r.Number))),[n,r]}getMetadata(...a){let r=this.metadata;for(const n of a)if(r=r[n],!r)return r;return r}parseKeyValue(a,r=";"){const n={};let e="",t="",s=1;for(const i of a)s===1?i==="="?s=2:i!==r?e+=i:t===""&&(n[e]=void 0,e=""):s===2?i===r?(n[e]=t,e="",t="",s=1):i==='"'?s=3:t+=i:s===3&&(i!=='"'?t+=i:s=2);return s===2||s===3?n[e]=t:s===1&&(n[e]=void 0),n}parseLine(a){var r,n;let e=0;for(let l=0;e<a.length&&(a[e]==="	"&&(l+=1),l!==9);e+=1);const t=a.slice(0,e).split("	"),s=a.slice(e+1),[i,o,p,c,m,u,T]=t,g=i,I=+o,A=p==="."?void 0:p.split(";"),S=c,R=m==="."?void 0:m.split(","),E=u==="."?void 0:+u,y=T==="."?void 0:T.split(";");if(this.strict&&!t[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const F=(r=t[7])===null||r===void 0?void 0:r.includes("%"),f=t[7]===void 0||t[7]==="."?{}:this.parseKeyValue(t[7]);for(const l of Object.keys(f)){const D=(n=f[l])===null||n===void 0?void 0:n.split(",").map(d=>d==="."?void 0:d).map(d=>d&&F?v(d):d),N=this.getMetadata("INFO",l,"Type");N==="Integer"||N==="Float"?f[l]=D==null?void 0:D.map(d=>d===void 0?void 0:Number(d)):N==="Flag"?f[l]=!0:f[l]=D}return{CHROM:g,POS:I,ALT:R,INFO:f,REF:S,FILTER:y&&y.length===1&&y[0]==="PASS"?"PASS":y,ID:A,QUAL:E,SAMPLES:()=>{var l;return this.parseSamples((l=t[8])!==null&&l!==void 0?l:"",s)},GENOTYPES:()=>{var l;return this.parseGenotypesOnly((l=t[8])!==null&&l!==void 0?l:"",s)}}}}export{M as default};
