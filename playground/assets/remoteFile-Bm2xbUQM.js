import{b as d}from"./index-D1-7ym7j.js";function u(n){return(typeof n=="object"&&n!==null&&"message"in n?n.message:`${n}`).replace(/\.$/,"")}class ${async getBufferFromResponse(e){const t=await e.arrayBuffer();return d.Buffer.from(t)}constructor(e,t={}){this.baseOverrides={},this.url=e;const r=t.fetch||globalThis.fetch.bind(globalThis);if(!r)throw new TypeError("no fetch function supplied, and none found in global environment");t.overrides&&(this.baseOverrides=t.overrides),this.fetchImplementation=r}async fetch(e,t){let r;try{r=await this.fetchImplementation(e,t)}catch(s){if(`${s}`.includes("Failed to fetch")){console.warn(`generic-filehandle: refetching ${e} to attempt to work around chrome CORS header caching bug`);try{r=await this.fetchImplementation(e,{...t,cache:"reload"})}catch(i){throw new Error(`${u(i)} fetching ${e}`,{cause:i})}}else throw new Error(`${u(s)} fetching ${e}`,{cause:s})}return r}async read(e,t=0,r,s=0,i={}){const{headers:c={},signal:o,overrides:f={}}=i;r<1/0?c.range=`bytes=${s}-${s+r}`:r===1/0&&s!==0&&(c.range=`bytes=${s}-`);const a=await this.fetch(this.url,{...this.baseOverrides,...f,headers:{...c,...f.headers,...this.baseOverrides.headers},method:"GET",redirect:"follow",mode:"cors",signal:o});if(!a.ok)throw new Error(`HTTP ${a.status} fetching ${this.url}`);if(a.status===200&&s===0||a.status===206){const l=await this.getBufferFromResponse(a),g=l.copy(e,t,0,Math.min(r,l.length)),w=a.headers.get("content-range"),h=/\/(\d+)$/.exec(w||"");return h!=null&&h[1]&&(this._stat={size:parseInt(h[1],10)}),{bytesRead:g,buffer:e}}throw a.status===200?new Error(`${this.url} fetch returned status 200, expected 206`):new Error(`HTTP ${a.status} fetching ${this.url}`)}async readFile(e={}){let t,r;typeof e=="string"?(t=e,r={}):(t=e.encoding,r=e,delete r.encoding);const{headers:s={},signal:i,overrides:c={}}=r,o=await this.fetch(this.url,{headers:s,method:"GET",redirect:"follow",mode:"cors",signal:i,...this.baseOverrides,...c});if(o.status!==200)throw new Error(`HTTP ${o.status} fetching ${this.url}`);if(t==="utf8")return o.text();if(t)throw new Error(`unsupported encoding: ${t}`);return this.getBufferFromResponse(o)}async stat(){if(!this._stat){const e=d.Buffer.allocUnsafe(10);if(await this.read(e,0,10,0),!this._stat)throw new Error(`unable to determine size of file at ${this.url}`)}return this._stat}async close(){}}export{$ as R};
