function R(d,t,e){const r=Object.create(null),i=e.length,a=t.length,l=9,s=58;let n=0;if(d==="GT"){for(let o=0;o<i;o++){const p=n;for(;n<a&&t.charCodeAt(n)!==l;)n++;r[e[o]]=t.slice(p,n),n++}return r}const c=d.indexOf("GT");if(c===-1)return r;if(c===0){for(let o=0;o<i;o++){const p=n;for(;n<a&&t.charCodeAt(n)!==s&&t.charCodeAt(n)!==l;)n++;for(r[e[o]]=t.slice(p,n);n<a&&t.charCodeAt(n)!==l;)n++;n++}return r}let b=0;for(let o=0;o<c;o++)d.charCodeAt(o)===s&&b++;for(let o=0;o<i;o++){const p=n;let u=n;for(;u<a&&t.charCodeAt(u)!==l;)u++;let g=0,N=p;for(let h=p;h<=u;h++)if(h===u||t.charCodeAt(h)===s){if(g===b){r[e[o]]=t.slice(N,h);break}g++,N=h+1}n=u+1}return r}function E(d){const t=[],e=[];let r=!1,i=!1;const a=d.length;for(let l=0;l<a;l++){const s=d[l];s==='"'?(r=!r,e.push(s)):s==="["?(i=!0,e.push(s)):s==="]"?(i=!1,e.push(s)):s===","&&!r&&!i?(t.push(e.join("").trim()),e.length=0):e.push(s)}return e.length>0&&t.push(e.join("").trim()),t}function F(d,t){const e=d.indexOf(t);return[d.slice(0,e),d.slice(e+1)]}function C(d){const t=d.slice(1,-1),e=E(t),r=[];for(let i=0;i<e.length;i++){const a=e[i],[l,s]=F(a,"=");if(s&&s.startsWith("[")&&s.endsWith("]")){const n=s.slice(1,-1).split(",");for(let c=0;c<n.length;c++)n[c]=n[c].trim();r.push([l,n])}else s&&s.startsWith('"')&&s.endsWith('"')?r.push([l,s.slice(1,-1)]):r.push([l,s])}return Object.fromEntries(r)}const S={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function L(d){try{return decodeURIComponent(d)}catch{return d}}class M{constructor({header:t="",strict:e=!0}){if(!t.length)throw new Error("empty header received");const r=t.split(/[\r\n]+/).filter(Boolean);if(!r.length)throw new Error("no non-empty header lines specified");this.strict=e,this.metadata={INFO:{...S.InfoFields},FORMAT:{...S.GenotypeFields},ALT:{...S.AltTypes},FILTER:{...S.FilterTypes}};let i;for(let n=0;n<r.length;n++){const c=r[n];if(c.startsWith("#"))c.startsWith("##")?this.parseMetadata(c):i=c;else throw new Error(`Bad line in header:
${c}`)}if(!i)throw new Error("No format line found in header");const a=i.trim().split("	"),l=a.slice(0,8),s=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(a.length<8)throw new Error(`VCF header missing columns:
${i}`);if(l.length!==s.length||!l.every((n,c)=>n===s[c]))throw new Error(`VCF column headers not correct:
${i}`);this.samples=a.slice(9)}parseInfo(t){var s;const e={},r=t.includes("%"),i=t.split(";"),a=this.metadata.INFO,l=i.length;for(let n=0;n<l;n++){const c=i[n],b=c.indexOf("="),o=b===-1?c:c.slice(0,b),p=b===-1?void 0:c.slice(b+1),u=(s=a[o])==null?void 0:s.Type;if(u==="Flag")e[o]=!0;else if(!p)e[o]=!0;else{const g=u==="Integer"||u==="Float",N=p.split(","),h=N.length;if(r){const f=[];for(let m=0;m<h;m++){const y=N[m];if(y===".")f.push(void 0);else{const D=L(y);f.push(g?Number(D):D)}}e[o]=f}else{const f=[];for(let m=0;m<h;m++){const y=N[m];y==="."?f.push(void 0):f.push(g?Number(y):y)}e[o]=f}}}return e}parseSamples(t,e){var i;const r={};if(t){const a=e.split("	"),l=t.split(":"),s=this.metadata.FORMAT,n=[];for(let o=0;o<l.length;o++){const p=(i=s[l[o]])==null?void 0:i.Type;n.push(p==="Integer"||p==="Float")}const c=l.length,b=this.samples.length;for(let o=0;o<b;o++){const p=this.samples[o],u={},g=a[o],N=g.length;let h=0,f=0;for(let m=0;m<=N;m++)if(m===N||g[m]===":"){const y=g.slice(h,m);if(y===""||y===".")u[l[f]]=void 0;else{const D=y.split(","),I=[];if(n[f])for(let T=0;T<D.length;T++){const A=D[T];I.push(A==="."?void 0:+A)}else for(let T=0;T<D.length;T++){const A=D[T];I.push(A==="."?void 0:A)}u[l[f]]=I}if(h=m+1,f+=1,f>=c)break}r[p]=u}}return r}parseMetadata(t){const e=/^##(.+?)=(.*)/.exec(t.trim());if(!e)throw new Error(`Line is not a valid metadata line: ${t}`);const[r,i]=e.slice(1,3),a=r;if(i!=null&&i.startsWith("<")){a in this.metadata||(this.metadata[a]={});const[l,s]=this.parseStructuredMetaVal(i);l?this.metadata[a][l]=s:this.metadata[a]=s}else this.metadata[a]=i}parseStructuredMetaVal(t){const e=C(t),r=e.ID;return delete e.ID,"Number"in e&&(Number.isNaN(Number(e.Number))||(e.Number=Number(e.Number))),[r,e]}getMetadata(...t){let e=this.metadata;const r=t.length;for(let i=0;i<r;i++)if(e=e[t[i]],!e)return e;return e}parseLine(t){let e=0,r=0;for(;e<t.length&&r<9;)t[e]==="	"&&(r+=1),e+=1;const i=r===9?e-1:e,a=t.slice(0,i).split("	"),l=t.slice(i+1),[s,n,c,b,o,p,u]=a,g=s,N=+n,h=c==="."?void 0:c.split(";"),f=b,m=o==="."?void 0:o.split(","),y=p==="."?void 0:+p,D=u==="."?void 0:u.split(";"),I=a[8];if(this.strict&&!a[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const T=a[7]===void 0||a[7]==="."?{}:this.parseInfo(a[7]);return{CHROM:g,POS:N,ALT:m,INFO:T,REF:f,FILTER:(D==null?void 0:D.length)===1&&D[0]==="PASS"?"PASS":D,ID:h,QUAL:y,FORMAT:I,SAMPLES:()=>this.parseSamples(a[8]??"",l),GENOTYPES:()=>R(a[8]??"",l,this.samples)}}}export{M as default};
