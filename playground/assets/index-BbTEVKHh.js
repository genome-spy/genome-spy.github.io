import{LocalFile as d}from"./browser-BgbJyVTA.js";import{I as y,Z as _}from"./inflate-b6xj_GGs.js";const g=65536,I=g*g;function u(i,e=0){const t=i[e]|i[e+1]<<8|i[e+2]<<16|i[e+3]<<24;return((i[e+4]|i[e+5]<<8|i[e+6]<<16|i[e+7]<<24)>>>0)*I+(t>>>0)}const f=1;function w(i,e,t){const n=e[f],s=t?t[f]:1/0;return n<=i&&s>i?0:n<i?-1:1}class b{filehandle;index;constructor({filehandle:e}){this.filehandle=e}_getIndex(){return this.index||(this.index=this._readIndex().catch(e=>{throw this.index=void 0,e})),this.index}async _readIndex(){const e=await this.filehandle.read(8,0),t=u(e);if(!t)return[[0,0]];const n=new Array(t+1);n[0]=[0,0];const s=16*t;if(s>Number.MAX_SAFE_INTEGER)throw new TypeError("integer overflow");const r=await this.filehandle.read(s,8);for(let a=0;a<t;a+=1){const o=u(r,a*16),c=u(r,a*16+8);n[a+1]=[o,c]}return n}async getLastBlock(){return(await this._getIndex()).at(-1)}async getRelevantBlocksForRead(e,t){const n=t+e;if(e===0)return[];const s=await this._getIndex(),r=[];let a=0,o=s.length-1,c=Math.floor(s.length/2),l=w(t,s[c],s[c+1]);for(;l!==0;)l>0?o=c-1:l<0&&(a=c+1),c=Math.ceil((o-a)/2)+a,l=w(t,s[c],s[c+1]);r.push(s[c]);let h=c+1;for(;h<s.length&&(r.push(s[h]),!(s[h][f]>=n));h+=1);return r[r.length-1][f]<n&&r.push([]),r}}function F(i){let e=0;for(const t of i)e+=t.length;return e}function x(i,e){const t=new Uint8Array(e??F(i));let n=0;for(const s of i)t.set(s,n),n+=s.length;return t}async function S(i){try{let e,t=0,n;const s=[];let r=0;do{const a=i.subarray(t);if(n=new y(void 0),{strm:e}=n,n.push(a,_),n.err)throw new Error(n.msg);t+=e.next_in;const o=n.result;s.push(o),r+=o.length}while(e.avail_in);return x(s,r)}catch(e){throw/incorrect header check/.exec(`${e}`)?new Error("problem decompressing block: incorrect gzip header check"):e}}class m{filehandle;gzi;constructor({filehandle:e,gziFilehandle:t}){this.filehandle=e,this.gzi=new b({filehandle:t})}async _readAndUncompressBlock(e,t){let n=t;n||(n=(await this.filehandle.stat()).size);const s=n-e,r=await this.filehandle.read(s,e);return S(r)}async read(e,t){const n=await this.gzi.getRelevantBlocksForRead(e,t),s=[];for(let r=0;r<n.length-1;r+=1){const a=await this._readAndUncompressBlock(n[r][0],n[r+1][0]),[,o]=n[r],c=o>=t?0:t-o,l=Math.min(t+e,o+a.length)-o;c>=0&&c<a.length&&s.push(a.subarray(c,l))}return x(s)}}function p(i,e){return i.offset+i.lineBytes*Math.floor(e/i.lineLength)+e%i.lineLength}async function B(i,e={}){const t=new TextDecoder("utf8");return Object.fromEntries(t.decode(await i.readFile(e)).split(/\r?\n/).map(n=>n.trim()).filter(n=>!!n).map(n=>n.split("	")).map(n=>{if(n[0]?.startsWith(">"))throw new Error("found > in sequence name, might have supplied FASTA file for the FASTA index");return[n[0],{name:n[0],length:+n[1],start:0,end:+n[1],offset:+n[2],lineLength:+n[3],lineBytes:+n[4]}]}))}class E{constructor({fasta:e,fai:t,path:n,faiPath:s}){if(e)this.fasta=e;else if(n)this.fasta=new d(n);else throw new Error("Need to pass filehandle for fasta or path to localfile");if(t)this.fai=t;else if(s)this.fai=new d(s);else if(n)this.fai=new d(`${n}.fai`);else throw new Error("Need to pass filehandle for  or path to localfile")}async _getIndexes(e){return this.indexes||(this.indexes=B(this.fai,e).catch(t=>{throw this.indexes=void 0,t})),this.indexes}async getSequenceNames(e){return Object.keys(await this._getIndexes(e))}async getSequenceSizes(e){const t={},n=await this._getIndexes(e);for(const s of Object.values(n))t[s.name]=s.length;return t}async getSequenceSize(e,t){return(await this._getIndexes(t))[e]?.length}async hasReferenceSequence(e,t){return!!(await this._getIndexes(t))[e]}async getResiduesByName(e,t,n,s){const r=(await this._getIndexes(s))[e];return r?this._fetchFromIndexEntry(r,t,n,s):void 0}async getSequence(e,t,n,s){return this.getResiduesByName(e,t,n,s)}async _fetchFromIndexEntry(e,t=0,n,s){let r=n;if(t<0)throw new TypeError("regionStart cannot be less than 0");if((r===void 0||r>e.length)&&(r=e.length),t>=r)return"";const a=p(e,t),o=p(e,r)-a,l=new TextDecoder("utf8").decode(await this.fasta.read(o,a,s)).replace(/\s+/g,"");if(/[^\x20-\x7e]/.test(l.slice(0,1e3)))throw new Error("Non-ASCII characters detected in sequence. The file may be gzip compressed. Use BgzipIndexedFasta for bgzip files, or decompress the file.");return l}}class A extends E{constructor({fasta:e,path:t,fai:n,faiPath:s,gzi:r,gziPath:a}){super({fasta:e,path:t,fai:n,faiPath:s}),e&&r?this.fasta=new m({filehandle:e,gziFilehandle:r}):t&&a&&(this.fasta=new m({filehandle:new d(t),gziFilehandle:new d(a)}))}}function k(i){return i.split(">").filter(e=>/\S/.test(e)).map(e=>{const[t,...n]=e.split(`
`),[s,...r]=t.split(" "),a=n.join("").replace(/\s/g,"");return{id:s,description:r.join(" "),sequence:a}})}class q{constructor({fasta:e,path:t}){if(e)this.fasta=e;else if(t)this.fasta=new d(t);else throw new Error("Need to pass fasta or path");this.data=this.fasta.readFile().then(n=>{const r=new TextDecoder("utf8").decode(n);return k(r)})}async fetch(e,t,n){const r=(await this.data).find(o=>o.id===e),a=n-t;if(!r)throw new Error(`no sequence with id ${e} exists`);return r.sequence.slice(t,a)}async getSequenceNames(){return(await this.data).map(t=>t.id)}}export{A as BgzipIndexedFasta,q as FetchableSmallFasta,E as IndexedFasta,k as parseSmallFasta};
