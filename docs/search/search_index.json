{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>GenomeSpy is a toolkit for interactive visualization of genomic and other data. It enables tailored visualizations by providing a declarative grammar, which allows for mapping data to visual channels (position, color, etc.) and composing complex visualization from primitive graphical marks (points, rectangles, etc.). The grammar is heavily inspired by Vega-Lite, providing partial compatibility and extending it with features essential in genome visualization.</p> <p>The visualizations are rendered using a carefully crafted WebGL-based engine, enabling fluid interaction and smooth animation for datasets comprising several million data points. The high interactive performance is achieved using GPU shader programs for all scale transformations and rendering of marks. However, shaders are an implementation detail hidden from the end users.</p> <p>The toolkit comprises two JavaScript packages:</p> <ol> <li>The core library implements the visualization grammar    and rendering engine and can be embedded in web pages or applications.</li> <li>The app extends the core library with support    for interactive analysis of large sample collections. It broadens the grammar    by introducing a facet operator that repeats a visualization for multiple    samples. The app also provides interactions for filtering, sorting, and    grouping these samples.</li> </ol> <p>Check the Getting Started page to get started with GenomeSpy and make your own tailored visualizations.</p>"},{"location":"#an-interactive-example","title":"An interactive example","text":"<p>The example below is interactive. You can zoom in using the mouse wheel.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 200000, \"as\": \"x\" }\n  },\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"random() * 0.682\", \"as\": \"u\" },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"((datum.u % 1e-8 &gt; 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618 + sin(datum.x / 10000)\",\n      \"as\": \"y\"\n    }\n  ],\n  \"mark\": {\n    \"type\": \"point\",\n    \"size\": { \"expr\": \"min(0.5 * pow(zoomLevel, 1.5), 200)\" }\n  },\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n    \"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n    \"opacity\": { \"value\": 0.6 }\n  }\n}\n</code></pre>"},{"location":"#about","title":"About","text":"<p>GenomeSpy is developed by Kari Lavikka in The Systems Biology of Drug Resistance in Cancer group at the University of Helsinki.</p> <p>This project has received funding from the European Union's Horizon 2020 Research and Innovation Programme under Grant agreement No. 667403 (HERCULES) and No. 965193 (DECIDER)</p>"},{"location":"api/","title":"JavaScript API","text":"<p>The public JavaScript API is currently quite minimal.</p>"},{"location":"api/#embedding","title":"Embedding","text":"<p>See the getting started page.</p>"},{"location":"api/#the-api","title":"The API","text":"<p>The <code>embed</code> function returns a promise that resolves into an object that provides the current public API. The API is documented in the interface definition.</p> <p>For practical examples on using the API, check the embed-examples package.</p>"},{"location":"api/#embed-options","title":"Embed options","text":"<p>The <code>embed</code> function accepts an optional options object.</p>"},{"location":"api/#named-data-provider","title":"Named data provider","text":"<p>See the API definition.</p>"},{"location":"api/#custom-tooltip-handlers","title":"Custom tooltip handlers","text":"<p>GenomeSpy provides two built-in tooltip handlers.</p> <p>The <code>default</code> handler displays the underlying datum's properties in a table. Property names starting with an underscore are omitted. The values are formatted nicely.</p> <p>The <code>refseqgene</code> handler fetches a summary description for a gene symbol using the Entrez API. For an example, check the RefSeq gene track in this notebook. Custom search terms can be provided through the <code>params</code> property.</p> <p>Handlers are functions that receive the hovered mark's underlying datum and return a promise that resolves into a string, HTMLElement, or lit-html TemplateResult.</p> <p>The function signature:</p> <pre><code>export type TooltipHandler = (\n  datum: Record&lt;string, any&gt;,\n  mark: Mark,\n  /** Optional parameters from the view specification */\n  params?: Record&lt;string, any&gt;\n) =&gt; Promise&lt;string | TemplateResult | HTMLElement&gt;;\n</code></pre> <p>Use the <code>tooltipHandlers</code> option to register custom handlers or override the default. See the example below.</p>"},{"location":"api/#examples","title":"Examples","text":"<p>Overriding the <code>default</code> handler:</p> <pre><code>import { html } from \"lit-html\";\n\nconst options = {\n  tooltipHandlers: {\n    default: async (datum, mark, props) =&gt; html`\n      The datum has\n      &lt;strong&gt;${Object.keys(datum).length}&lt;/strong&gt; attributes!\n    `,\n  },\n};\n\nembed(container, spec, options);\n</code></pre> <p>To use a specific (custom) handler in a view specification:</p> <pre><code>{\n  \"mark\": {\n    \"type\": \"point\",\n    \"tooltip\": {\n      \"handler\": \"myhandler\",\n      \"params\": {\n        \"custom\": \"param\"\n      }\n    }\n  },\n  ...\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>GenomeSpy is a visualization toolkit for genomic data. More specifically, it is a JavaScript library that can be used to create interactive visualizations of genomic data in web browsers. To visualize data with GenomeSpy, you need to:</p> <ol> <li>Have some data to be visualized</li> <li>Write or find a visualization specification that    describes how the data should be visualized</li> <li>Embed GenomeSpy into a web page and initialize it with the specification and    the data</li> <li>Open the web page with your web browser</li> </ol> <p>However, there are three ways to get quickly started with GenomeSpy visualizations: the Playground app, Observable notebooks, and embedding GenomeSpy on HTML pages. More advanced users can use GenomeSpy as a visualization library in web applications.</p>"},{"location":"getting-started/#playground","title":"Playground","text":"<p>The easiest way to try out GenomeSpy is the Playground  app, which allows you to experiment with different visualization specifications directly in your web browser. You can load data from publicly accessible web servers or from your computer. The app is still rudimentary and does not support saving or sharing visualizations.</p>"},{"location":"getting-started/#observable-notebooks","title":"Observable notebooks","text":"<p>You can embed GenomeSpy into an Observable notebook. Please check the GenomeSpy collection for usage examples.</p>"},{"location":"getting-started/#local-or-remote-web-server","title":"Local or remote web server","text":"<p>For more serious work, you should use the GenomeSpy JavaScript library to create a web page for the visualization:</p> <ol> <li>Create an HTML document (web page) by using the example below</li> <li>Place the visualization spec and your data files into the same directory    as the HTML document</li> <li>Copy them onto a remote web server or start a local web server in the directory</li> </ol>"},{"location":"getting-started/#local-web-server","title":"Local web server","text":"<p>Python comes with an HTTP server module that can be started from command line:</p> <pre><code>python3 -m http.server --bind 127.0.0.1\n</code></pre> <p>By default, it serves files from the current working directory. See Python's documentation for details.</p>"},{"location":"getting-started/#html-template","title":"HTML template","text":"<p>The templates below load the GenomeSpy JavaScript library from a content delivery network. Because the specification schema and the JavaScript API are not yet 100% stable, it is recommended to use a specific version.</p> <p>The <code>embed</code> function initializes a visualization into the HTML element given as the first parameter using the specification given as the second parameter. The function returns a promise that resolves into an object that provides the current public API. For deails, see the API Documentation.</p> <p>Check the latest version!</p> <p>The versions in the examples below may be slightly out of date. The current version is:</p> <p></p>"},{"location":"getting-started/#load-the-spec-from-a-file","title":"Load the spec from a file","text":"<p>This template loads the spec from a separate <code>spec.json</code> file.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;GenomeSpy&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script\n      type=\"text/javascript\"\n      src=\"https://cdn.jsdelivr.net/npm/@genome-spy/core@0.37.x\"\n    &gt;&lt;/script&gt;\n\n    &lt;script&gt;\n      genomeSpyEmbed.embed(document.body, \"spec.json\", {});\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting-started/#embed-the-spec-in-the-html-document","title":"Embed the spec in the HTML document","text":"<p>You can alternatively provide the specification as a JavaScript object.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;GenomeSpy&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script\n      type=\"text/javascript\"\n      src=\"https://cdn.jsdelivr.net/npm/@genome-spy/core@0.37.x\"\n    &gt;&lt;/script&gt;\n\n    &lt;script&gt;\n      const spec = {\n        data: {\n          sequence: { start: 0, stop: 6.284, step: 0.39269908169, as: \"x\" },\n        },\n        transform: [{ type: \"formula\", expr: \"sin(datum.x)\", as: \"sin\" }],\n        mark: \"point\",\n        encoding: {\n          x: { field: \"x\", type: \"quantitative\" },\n          y: { field: \"sin\", type: \"quantitative\" },\n        },\n      };\n\n      genomeSpyEmbed.embed(document.body, spec, {});\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting-started/#genomespyapp-website-examples","title":"Genomespy.app website examples","text":"<p>The examples on the genomespy.app main page are stored in the website-examples GitHub repository. You can clone the repository and launch the examples locally for further experimentation.</p>"},{"location":"getting-started/#using-genomespy-as-a-visualization-library-in-web-applications","title":"Using GenomeSpy as a visualization library in web applications","text":"<p>The @genome-spy/core NPM package contains a bundled library that can be used on web pages as shown in the examples above. In addition, it contains the source code in ESM format, allowing use with bundlers such as Vite and Webpack. For examples of such use, see:</p> <ul> <li>The embed-examples   package contains examples of embedding GenomeSpy in web applications and using the API.</li> <li>SegmentModel Spy is an example   of a complete web application that uses GenomeSpy for visualization.</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2018-2023 Kari Lavikka</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"license/#contains-code-from","title":"Contains Code From","text":""},{"location":"license/#vega-and-vega-lite","title":"Vega and Vega-Lite","text":"<p>Copyright (c) 2015, University of Washington Interactive Data Lab. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</li> </ul> <ul> <li>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</li> </ul> <ul> <li>Neither the name of the University of Washington Interactive Data Lab   nor the names of its contributors may be used to endorse or promote products   derived from this software without specific prior written permission.</li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"genomic-data/","title":"Working with Genomic Data","text":"<p>GenomeSpy provides various features that are specifically designed for working with genomic data.</p>"},{"location":"genomic-data/#loading-genomic-data","title":"Loading Genomic Data","text":"<p>While GenomeSpy can load data from various sources, such as CSV and JSON files, genomic data is often stored in specialized file formats, such as Indexed FASTA, BigWig, and BigBed. GenomeSpy provides built-in support for these formats, allowing you to load and visualize genomic data without the need for additional tools or libraries.</p>"},{"location":"genomic-data/#handling-genomic-coordinates","title":"Handling Genomic Coordinates","text":"<p>Genomic data is typically associated with genomic coordinates comprising chromosome names and positions within the chromosomes. GenomeSpy provides various techniques for working with such coordinates, such as transforming between different coordinate systems and visualizing data in the context of a reference genome.</p>"},{"location":"genomic-data/#data-transformations","title":"Data Transformations","text":"<p>Specialized transformations, such as folding tabular data, calculating coverage, and computing a piled up layout allows GenomeSpy to be adapted for many genomic data visualization and analysis tasks.</p>"},{"location":"genomic-data/#gpu-accelerated-rendering","title":"GPU-accelerated Rendering","text":"<p>As genomic data can be large and complex, GenomeSpy's GPU-accelerated rendering allows you to visualize, navigate, and explore large datasets with high performance.</p>"},{"location":"genomic-data/examples/","title":"Practical Genomic Data Examples","text":""},{"location":"genomic-data/examples/#observable-notebooks","title":"Observable notebooks","text":"<p>The ASCAT Copy-Number Segmentation notebook provides a comprehensive and fully documented example of using GenomeSpy with genomic data.</p> <p>The Annotation Tracks notebooks explains how to implement a chromosome ideogram and a fancy gene annotation track.</p>"},{"location":"genomic-data/examples/#website-examples","title":"Website examples","text":"<p>The genomespy.app main page showcases several examples, some of which focusing on genomic data.</p> <ul> <li>GWAS Manhattan Plot (spec)</li> <li>Multiple-Sequence Alignment (spec)</li> <li>Structural Variants (spec)</li> <li>Multiple Cell Lines (spec)</li> </ul>"},{"location":"genomic-data/genomic-coordinates/","title":"Genomic Coordinates","text":"<p>To allow easy visualization of coordinate-based genomic data, GenomeSpy can concatenate the discrete chromosomes onto a single continuous linear axis. Concatenation needs the sizes and preferred order for the contigs or chromosomes. These are usually provided with a genome assembly.</p> <p>To activate support for genomic coordinates, add the <code>genome</code> property with the name of the assembly to the top level view specification:</p> <pre><code>{\n  \"genome\": {\n    \"name\": \"hg38\"\n  },\n  ...\n}\n</code></pre> <p>Only a single genome assembly</p> <p>Currently, a visualization may have only a single globally configured genome assembly. Different assemblies for different scales (for <code>x</code> and <code>y</code> axes, for example) will be supported in the future.</p>"},{"location":"genomic-data/genomic-coordinates/#supported-genomes","title":"Supported genomes","text":"<p>GenomeSpy bundles a few common built-in genome assemblies: <code>\"hg38\"</code>, <code>\"hg19\"</code>, <code>\"hg18\"</code>, <code>\"mm10\"</code>, <code>\"mm9\"</code>, and <code>\"dm6\"</code>.</p>"},{"location":"genomic-data/genomic-coordinates/#custom-genomes","title":"Custom genomes","text":"<p>Custom genome assemblies can be provided in two ways: as a <code>chrom.sizes</code> file or within the the specification.</p>"},{"location":"genomic-data/genomic-coordinates/#as-a-chromsizes-file","title":"As a <code>chrom.sizes</code> file","text":"<p>The <code>chrom.sizes</code> file is a two-column text file with the chromosome names and their sizes. You may want to use the UCSC Genome Browser's fetchChromSizes script to download the sizes for a genome assembly. GenomeSpy does not filter out any alternative contigs or haplotypes, so you may want to preprocess the file before using it.</p> <p>Example:</p> <pre><code>{\n  \"genome\": {\n    \"name\": \"hg19\",\n    \"url\": \"https://genomespy.app/data/genomes/hg19/chrom.sizes\"\n  },\n  ...\n}\n</code></pre>"},{"location":"genomic-data/genomic-coordinates/#within-the-specification","title":"Within the specification","text":"<p>You can provide the genome assembly directly in the specification using the <code>contigs</code> property. The contigs are an array of objects with the <code>name</code> and <code>size</code> properties.</p> <p>Example:</p> <pre><code>{\n  \"genome\": {\n    \"name\": \"dm6\",\n    \"contigs\": [\n      {\"name\": \"chr3R\", \"size\": 32079331 },\n      {\"name\": \"chr3L\", \"size\": 28110227 },\n      {\"name\": \"chr2R\", \"size\": 25286936 },\n      {\"name\": \"chrX\",  \"size\": 23542271 },\n      {\"name\": \"chr2L\", \"size\": 23513712 },\n      {\"name\": \"chrY\",  \"size\": 3667352 },\n      {\"name\": \"chr4\",  \"size\": 1348131 },\n    ]\n  },\n  ...\n}\n</code></pre>"},{"location":"genomic-data/genomic-coordinates/#encoding-genomic-coordinates","title":"Encoding genomic coordinates","text":"<p>When a genome assembly has been specified, you can encode the genomic coordinates conveniently by specifying the chromosome (<code>chrom</code>) and position (<code>pos</code>) fields as follows:</p> <pre><code>{\n  ...,\n  \"encoding\": {\n    \"x\": {\n      \"chrom\": \"Chr\",\n      \"pos\": \"Pos\",\n      \"offset\": -1.0,\n      \"type\": \"locus\"\n    },\n    ...\n  }\n}\n</code></pre> <p>The example above specifies that the chromosome is read from the <code>\"Chr\"</code> field and the intra-chromosomal position from the <code>\"Pos\"</code> field. The <code>\"locus\"</code> data type pairs the channel with a <code>\"locus\"</code> scale, which provides a chromosome-aware axis. However, you can also use the <code>field</code> property with the locus data type if the coordinate has already been linearized. The <code>offset</code> property is explained below.</p> <p>What happens under the hood</p> <p>When the <code>chrom</code> and <code>pos</code> properties are used used in channel definitions, GenomeSpy inserts an implicit linearizeGenomicCoordinate transformation into the data flow. The transformation introduces a new field with the linearized coordinate for the (chromosome, position) pair. The channel definition is modified to use the new field.</p> <p>In some cases you may want to insert an explicit transformation to the data flow to have better control on its behavior.</p>"},{"location":"genomic-data/genomic-coordinates/#coordinate-counting","title":"Coordinate counting","text":"<p>The <code>offset</code> property allows for aligning and adjusting for different coordinate notations: zero or one based, closed or half-open. The offset is added to the final coordinate.</p> <p>GenomeSpy's <code>\"locus\"</code> scale expects half-open, zero-based coordinates.</p> <p>Read more about coordinates at the UCSC Genome Browser Blog.</p>"},{"location":"genomic-data/genomic-coordinates/#examples","title":"Examples","text":""},{"location":"genomic-data/genomic-coordinates/#point-features","title":"Point features","text":"<p>Point features cover a single position on a chromosome. An example of a point feature is a single nucleotide variant (SNV), where a nucleotide has been replaced by another.</p> <pre><code>{\n  \"genome\": { \"name\": \"hg38\" },\n  \"data\": {\n    \"values\": [\n      { \"chrom\": \"chr3\", \"pos\": 134567890 },\n      { \"chrom\": \"chr4\", \"pos\": 123456789 },\n      { \"chrom\": \"chr9\", \"pos\": 34567890 }\n    ]\n  },\n  \"mark\": \"point\",\n  \"encoding\": {\n    \"x\": {\n      \"chrom\": \"chrom\",\n      \"pos\": \"pos\",\n      \"type\": \"locus\"\n    }\n  }\n}\n</code></pre>"},{"location":"genomic-data/genomic-coordinates/#segment-features","title":"Segment features","text":"<p>Segment features cover a range of positions on a chromosome. They are defined by their two end positions. An example of a segment feature is a copy number variant (CNV), where a region of the genome has been duplicated or deleted.</p> <pre><code>{\n  \"genome\": { \"name\": \"hg38\" },\n  \"data\": {\n    \"values\": [\n      { \"chrom\": \"chr3\", \"startpos\": 100000000, \"endpos\": 140000000 },\n      { \"chrom\": \"chr4\", \"startpos\": 70000000, \"endpos\": 170000000 },\n      { \"chrom\": \"chr9\", \"startpos\": 50000000, \"endpos\": 70000000 }\n    ]\n  },\n  \"mark\": \"rect\",\n  \"encoding\": {\n    \"x\": {\n      \"chrom\": \"chrom\",\n      \"pos\": \"startpos\",\n      \"type\": \"locus\"\n    },\n    \"x2\": {\n      \"chrom\": \"chrom\",\n      \"pos\": \"endpos\"\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/","title":"Visualization Grammar","text":"<p>Genome browser applications typically couple the visual representations to specific file formats and provide few customization options. GenomeSpy has a more abstract approach to visualization, providing combinatorial building blocks such as marks, transformations, and scales. As a result, users can author tailored visualizations that display the underlying data more effectively.</p> <p>The concept was first introduced in The Grammar of Graphics and developed further in ggplot2 and Vega-Lite.</p> <p>A dialect of Vega-Lite</p> <p>The visualization grammar of GenomeSpy is a dialect of Vega-Lite, providing partial compatibility. However, the goals of GenomeSpy and Vega-Lite are different \u2013 GenomeSpy is more domain-specific and primarily intended for the visualization and analysis of large datasets containing genomic coordinates. Nevertheless, GenomeSpy tries to follow Vega-Lite's grammar where practical, and thus, this documentation has several references to its documentation.</p>"},{"location":"grammar/#a-single-view-specification","title":"A single view specification","text":"<p>Each view specification must have at least the <code>data</code> to be visualized, the <code>mark</code> that will represent the data items, and an <code>encoding</code> that specifies how the fields of data are mapped to the visual channels of the mark. In addition, an optional <code>transform</code> steps allow for modifying the data before they are encoded into mark instances.</p> <pre><code>{\n  \"data\": { \"url\": \"sincos.csv\" },\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"abs(datum.sin)\", \"as\": \"abs(sin)\" }\n  ],\n  \"mark\": \"point\",\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n    \"y\": { \"field\": \"abs(sin)\", \"type\": \"quantitative\" },\n    \"size\": { \"field\": \"x\", \"type\": \"quantitative\" }\n  }\n}\n</code></pre>"},{"location":"grammar/#properties","title":"Properties","text":"<code>aggregateSamples</code> Type: array<p>Specifies views that aggregate multiple samples within the GenomeSpy App.</p> <code>baseUrl</code> Type: string<p>The base URL for relative URL data sources and URL imports. The base URLs are inherited in the view hierarchy unless overridden with this property. By default, the top-level view's base URL equals to the visualization specification's base URL.</p> <code>configurableVisibility</code> Type: boolean<p>Is the visibility configurable interactively from the GenomeSpy App. Configurability requires that the view has an explicitly specified name that is unique within its import scope.</p> <p>Default: <code>false</code> for children of <code>layer</code>, <code>true</code> for others.</p> <code>data</code> Type: UrlData | InlineData | NamedData | DynamicCallbackData | LazyData | Generator<p>Specifies a data source. If omitted, the data source is inherited from the parent view.</p> <code>description</code> Type: string | string[]<p>A description of the view. Can be used for documentation. The description of the top-level view is shown in the toolbar of the GenomeSpy App.</p> <code>domainInert</code> Type: boolean<p>If true, this view and its descendants do not contribute to scale domains. Child views inherit this flag automatically.</p> <p>Default value: <code>false</code></p> <code>encoding</code> Type: Encoding<p>Specifies how data are encoded using the visual channels.</p> <code>height</code> Type: SizeDef | number | Step | <code>\"container\"</code><p>Height of the view. If a number, it is interpreted as pixels. Check child sizing for details.</p> <p>Default value: <code>\"container\"</code></p> <code>mark</code> Required Type: <code>\"rect\"</code> | <code>\"point\"</code> | <code>\"rule\"</code> | <code>\"text\"</code> | <code>\"link\"</code> | RectProps | TextProps | RuleProps | LinkProps | PointProps<p>The graphical mark presenting the data objects.</p> <code>name</code> Type: string<p>An explicit name used to address the view. It is recommended to keep names unique among siblings. In the App (where view state is bookmarkable), the name must be unique within its import scope for views with configurable visibility, etc.</p> <code>opacity</code> Type: number | DynamicOpacity | ExprRef<p>Opacity of the view and all its children. Allows implementing semantic zooming where the layers are faded in and out as the user zooms in and out.</p> <p>TODO: Write proper documentation with examples.</p> <p>Default: <code>1.0</code></p> <code>padding</code> Type: Paddings | number<p>Padding applied to the view. Accepts either a number representing pixels or an object specifying separate paddings for each edge.</p> <p>Examples: - <code>padding: 10</code> - <code>padding: { top: 10, right: 20, bottom: 10, left: 20 }</code></p> <p>Default value: <code>0</code></p> <code>params</code> Type: array<p>Dynamic variables that parameterize a visualization.</p> <code>resolve</code> Type: object<p>Specifies how scales and axes are resolved in the view hierarchy.</p> <code>templates</code> Type: object<p>Templates that can be reused within the view specification by importing them with the template key.</p> <code>title</code> Type: string | Title<p>View title. N.B.: Currently, GenomeSpy doesn't do bound calculation, and you need to manually specify proper padding for the view to ensure that the title is visible.</p> <code>transform</code> Type: array<p>An array of transformations applied to the data before visual encoding.</p> <code>view</code> Type: ViewBackground<p>The background of the view, including fill, stroke, and stroke width.</p> <code>viewportHeight</code> Type: SizeDef | number | <code>\"container\"</code><p>Optional viewport height of the view. If the view size exceeds the viewport height, it will be shown with scrollbars. This property implicitly enables clipping.</p> <p>Default: <code>null</code> (same as <code>height</code>)</p> <code>viewportWidth</code> Type: SizeDef | number | <code>\"container\"</code><p>Optional viewport width of the view. If the view size exceeds the viewport width, it will be shown with scrollbars. This property implicitly enables clipping.</p> <p>Default: <code>null</code> (same as <code>width</code>)</p> <code>visible</code> Type: boolean<p>The default visibility of the view. An invisible view is removed from the layout and not rendered. For context, see toggleable view visibility.</p> <p>Default: <code>true</code></p> <code>width</code> Type: SizeDef | number | Step | <code>\"container\"</code><p>Width of the view. If a number, it is interpreted as pixels. Check child sizing for details.</p> <p>Default: <code>\"container\"</code></p>"},{"location":"grammar/#view-composition-for-more-complex-visualizations","title":"View composition for more complex visualizations","text":"<p>View composition allows for building more complex visualizations from multiple single-view specifications. For example, the <code>layer</code> operator allows creation of custom glyphs and the concatenation operators enables stacked layouts resembling genome browsers with multiple tracks.</p>"},{"location":"grammar/expressions/","title":"Expressions","text":"<p>Expressions allow for defining predicates or computing new variables based on existing data. The expression language is based on JavaScript, but provides only a limited set of features, guaranteeing secure execution.</p> <p>Expressions can be used with the <code>\"filter\"</code> and <code>\"formula\"</code> transforms, in encoding, and in expression references for dynamic properties in marks, transforms, and data sources.</p>"},{"location":"grammar/expressions/#usage","title":"Usage","text":"<p>All basic arithmetic operators are supported:</p> <pre><code>(1 + 2) * 3 / 4\n</code></pre> <p>When using expressions within the data transformation pipeline, the current data object is available in the <code>datum</code> variable. Its properties (fields) can be accessed by using the dot or bracket notation:</p> <pre><code>datum.foo + 2\n</code></pre> <p>If the name of the property contains special characters such as \"<code>.</code>\", \"<code>!</code>\", or \"<code> </code>\" (a space) the bracket notation must be used:</p> <pre><code>datum['A very *special* name!'] &gt; 100\n</code></pre>"},{"location":"grammar/expressions/#conditional-operators","title":"Conditional operators","text":"<p>Ternary operator:</p> <pre><code>datum.foo &lt; 5 ? 'small' : 'large'\n</code></pre> <p>And an equivalent <code>if</code> construct:</p> <pre><code>if(datum.foo &lt; 5, 'small', 'large')\n</code></pre>"},{"location":"grammar/expressions/#provided-constants-and-functions","title":"Provided constants and functions","text":"<p>Common mathematical functions are supported:</p> <pre><code>(datum.u % 1e-8 &gt; 5e-9 ? 1 : -1) *\n  (sqrt(-log(max(1e-9, datum.u))) - 0.618) *\n  1.618\n</code></pre>"},{"location":"grammar/expressions/#constants-and-functions-from-vega","title":"Constants and functions from Vega","text":"<p>The following constants and functions are provided by the vega-expression package.</p>"},{"location":"grammar/expressions/#constants","title":"Constants","text":"<p><code>NaN</code>, <code>E</code>, <code>LN2</code>, <code>LN10</code>, <code>LOG2E</code>, <code>LOG10E</code>, <code>PI</code>, <code>SQRT1_2</code>, <code>SQRT2</code>, <code>MIN_VALUE</code>, <code>MAX_VALUE</code></p>"},{"location":"grammar/expressions/#type-checking-functions","title":"Type Checking Functions","text":"<p><code>isArray</code>, <code>isBoolean</code>, <code>isNumber</code>, <code>isObject</code>, <code>isRegExp</code>, <code>isString</code></p>"},{"location":"grammar/expressions/#math-functions","title":"Math Functions","text":"<p><code>isNaN</code>, <code>isFinite</code>, <code>abs</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>, <code>atan2</code>, <code>ceil</code>, <code>cos</code>, <code>exp</code>, <code>floor</code>, <code>hypot</code>, <code>log</code>, <code>max</code>, <code>min</code>, <code>pow</code>, <code>random</code>, <code>round</code>, <code>sin</code>, <code>sqrt</code>, <code>tan</code>, <code>clamp</code></p>"},{"location":"grammar/expressions/#sequence-array-or-string-functions","title":"Sequence (Array or String) Functions","text":"<p><code>length</code>, <code>join</code>, <code>indexof</code>, <code>lastindexof</code>, <code>reverse</code>, <code>slice</code></p>"},{"location":"grammar/expressions/#string-functions","title":"String Functions","text":"<p><code>parseFloat</code>, <code>parseInt</code>, <code>upper</code>, <code>lower</code>, <code>replace</code>, <code>split</code>, <code>substring</code>, <code>trim</code></p>"},{"location":"grammar/expressions/#formatting-functions","title":"Formatting Functions","text":"<p><code>format</code></p>"},{"location":"grammar/expressions/#regexp-functions","title":"RegExp Functions","text":"<p><code>regexp</code>, <code>test</code></p>"},{"location":"grammar/expressions/#other-functions","title":"Other functions","text":"<p># lerp(array, fraction) Provides a linearly interpolated value from the first to the last element in the given array based on the specified interpolation fraction, usually ranging from 0 to 1. For instance, lerp([0, 50], 0.5) yields 25.</p> <p># linearstep(edge0, edge1, x) Calculates a linear interpolation between 0 and 1 for a value x within the range defined by edge0 and edge1. It applies a clamp to ensure the result stays within the 0.0 to 1.0 range.</p> <p># smoothstep(edge0, edge1, x) Performs smooth Hermite interpolation between 0 and 1 for values of x that lie between edge0 and edge1. This function is particularly useful for scenarios requiring a threshold function with a smooth transition, offering a gradual rather than an abrupt change between states.</p>"},{"location":"grammar/import/","title":"Importing Views","text":"<p>GenomeSpy facilitates reusing views by allowing them to be imported from the same specification by name or from external specification files by a URL. The files can be placed flexibly \u2013 it may be practical to split large specifications into multiple files and place them in the same directory. On the other hand, if you have created, for example, an annotation track that you would like the share with the research community, you can upload the specification file and the associated data to a publicly accessible web server. The imported views, both named and URLs, can be parameterized to allow for customization.</p>"},{"location":"grammar/import/#properties","title":"Properties","text":"<code>import</code> Required Type: UrlImport | TemplateImport<p>The method to import a specification.</p> <code>name</code> Type: string<p>The name given to the imported view. This property overrides the name specified in the imported specification and defines an import scope that is used for bookmarkable view visibility and parameter addressing.</p> <code>params</code> Type: (VariableParameter | SelectionParameter)[] | object<p>Dynamic variables that parameterize a visualization. Parameters defined here override the parameters defined in the imported specification.</p>"},{"location":"grammar/import/#urlimport","title":"UrlImport","text":"<code>url</code> Required Type: string<p>Imports a specification from the specified URL.</p>"},{"location":"grammar/import/#templateimport","title":"TemplateImport","text":"<code>template</code> Required Type: string<p>Imports a specification from the current view hierarchy, searching first in the current view, then ascending through ancestors.</p>"},{"location":"grammar/import/#importing-from-a-url","title":"Importing from a URL","text":"<p>Views can be imported from relative and absolute URLs. Relative URLs are imported with respect to the current <code>baseUrl</code>.</p> <p>The imported specification may contain a single, concatenated, or layered view. The <code>baseUrl</code> of the imported specification is updated to match the directory of the imported specification. Thus, you can publish a view (or a track as known in genome browsers) by placing its specification and data available in the same directory on a web server.</p> <p>The URL import supports parameters, which are described below within the named templates.</p> Example<pre><code>{\n  ...,\n  \"vconcat\": [\n    ...,\n    { \"import\": { \"url\": \"includes/annotations.json\" } },\n    { \"import\": { \"url\": \"https://example.site/tracks/annotations.json\" } }\n  ]\n}\n</code></pre>"},{"location":"grammar/import/#repeating-with-named-templates","title":"Repeating with named templates","text":"<p>Instead of importing from external files, views can offer named <code>templates</code> for reuse by their descendants. In the example below, the provided specification features a template called \"myTrack,\" which is applied twice, each instance with a unique set of parameters. The imported view can access the parameters using expressions. This approach enables the modification of visual elements through parameter changes, streamlining the creation of varied visualizations from a single template without the need to duplicate the base specification fragment.</p> <p>Naming an import instance (<code>name</code> on the import spec) overrides the imported view's own name and creates a scope for addressing descendant views. This is used in the App for bookmarkable state like view visibility. When repeating templates, give each import instance a unique <code>name</code> so that descendants with the same internal names remain unambiguous.</p> <pre><code>{\n  \"vconcat\": [\n    {\n      \"import\": {\n        \"template\": \"myTrack\"\n      },\n      \"name\": \"trackA\",\n      \"params\": [{ \"name\": \"size\", \"value\": 5 }]\n    },\n    {\n      \"import\": {\n        \"template\": \"myTrack\"\n      },\n      \"name\": \"trackB\",\n      \"params\": { \"offset\": 3.141, \"size\": 20 }\n    }\n  ],\n  \"templates\": {\n    \"myTrack\": {\n      \"params\": [\n        { \"name\": \"offset\", \"value\": 0 },\n        { \"name\": \"size\", \"value\": 10 }\n      ],\n      \"data\": {\n        \"sequence\": { \"start\": 0, \"stop\": 20, \"step\": 0.2, \"as\": \"x\" }\n      },\n      \"transform\": [\n        { \"type\": \"formula\", \"expr\": \"sin(datum.x + offset)\", \"as\": \"y\" }\n      ],\n      \"mark\": \"point\",\n      \"encoding\": {\n        \"size\": { \"value\": { \"expr\": \"size\" } },\n        \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n        \"y\": { \"field\": \"y\", \"type\": \"quantitative\" }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/parameters/","title":"Parameters","text":"<p>Work in progress</p> <p>This page is a work in progress and is incomplete.</p> <p>Parameters enable various dynamic behaviors in GenomeSpy visualizations, such as interactive selections, conditional encoding, and data filtering with expressions. They also enable parameterization when importing specification fragments from external files or named templates. Parameters in GenomeSpy are heavily inspired by the parameters concept of Vega-Lite.</p>"},{"location":"grammar/parameters/#examples","title":"Examples","text":""},{"location":"grammar/parameters/#using-input-bindings","title":"Using Input Bindings","text":"<p>Parameters can be bound to input elements, such as sliders, dropdowns, and checkboxes. The GenomeSpy Core library shows the input elements below the visualization. In the GenomeSpy App, the input elements are shown in the View visibility menu, allowing the visualization author to provide configuration options to the end user.</p> <p>Parameters with input bindings should have a unique <code>name</code> within the import scope. While not enforced in core, this is necessary for bookmarkable state in the GenomeSpy App.</p> <p>By default, selection parameters and parameters with input bindings are persisted in the GenomeSpy App's bookmarks and provenance history. Use <code>persist: false</code> to opt out of persistence for ephemeral params (such as hover selections) or when <code>encoding.key</code> is not defined for point selections.</p> <p>For point selections, <code>encoding.key</code> should uniquely identify data objects. You can use either a single field or a composite key (an array of field definitions). When using a composite key, keep the field order stable across bookmark creation and restore.</p> <p>The following example shows how to bind parameters to input elements and use them to control the size, angle, and text of a text mark.</p> <pre><code>{\n  \"padding\": 0,\n  \"view\": { \"fill\": \"#cbeef3\" },\n  \"params\": [\n    {\n      \"name\": \"size\",\n      \"value\": 80,\n      \"bind\": { \"input\": \"range\", \"min\": 1, \"max\": 300 }\n    },\n    {\n      \"name\": \"angle\",\n      \"value\": 0,\n      \"bind\": { \"input\": \"range\", \"min\": 0, \"max\": 360 }\n    },\n    {\n      \"name\": \"text\",\n      \"value\": \"Params are cool!\",\n      \"bind\": {\n        \"input\": \"select\",\n        \"options\": [\"Params are cool!\", \"GenomeSpy\", \"Hello\", \"World\"]\n      }\n    }\n  ],\n\n  \"data\": { \"values\": [{}] },\n\n  \"mark\": {\n    \"type\": \"text\",\n    \"font\": \"Lobster\",\n    \"text\": { \"expr\": \"text\" },\n    \"size\": { \"expr\": \"size\" },\n    \"angle\": { \"expr\": \"angle\" }\n  }\n}\n</code></pre>"},{"location":"grammar/parameters/#expressions","title":"Expressions","text":"<p>Parameters can be based on expressions, which can depend on other parameters. They are automatically re-evaluated when the dependent parameters change.</p> <pre><code>{\n  \"view\": { \"stroke\": \"lightgray\" },\n  \"params\": [\n    {\n      \"name\": \"A\",\n      \"value\": 2,\n      \"bind\": { \"input\": \"range\", \"min\": 0, \"max\": 10, \"step\": 1 }\n    },\n    {\n      \"name\": \"B\",\n      \"value\": 3,\n      \"bind\": { \"input\": \"range\", \"min\": 0, \"max\": 10, \"step\": 1 }\n    },\n    {\n      \"name\": \"C\",\n      \"expr\": \"A * B\"\n    }\n  ],\n\n  \"data\": { \"values\": [{}] },\n\n  \"mark\": {\n    \"type\": \"text\",\n    \"size\": 30,\n    \"text\": { \"expr\": \"'' + A + ' * ' + B + ' = ' + C\" }\n  }\n}\n</code></pre>"},{"location":"grammar/parameters/#selection-parameters","title":"Selection parameters","text":"<p>Parameters allow for defining interactive selections, which can be used in conditional encodings. GenomeSpy compiles the conditional encoding rules into efficient GPU shader code, enabling fast interactions in very large data sets.</p>"},{"location":"grammar/parameters/#point-selection","title":"Point selection","text":"<p>The following example has been adapted from Vega-Lite's example gallery with slight modifications (GenomeSpy provides no <code>\"bar\"</code> mark). The specification below is fully compatible with Vega-Lite. You can select multiple bars by holding down the <code>Shift</code> key.</p> <pre><code>{\n  \"description\": \"A bar chart with highlighting on hover and selecting on click. (Inspired by Tableau's interaction style.)\",\n\n  \"data\": {\n    \"values\": [\n      { \"a\": \"A\", \"b\": 28 },\n      { \"a\": \"B\", \"b\": 55 },\n      { \"a\": \"C\", \"b\": 43 },\n      { \"a\": \"D\", \"b\": 91 },\n      { \"a\": \"E\", \"b\": 81 },\n      { \"a\": \"F\", \"b\": 53 },\n      { \"a\": \"G\", \"b\": 19 },\n      { \"a\": \"H\", \"b\": 87 },\n      { \"a\": \"I\", \"b\": 52 }\n    ]\n  },\n  \"params\": [\n    {\n      \"name\": \"highlight\",\n      \"select\": { \"type\": \"point\", \"on\": \"pointerover\" }\n    },\n    { \"name\": \"select\", \"select\": \"point\" }\n  ],\n  \"mark\": {\n    \"type\": \"rect\",\n    \"fill\": \"#4C78A8\",\n    \"stroke\": \"black\"\n  },\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"a\",\n      \"type\": \"ordinal\",\n      \"scale\": { \"type\": \"band\", \"padding\": 0.2 }\n    },\n    \"y\": { \"field\": \"b\", \"type\": \"quantitative\" },\n    \"fillOpacity\": {\n      \"value\": 0.3,\n      \"condition\": { \"param\": \"select\", \"value\": 1 }\n    },\n    \"strokeWidth\": {\n      \"value\": 0,\n      \"condition\": [\n        { \"param\": \"select\", \"value\": 2, \"empty\": false },\n        { \"param\": \"highlight\", \"value\": 1, \"empty\": false }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/parameters/#interval-selection","title":"Interval selection","text":"<p>Interval selections allow for selecting a range of data points along one or two axes. By default, the selection is done by holding down the <code>Shift</code> key and dragging the mouse cursor over the data points. The selection can be cleared by clicking outside the selected area.</p> <pre><code>{\n  \"params\": [\n    {\n      \"name\": \"brush\",\n      \"value\": { \"x\": [2, 4] },\n      \"select\": {\n        \"type\": \"interval\",\n        \"encodings\": [\"x\"]\n      }\n    }\n  ],\n\n  \"data\": { \"url\": \"sincos.csv\" },\n\n  \"mark\": { \"type\": \"point\", \"size\": 100 },\n\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n    \"y\": { \"field\": \"sin\", \"type\": \"quantitative\" },\n    \"color\": {\n      \"condition\": {\n        \"param\": \"brush\",\n        \"value\": \"#38c\"\n      },\n      \"value\": \"#ddd\"\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/scale/","title":"Scale","text":"<p>Scales are functions that map abstract data values (e.g., a type of a point mutation) to visual values (e.g., colors that indicate the type).</p> <p>By default, GenomeSpy configures scales automatically based on the data type (e.g., <code>\"ordinal\"</code>), the visual channel, and the data domain. As the defaults may not always be optimal, the scales can be configured explicitly.</p> Specifying a scale for a channel<pre><code>{\n  \"encoding\": {\n    \"y\": {\n      \"field\": \"impact\",\n      \"type\": \"quantitative\",\n      \"scale\": {\n        \"type\": \"linear\",\n        \"domain\": [0, 1]\n      }\n    }\n  },\n  ...\n}\n</code></pre>"},{"location":"grammar/scale/#vega-lite-scales","title":"Vega-Lite scales","text":"<p>GenomeSpy implements most of the scale types of Vega-Lite. The aim is to replicate their behavior identically (unless stated otherwise) in GenomeSpy. Although that has yet to fully materialize, Vega-Lite's scale documentation generally applies to GenomeSpy as well.</p> <p>The supported scales are: <code>\"linear\"</code>, <code>\"pow\"</code>, <code>\"sqrt\"</code>, <code>\"symlog\"</code>, <code>\"log\"</code>, <code>\"ordinal\"</code>, <code>\"band\"</code>, <code>\"point\"</code>, <code>\"quantize\"</code>, and <code>\"threshold\"</code>. Disabled scale is supported on quantitative channels such as <code>x</code> and <code>opacity</code>.</p> <p>Currently, the following scales are not supported: <code>\"time\"</code>, <code>\"utc\"</code>, <code>\"quantile\"</code>, <code>\"bin-linear\"</code>, <code>\"bin-ordinal\"</code>.</p> <p>Relation to Vega scales</p> <p>In fact, GenomeSpy uses Vega scales, which are based on d3-scale. However, GenomeSpy has GPU-based implementations for the actual scale transformations, ensuring high rendering performance.</p>"},{"location":"grammar/scale/#genomespy-specific-scales","title":"GenomeSpy-specific scales","text":"<p>GenomeSpy provides two additional scales that are designed for molecular sequence data.</p>"},{"location":"grammar/scale/#index-scale","title":"Index scale","text":"<p>The <code>\"index\"</code> scale allows mapping index-based values such as nucleotide or amino-acid locations to positional visual channels. It has traits from both the continuous <code>\"linear\"</code> and the discrete <code>\"band\"</code> scale. It is linear and zoomable but maps indices to the range like the band scale does \u2013 each index has its own band. Properties such as <code>padding</code> work just as in the band scale.</p> <p>The indices must be zero-based, i.e., the counting must start from zero. The numbering of the axis labels can be adjusted to give an impression of, for example, one-based indexing.</p> <p>The index scale is used by default when the field type is <code>\"index\"</code>.</p>"},{"location":"grammar/scale/#point-indices","title":"Point indices","text":"<p>When only the primary positional channel is defined, marks such as <code>\"rect\"</code> fill the whole band.</p> <pre><code>{\n  \"data\": {\n    \"values\": [0, 2, 4, 7, 8, 10, 12]\n  },\n  \"encoding\": {\n    \"x\": { \"field\": \"data\", \"type\": \"index\" }\n  },\n  \"layer\": [\n    {\n      \"mark\": \"rect\",\n      \"encoding\": {\n        \"color\": { \"field\": \"data\", \"type\": \"nominal\" }\n      }\n    },\n    {\n      \"mark\": \"text\",\n      \"encoding\": {\n        \"text\": {\n          \"field\": \"data\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>Marks such as <code>\"point\"</code> that do not support the secondary positional channel are centered.</p> <pre><code>{\n  \"data\": {\n    \"values\": [0, 2, 4, 7, 8, 10, 12]\n  },\n  \"mark\": \"point\",\n  \"encoding\": {\n    \"x\": { \"field\": \"data\", \"type\": \"index\" },\n    \"color\": { \"field\": \"data\", \"type\": \"nominal\" },\n    \"size\": { \"value\": 300 }\n  }\n}\n</code></pre>"},{"location":"grammar/scale/#range-indices","title":"Range indices","text":"<p>When the index scale is used with ranges, e.g., a <code>\"rect\"</code> mark that has both the <code>x</code> and <code>x2</code> channels defined, the ranges must be half open. For example, if a segment should cover the indices 2, 3, and 4, a half-open range would be defined as: x = 2 (inclusive), x2 = 5 (exclusive).</p> <pre><code>{\n  \"data\": {\n    \"values\": [\n      { \"from\": 0, \"to\": 2 },\n      { \"from\": 2, \"to\": 5 },\n      { \"from\": 8, \"to\": 9 },\n      { \"from\": 10, \"to\": 13 }\n    ]\n  },\n  \"encoding\": {\n    \"x\": { \"field\": \"from\", \"type\": \"index\" },\n    \"x2\": { \"field\": \"to\" }\n  },\n  \"layer\": [\n    {\n      \"mark\": \"rect\",\n      \"encoding\": {\n        \"color\": { \"field\": \"from\", \"type\": \"nominal\" }\n      }\n    },\n    {\n      \"mark\": \"text\",\n      \"encoding\": {\n        \"text\": {\n          \"expr\": \"'[' + datum.from + ', ' + datum.to + ')'\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/scale/#adjusting-the-indexing-of-axis-labels","title":"Adjusting the indexing of axis labels","text":"<p>The index scale expects zero-based indexing. However, it may be desirable to display the axis labels using one-based indexing. Use the <code>numberingOffset</code> property adjust the label indices.</p> <pre><code>{\n  \"data\": {\n    \"values\": [0, 2, 4, 7, 8, 10, 12]\n  },\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"data\",\n      \"type\": \"index\",\n      \"scale\": {\n        \"numberingOffset\": 1\n      }\n    }\n  },\n  \"layer\": [\n    {\n      \"mark\": \"rect\",\n      \"encoding\": {\n        \"color\": { \"field\": \"data\", \"type\": \"nominal\" }\n      }\n    },\n    {\n      \"mark\": \"text\",\n      \"encoding\": {\n        \"text\": {\n          \"field\": \"data\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/scale/#locus-scale","title":"Locus scale","text":"<p>The <code>\"locus\"</code> scale is similar to the <code>\"index\"</code> scale, but provides a genome-aware axis with concatenated chromosomes. To use the locus scale, a genome must be specified.</p> <p>The locus scale is used by default when the field type is <code>\"locus\"</code>.</p> <p>Note</p> <p>The locus scale does not map the discrete chromosomes onto the concatenated axis. It's done by the linearizeGenomicCoordinate transform.</p>"},{"location":"grammar/scale/#specifying-the-domain","title":"Specifying the domain","text":"<p>By default, the domain of the locus scale consists of the whole genome. However, You can specify a custom domain using either linearized or genomic coordinates. A genomic coordinate consists of a chromosome (<code>chrom</code>) and an optional position (<code>pos</code>). The left bound's position defaults to zero, whereas the right bound's position defaults to the size of the chromosome. Thus, the chromosomes are inclusive.</p> <p>For example, chromosomes 3, 4, and 5:</p> <pre><code>[{ \"chrom\": \"chr3\" }, { \"chrom\": \"chr5\" }]\n</code></pre> <p>Only the chromosome 3:</p> <pre><code>[{ \"chrom\": \"chr3\" }]\n</code></pre> <p>A specific region inside the chromosome 3:</p> <pre><code>[\n  { \"chrom\": \"chr3\", \"pos\": 1000000 },\n  { \"chrom\": \"chr3\", \"pos\": 2000000 }\n]\n</code></pre> <p>Somewhere inside the chromosome 1:</p> <pre><code>[1000000, 2000000]\n</code></pre>"},{"location":"grammar/scale/#example","title":"Example","text":"<pre><code>{\n  \"genome\": { \"name\": \"hg38\" },\n  \"data\": {\n    \"values\": [\n      { \"chrom\": \"chr3\", \"pos\": 134567890 },\n      { \"chrom\": \"chr4\", \"pos\": 123456789 },\n      { \"chrom\": \"chr9\", \"pos\": 34567890 }\n    ]\n  },\n  \"mark\": \"point\",\n  \"encoding\": {\n    \"x\": {\n      \"chrom\": \"chrom\",\n      \"pos\": \"pos\",\n      \"type\": \"locus\",\n      \"scale\": {\n        \"domain\": [{ \"chrom\": \"chr3\" }, { \"chrom\": \"chr9\" }]\n      }\n    },\n    \"size\": { \"value\": 200 }\n  }\n}\n</code></pre>"},{"location":"grammar/scale/#zooming-and-panning","title":"Zooming and panning","text":"<p>To enable zooming and panning of continuous scales on positional channels, set the <code>zoom</code> scale property to <code>true</code>. Example:</p> <pre><code>{\n  \"x\": {\n    \"field\": \"foo\",\n    \"type\": \"quantitative\",\n    \"scale\": {\n      \"zoom\": true\n    }\n  }\n}\n</code></pre> <p>Both <code>\"index\"</code> and <code>\"locus\"</code> scales are zoomable by default.</p>"},{"location":"grammar/scale/#zoom-extent","title":"Zoom extent","text":"<p>The zoom <code>extent</code> allows you to control how far the scale can be zoomed out or panned (translated). Zoom extent equals the scale domain by default, except for the <code>\"locus\"</code> scale, where it includes the whole genome. Example:</p> <pre><code>{\n  ...,\n  \"scale\": {\n    \"domain\": [10, 20],\n    \"zoom\": {\n      \"extent\": [0, 30]\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/scale/#named-scales","title":"Named scales","text":"<p>By giving the scale a name, it can be accessed through the API.</p> <pre><code>{\n  ...,\n  \"scale\": {\n    \"name\": \"myScale\"\n  }\n}\n</code></pre>"},{"location":"grammar/scale/#axes","title":"Axes","text":"<p>Positional channels are usually annotated with axes, which are automatically generated based on the scale type. However, you can customize the axis by specifying the <code>axis</code> property in the encoding block.</p> <pre><code>{\n  ...,\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"foo\",\n      \"type\": \"quantitative\",\n      \"axis\": {\n        \"title\": \"My axis title\"\n      }\n    }\n  }\n}\n</code></pre> <p>GenomeSpy implements most of Vega-Lite's axis properties. See the interface definition for supported properties. TODO: Write a proper documentation.</p> <p>Grid lines</p> <p>Grid lines are hidden by default in GenomeSpy and can be enabled for each view using the <code>grid</code> property. The default behavior will be configurable once GenomeSpy supports themes.</p>"},{"location":"grammar/scale/#genome-axis-for-loci","title":"Genome axis for loci","text":"<p>The genome axis is a special axis for the <code>\"locus\"</code> scale. It displays chromosome names and the intra-chromosomal coordinates. You can adjust the style of the chromosome axis and grid using various parameters.</p> <pre><code>{\n  \"genome\": { \"name\": \"hg38\" },\n  \"data\": { \"values\": [] },\n  \"mark\": \"point\",\n\n  \"encoding\": {\n    \"x\": {\n      \"chrom\": \"a\",\n      \"pos\": \"b\",\n      \"type\": \"locus\",\n\n      \"axis\": {\n        \"chromTickColor\": \"#5F87F5\",\n        \"chromLabelColor\": \"#E16B67\",\n\n        \"grid\": true,\n        \"gridColor\": \"gray\",\n        \"gridOpacity\": 0.5,\n        \"gridDash\": [1, 11],\n\n        \"chromGrid\": true,\n        \"chromGridDash\": [3, 3],\n        \"chromGridColor\": \"#5F87F5\",\n        \"chromGridOpacity\": 0.7,\n        \"chromGridFillEven\": \"#BEFACC\",\n        \"chromGridFillOdd\": \"#FDFCE8\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/scale/#fully-customized-axes","title":"Fully customized axes","text":"<p>You can also disable the genome axis and grid and specify a custom axis instead. The <code>\"axisGenome\"</code> data source provides the chromosomes and their sizes, which can be used to create a custom axes or grids for a view.</p>"},{"location":"grammar/types/","title":"Types Used in the Grammar","text":"<p>Note</p> <p>The list is still incomplete.</p>"},{"location":"grammar/types/#compareparams","title":"CompareParams","text":"<code>field</code> Required Type: string (field name)[] | string (field name)<p>The field(s) to sort by</p> <code>order</code> Type: (<code>\"ascending\"</code> | <code>\"descending\"</code>)[] | <code>\"ascending\"</code> | <code>\"descending\"</code><p>The order(s) to use: <code>\"ascending\"</code> (default), <code>\"descending\"</code>.</p>"},{"location":"grammar/types/#dynamicopacity","title":"DynamicOpacity","text":"<code>channel</code> Type: <code>\"x\"</code> | <code>\"y\"</code><p>TODO</p> <code>unitsPerPixel</code> Required Type: array<p>Stops expressed as units (base pairs, for example) per pixel.</p> <code>values</code> Required Type: array<p>Opacity values that match the given stops.</p>"},{"location":"grammar/types/#exprref","title":"ExprRef","text":"<code>expr</code> Required Type: string<p>The expression string.</p>"},{"location":"grammar/types/#paddings","title":"Paddings","text":"<code>bottom</code> Type: number<p>TODO</p> <code>left</code> Type: number<p>TODO</p> <code>right</code> Type: number<p>TODO</p> <code>top</code> Type: number<p>TODO</p>"},{"location":"grammar/types/#step","title":"Step","text":"<code>step</code> Required Type: number<p>TODO</p>"},{"location":"grammar/types/#sizedef","title":"SizeDef","text":"<code>grow</code> Type: number<p>Share of the remaining space. See child sizing for details.</p> <code>px</code> Type: number<p>Size in pixels</p>"},{"location":"grammar/types/#title","title":"Title","text":"<code>align</code> Type: <code>\"left\"</code> | <code>\"center\"</code> | <code>\"right\"</code><p>Horizontal text alignment for title text. One of <code>\"left\"</code>, <code>\"center\"</code>, or <code>\"right\"</code>.</p> <code>anchor</code> Type: <code>None</code> | <code>start</code> | <code>middle</code> | <code>end</code><p>The anchor position for placing the title and subtitle text. One of <code>\"start\"</code>, <code>\"middle\"</code>, or <code>\"end\"</code>. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.</p> <code>angle</code> Type: number | ExprRef<p>Angle in degrees of title and subtitle text.</p> <code>baseline</code> Type: <code>\"top\"</code> | <code>\"middle\"</code> | <code>\"bottom\"</code> | <code>\"alphabetic\"</code><p>Vertical text baseline for title and subtitle text. One of <code>\"alphabetic\"</code> (default), <code>\"top\"</code>, <code>\"middle\"</code>, or <code>\"bottom\"</code>.</p> <code>color</code> Type: string | ExprRef<p>Text color for title text.</p> <code>dx</code> Type: number<p>Delta offset for title and subtitle text x-coordinate.</p> <code>dy</code> Type: number<p>Delta offset for title and subtitle text y-coordinate.</p> <code>font</code> Type: string<p>Font name for title text.</p> <code>fontSize</code> Type: number | ExprRef<p>Font size in pixels for title text.</p> <code>fontStyle</code> Type: <code>\"normal\"</code> | <code>\"italic\"</code><p>Font style for title text.</p> <code>fontWeight</code> Type: number | <code>\"thin\"</code> | <code>\"light\"</code> | <code>\"regular\"</code> | <code>\"normal\"</code> | <code>\"medium\"</code> | <code>\"bold\"</code> | <code>\"black\"</code><p>Font weight for title text. This can be either a string (e.g <code>\"bold\"</code>, <code>\"normal\"</code>) or a number (<code>100</code>, <code>200</code>, <code>300</code>, ..., <code>900</code> where <code>\"normal\"</code> = <code>400</code> and <code>\"bold\"</code> = <code>700</code>).</p> <code>frame</code> Type: <code>\"bounds\"</code> | <code>\"group\"</code><p>The reference frame for the anchor position, one of <code>\"bounds\"</code> (to anchor relative to the full bounding box) or <code>\"group\"</code> (to anchor relative to the group width or height).</p> <code>offset</code> Type: number<p>The orthogonal offset in pixels by which to displace the title group from its position along the edge of the chart.</p> <code>orient</code> Type: <code>\"none\"</code> | <code>\"left\"</code> | <code>\"right\"</code> | <code>\"top\"</code> | <code>\"bottom\"</code><p>Default title orientation (<code>\"none\"</code>, <code>\"top\"</code>, <code>\"bottom\"</code>, <code>\"left\"</code>, or <code>\"right\"</code>)</p> <code>style</code> Type: string<p>A mark style property to apply to the title text mark. If not specified, a default style of <code>\"group-title\"</code> is applied.</p> <code>text</code> Required Type: string | ExprRef<p>The title text.</p>"},{"location":"grammar/types/#viewbackground","title":"ViewBackground","text":"<code>fill</code> Type: string | ExprRef<p>The fill color.</p> <code>fillOpacity</code> Type: number | ExprRef<p>The fill opacity. Value between <code>0</code> and <code>1</code>.</p> <code>shadowBlur</code> Type: number | ExprRef<p>The blur radius of the drop shadow in pixels. Higher values produce a more diffuse shadow.</p> <p>Default value: <code>0</code></p> <code>shadowColor</code> Type: string | ExprRef<p>The color of the drop shadow. Any valid CSS color string is allowed.</p> <p>Default value: <code>\"black\"</code></p> <code>shadowOffsetX</code> Type: number | ExprRef<p>The horizontal offset of the drop shadow in pixels. Positive values move the shadow to the right.</p> <p>Default value: <code>0</code></p> <code>shadowOffsetY</code> Type: number | ExprRef<p>The vertical offset of the drop shadow in pixels. Positive values move the shadow downward.</p> <p>Default value: <code>0</code></p> <code>shadowOpacity</code> Type: number | ExprRef<p>The opacity of the drop shadow. Value between <code>0</code> (fully transparent) and <code>1</code> (fully opaque).</p> <p>Default value: <code>0</code> (disabled)</p> <code>stroke</code> Type: string | ExprRef<p>The stroke color</p> <code>strokeOpacity</code> Type: number | ExprRef<p>The stroke opacity. Value between <code>0</code> and <code>1</code>.</p> <code>strokeWidth</code> Type: number<p>The stroke width in pixels.</p>"},{"location":"grammar/types/#viewopacitydef","title":"ViewOpacityDef","text":"<p>Type: number | DynamicOpacity | ExprRef</p>"},{"location":"grammar/composition/","title":"View Composition","text":"<p>GenomeSpy replicates the hierarchical composition model of Vega-Lite, and currently provides the concatenation and <code>layer</code> composition operators in the core library. In addition, the GenomeSpy app provides a facet operator for visualizing sample collections using a track-based layout.</p> <p>The hierarchical model allows for nesting composition operators. For instance, you could have a visualization with two views side by side, and those views could contain multiple layered views. The views in the hierarchy inherit (transformed) <code>data</code> and <code>encoding</code> from their parents, and in some cases, the views may also share scales and axes with their siblings and parents. The data and encoding inherited from ancestors can always be overridden by the descendants.</p>"},{"location":"grammar/composition/#scale-and-axis-resolution","title":"Scale and axis resolution","text":"<p>Each visual channel of a view has a scale, which is either <code>\"independent\"</code> or <code>\"shared\"</code> with other views. For example, sharing the scale on the positional <code>x</code> channel links the zooming interactions of the participanting views through the shared scale domain. The axes of positional channels can be configured similarly.</p> <p>The <code>resolve</code> property configures the scale and axis resolutions for the view's children.</p> An example of a resolution configuration<pre><code>{\n  \"resolve\": {\n    \"scale\": {\n      \"x\": \"shared\",\n      \"y\": \"independent\",\n      \"color\": \"independent\"\n    },\n    \"axis\": {\n      \"x\": \"shared\",\n      \"y\": \"independent\"\n    }\n  },\n  ...\n}\n</code></pre>"},{"location":"grammar/composition/#shared","title":"Shared","text":"<p>The example below shows an excerpt of segmented copy number data layered on raw SNP logR values. The scale of the <code>y</code> channel is shared by default and the domain is unioned. As the <code>x</code> channel's scale is also shared, the zooming interaction affects both views.</p> <pre><code>{\n  \"layer\": [\n    {\n      \"data\": { \"url\": \"../data/cnv_chr19_raw.tsv\" },\n      \"title\": \"Single probe\",\n\n      \"mark\": {\n        \"type\": \"point\",\n        \"geometricZoomBound\": 9.5\n      },\n\n      \"encoding\": {\n        \"x\": { \"field\": \"Position\", \"type\": \"index\" },\n        \"y\": { \"field\": \"logR\", \"type\": \"quantitative\" },\n        \"size\": { \"value\": 225 },\n        \"opacity\": { \"value\": 0.15 }\n      }\n    },\n    {\n      \"data\": {\n        \"url\": \"../data/cnv_chr19_segs.tsv\"\n      },\n      \"title\": \"Segment mean\",\n      \"mark\": {\n        \"type\": \"rule\",\n        \"size\": 3.0,\n        \"minLength\": 3.0,\n        \"color\": \"black\"\n      },\n      \"encoding\": {\n        \"x\": { \"field\": \"startpos\", \"type\": \"index\" },\n        \"x2\": { \"field\": \"endpos\" },\n        \"y\": { \"field\": \"segMean\", \"type\": \"quantitative\" }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/composition/#independent","title":"Independent","text":"<p>By specifying that the scales of the <code>y</code> channel should remain <code>\"independent\"</code>, both layers get their own scales and axes. Obviously, such a configuration makes no sense with these data.</p> <pre><code>{\n  \"resolve\": {\n    \"scale\": { \"y\": \"independent\" },\n    \"axis\": { \"y\": \"independent\" }\n  },\n  \"layer\": [\n    {\n      \"data\": { \"url\": \"../data/cnv_chr19_raw.tsv\" },\n      \"title\": \"Single probe\",\n\n      \"mark\": {\n        \"type\": \"point\",\n        \"geometricZoomBound\": 9.5\n      },\n\n      \"encoding\": {\n        \"x\": { \"field\": \"Position\", \"type\": \"index\" },\n        \"y\": { \"field\": \"logR\", \"type\": \"quantitative\" },\n        \"size\": { \"value\": 225 },\n        \"opacity\": { \"value\": 0.15 }\n      }\n    },\n    {\n      \"data\": {\n        \"url\": \"../data/cnv_chr19_segs.tsv\"\n      },\n      \"title\": \"Segment mean\",\n      \"mark\": {\n        \"type\": \"rule\",\n        \"size\": 3.0,\n        \"minLength\": 3.0,\n        \"color\": \"black\"\n      },\n      \"encoding\": {\n        \"x\": { \"field\": \"startpos\", \"type\": \"index\" },\n        \"x2\": { \"field\": \"endpos\" },\n        \"y\": { \"field\": \"segMean\", \"type\": \"quantitative\" }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/composition/concat/","title":"View Concatenation","text":"<p>The <code>vconcat</code> and <code>hconcat</code> composition operators place views side-by-side either vertically or horizontally. The <code>vconcat</code> is practical for building genomic visualizations with multiple tracks. The <code>concat</code> operator with the <code>columns</code> property produces a wrapping grid layout.</p> <p>The spacing (in pixels) between concatenated views can be adjusted using the <code>spacing</code> property (Default: <code>10</code>).</p>"},{"location":"grammar/composition/concat/#example","title":"Example","text":""},{"location":"grammar/composition/concat/#vertical","title":"Vertical","text":"<p>Using <code>vconcat</code> for a vertical layout.</p> <pre><code>{\n  \"data\": { \"url\": \"sincos.csv\" },\n\n  \"spacing\": 20,\n\n  \"vconcat\": [\n    {\n      \"mark\": \"point\",\n      \"encoding\": {\n        \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n        \"y\": { \"field\": \"sin\", \"type\": \"quantitative\" }\n      }\n    },\n    {\n      \"mark\": \"point\",\n      \"encoding\": {\n        \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n        \"y\": { \"field\": \"cos\", \"type\": \"quantitative\" }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#horizontal","title":"Horizontal","text":"<p>Using <code>hconcat</code> for a horizontal layout.</p> <pre><code>{\n  \"data\": { \"url\": \"sincos.csv\" },\n\n  \"hconcat\": [\n    {\n      \"mark\": \"point\",\n      \"encoding\": {\n        \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n        \"y\": { \"field\": \"sin\", \"type\": \"quantitative\" }\n      }\n    },\n    {\n      \"mark\": \"point\",\n      \"encoding\": {\n        \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n        \"y\": { \"field\": \"cos\", \"type\": \"quantitative\" }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#grid","title":"Grid","text":"<p>Using <code>concat</code> and <code>columns</code> for a grid layout. For simplicity, the same visualization is used for all panels in the grid.</p> <pre><code>{\n  \"data\": { \"url\": \"sincos.csv\" },\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n    \"y\": { \"field\": \"sin\", \"type\": \"quantitative\" }\n  },\n\n  \"columns\": 3,\n  \"concat\": [\n    { \"mark\": \"point\" },\n    { \"mark\": \"point\" },\n    { \"mark\": \"point\" },\n    { \"mark\": \"point\" },\n    { \"mark\": \"point\" },\n    { \"mark\": \"point\" },\n    { \"mark\": \"point\" },\n    { \"mark\": \"point\" },\n    { \"mark\": \"point\" }\n  ]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#separators","title":"Separators","text":"<p>You can draw separators between child views using the <code>separator</code> property. Separators are centered within the spacing gaps and do not affect layout. Use <code>true</code> to enable the defaults or provide a <code>rule</code> mark style object. Use <code>includePlotMargin: false</code> to keep the separators inside the plot area.</p> <pre><code>{\n  \"data\": { \"url\": \"sincos.csv\" },\n\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n    \"y\": { \"field\": \"sin\", \"type\": \"quantitative\" }\n  },\n\n  \"resolve\": { \"scale\": { \"x\": \"shared\" }, \"axis\": { \"x\": \"shared\" } },\n\n  \"spacing\": 29,\n\n  \"separator\": {\n    \"color\": \"#bbb\",\n    \"strokeDash\": [6, 4],\n    \"size\": 1,\n    \"includePlotMargin\": true\n  },\n\n  \"vconcat\": [{ \"mark\": \"point\" }, { \"mark\": \"point\" }, { \"mark\": \"point\" }]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#child-sizing","title":"Child sizing","text":"<p>The concatenation operators mimic the behavior of the CSS flexbox. The child views have an absolute minimum size (<code>px</code>) in pixels and an unitless <code>grow</code> value that specifies in what proportion the possible remaining space should be distributed. The remaining space depends on the parent view's size.</p> <p>In the following example, the left view has a width of <code>20</code> px, the center view has a grow of <code>1</code>, and the right view has a grow of <code>2</code>. If you resize the web browser, you can observe that the width of the left view stays constant while the remaining space is distributed in proportions of 1:2.</p> <pre><code>{\n  \"data\": { \"values\": [{}] },\n\n  \"spacing\": 10,\n\n  \"hconcat\": [\n    {\n      \"width\": { \"px\": 20 },\n      \"mark\": \"rect\"\n    },\n    {\n      \"width\": { \"grow\": 1 },\n      \"mark\": \"rect\"\n    },\n    {\n      \"width\": { \"grow\": 2 },\n      \"mark\": \"rect\"\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#sizedef","title":"SizeDef","text":"<code>grow</code> Type: number<p>Share of the remaining space. See child sizing for details.</p> <code>px</code> Type: number<p>Size in pixels</p> <p>The size may have both absolute (<code>px</code>) and proportional (<code>grow</code>) components. When views are nested, both the absolute and proportional sizes are added up. Thus, the width of the above example is <code>{ \"px\": 40, \"grow\": 3 }</code>. The spacing between the child views is added to the total absolute width.</p> <p>Views' size properties (<code>width</code> and <code>height</code>) accept both SizeDef objects and shorthands. The SizeDef objects contain either or both of <code>px</code> and <code>grow</code> properties. Numbers are interpreted as as absolute sizes, and <code>\"container\"</code> is the same as <code>{ grow: 1 }</code>. Undefined sizes generally default to <code>\"container\"</code>.</p> <p>Concatenation operators can nested flexibly to build complex layouts as in the following example.</p> <pre><code>{\n  \"data\": { \"values\": [{}] },\n\n  \"hconcat\": [\n    { \"mark\": \"rect\" },\n    {\n      \"vconcat\": [{ \"mark\": \"rect\" }, { \"mark\": \"rect\" }]\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#scrollable-viewports","title":"Scrollable viewports","text":"<p>Sometimes the concents of a view are so large that they do not fit into the available space. In such cases, the view can be made scrollable by setting an explicit size for the view using the <code>viewportWidth</code> and <code>viewportHeight</code> properties. They accept the same values as <code>width</code> and <code>height</code> properties except for the step size. Scrollable viewports are particularly useful for categorical data types (<code>\"ordinal\"</code> and <code>\"nominal\"</code>) and respective scales and axes that do not support zooming and panning.</p> <pre><code>{\n  \"height\": { \"step\": 20 },\n  \"viewportHeight\": \"container\",\n\n  \"view\": { \"stroke\": \"lightgray\" },\n\n  \"data\": { \"sequence\": { \"start\": 0, \"stop\": 31, \"step\": 1 } },\n\n  \"encoding\": {\n    \"x\": { \"field\": \"data\", \"type\": \"quantitative\" },\n    \"y\": { \"field\": \"data\", \"type\": \"ordinal\" }\n  },\n\n  \"mark\": { \"type\": \"point\" }\n}\n</code></pre>"},{"location":"grammar/composition/concat/#resolve","title":"Resolve","text":"<p>By default, all channels have <code>\"independent\"</code> scales and axes. However, because track-based layouts that resemble genome browsers are such a common use case, <code>vconcat</code> defaults to <code>\"shared\"</code> resolution for <code>x</code> channel and <code>hconcat</code> defaults to <code>\"shared\"</code> resolution for <code>y</code> channel.</p>"},{"location":"grammar/composition/concat/#shared-axes","title":"Shared axes","text":"<p>Concatenation operators support shared axes on channels that also have shared scales. Axis domain line, ticks, and labels are drawn only once for each row or column. Grid lines are drawn for all participating views.</p> <pre><code>{\n  \"data\": { \"url\": \"sincos.csv\" },\n\n  \"resolve\": {\n    \"scale\": { \"x\": \"shared\", \"y\": \"shared\" },\n    \"axis\": { \"x\": \"shared\", \"y\": \"shared\" }\n  },\n\n  \"spacing\": 20,\n\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\", \"axis\": { \"grid\": true } },\n    \"y\": { \"field\": \"sin\", \"type\": \"quantitative\", \"axis\": { \"grid\": true } }\n  },\n\n  \"columns\": 2,\n\n  \"concat\": [\n    { \"mark\": \"point\", \"view\": { \"stroke\": \"lightgray\" } },\n    { \"mark\": \"point\", \"view\": { \"stroke\": \"lightgray\" } },\n    { \"mark\": \"point\", \"view\": { \"stroke\": \"lightgray\" } },\n    { \"mark\": \"point\", \"view\": { \"stroke\": \"lightgray\" } }\n  ]\n}\n</code></pre>"},{"location":"grammar/composition/layer/","title":"Layering Views","text":"<p>The <code>layer</code> operator superimposes multiple views over each other.</p>"},{"location":"grammar/composition/layer/#example","title":"Example","text":"<pre><code>{\n  \"data\": {\n    \"values\": [\n      { \"a\": \"A\", \"b\": 28 },\n      { \"a\": \"B\", \"b\": 55 },\n      { \"a\": \"C\", \"b\": 43 },\n      { \"a\": \"D\", \"b\": 91 },\n      { \"a\": \"E\", \"b\": 81 },\n      { \"a\": \"F\", \"b\": 53 },\n      { \"a\": \"G\", \"b\": 19 },\n      { \"a\": \"H\", \"b\": 87 },\n      { \"a\": \"I\", \"b\": 52 }\n    ]\n  },\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"a\",\n      \"type\": \"nominal\",\n      \"scale\": { \"padding\": 0.1 },\n      \"axis\": { \"labelAngle\": 0 }\n    },\n    \"y\": { \"field\": \"b\", \"type\": \"quantitative\" }\n  },\n  \"layer\": [\n    {\n      \"name\": \"Bar\",\n      \"mark\": \"rect\"\n    },\n    {\n      \"name\": \"Label\",\n      \"mark\": { \"type\": \"text\", \"dy\": -9 },\n      \"encoding\": {\n        \"text\": { \"field\": \"b\" }\n      }\n    }\n  ]\n}\n</code></pre> <p>To specify multiple layers, use the <code>layer</code> property:</p> <pre><code>{\n  \"layer\": [\n    ...  // Single or layered view specifications\n  ]\n}\n</code></pre> <p>The provided array may contain both single view specifications and layer specifications. The encodings and data that are specified in a layer view propagate to its descendants. For example, in the above example, the <code>\"Bar\"</code> and <code>\"Label\"</code> views inherit the data and encodings for the <code>x</code> and <code>y</code> channels from their parent, the layer view.</p>"},{"location":"grammar/composition/layer/#resolve","title":"Resolve","text":"<p>By default, layers share their scales and axes, unioning the data domains.</p>"},{"location":"grammar/composition/layer/#more-examples","title":"More examples","text":""},{"location":"grammar/composition/layer/#lollipop-plot","title":"Lollipop plot","text":"<p>This example layers two marks to create a composite mark, a lollipop. Yet another layer is used for the baseline.</p> <pre><code>{\n  \"name\": \"The Root\",\n  \"description\": \"Lollipop plot example\",\n\n  \"layer\": [\n    {\n      \"name\": \"Baseline\",\n      \"data\": { \"values\": [0] },\n      \"mark\": \"rule\",\n      \"encoding\": {\n        \"y\": { \"field\": \"data\", \"type\": \"quantitative\", \"title\": null },\n        \"color\": { \"value\": \"lightgray\" }\n      }\n    },\n    {\n      \"name\": \"Arrows\",\n\n      \"data\": {\n        \"sequence\": {\n          \"start\": 0,\n          \"stop\": 6.284,\n          \"step\": 0.39269908169,\n          \"as\": \"x\"\n        }\n      },\n\n      \"transform\": [\n        { \"type\": \"formula\", \"expr\": \"sin(datum.x)\", \"as\": \"sin(x)\" }\n      ],\n\n      \"encoding\": {\n        \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n        \"y\": {\n          \"field\": \"sin(x)\",\n          \"type\": \"quantitative\",\n          \"scale\": { \"padding\": 0.1 }\n        },\n        \"color\": { \"field\": \"sin(x)\", \"type\": \"quantitative\" }\n      },\n\n      \"layer\": [\n        {\n          \"name\": \"Arrow shafts\",\n\n          \"mark\": {\n            \"type\": \"rule\",\n            \"size\": 3\n          }\n        },\n        {\n          \"name\": \"Arrowheads\",\n\n          \"mark\": {\n            \"type\": \"point\",\n            \"size\": 500,\n            \"filled\": true\n          },\n\n          \"encoding\": {\n            \"shape\": {\n              \"field\": \"sin(x)\",\n              \"type\": \"nominal\",\n              \"scale\": {\n                \"type\": \"threshold\",\n                \"domain\": [-0.01, 0.01],\n                \"range\": [\"triangle-down\", \"diamond\", \"triangle-up\"]\n              }\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/data/","title":"Data Input","text":"<p>Like Vega-Lite's data model, GenomeSpy utilizes a tabular data structure as its fundamental data model, resembling a spreadsheet or database table. Each data set in GenomeSpy is considered to consist of a set of records, each containing various named data fields.</p> <p>In GenomeSpy, the <code>data</code> property within a view specification describes the data source. In a hierarchically composed view specification, the views inherit the data, which may be further transformed, from their parent views. However, each view can also override the inherited data.</p> <p>Non-indexed eager data, which is fully loaded during the visualization initialization stage, can be provided as inline data (<code>values</code>) or by specifying a URL from which the data can be loaded (<code>url</code>). Additionally, you can use a <code>sequence</code> generator for generating sequences of numbers.</p> <p>GenomeSpy provides several lazy data sources that load data on-demand in response to user interactions to support large genomic data sets comprising millions of records. These data sources enable easy handling of standard bioinformatic data formats such as indexed FASTA and BigWig.</p> <p>Furthermore, GenomeSpy enables the creation of an empty data source with a given <code>name</code>. This data source can be dynamically updated using the API, making it particularly useful when embedding GenomeSpy in web applications.</p> <ul> <li>Eager data</li> <li>Lazy data</li> </ul>"},{"location":"grammar/data/eager/","title":"Eager Data Sources","text":"<p>Eager data sources load and process all available data during the initialization stage. They are suitable for small data sets as they do not support partial loading or loading in response to user interactions. However, eager data sources are often more flexible and straightforward than lazy ones.</p> <p>GenomeSpy inputs eager data as tabular <code>\"csv\"</code>, <code>\"tsv\"</code>, and <code>\"json\"</code> files or as non-indexed <code>\"fasta\"</code> files. Data can be loaded from URLs or provided inline. You can also use generators to generate data on the fly and further modify them using transforms.</p> <p>The <code>data</code> property of the view specification describes a data source. The following example loads a tab-delimited file. By default, GenomeSpy infers the format from the file extension. However, in bioinformatics, CSV files are often actually tab-delimited, and you must specify the <code>\"tsv\"</code> explicitly:</p> Example: Eagerly loading data from a URL<pre><code>{\n  \"data\": {\n    \"url\": \"fileWithTabs.csv\",\n    \"format\": { \"type\": \"tsv\" }\n  },\n  ...\n}\n</code></pre> <p>With the exception of url arrays and the unsupported geographical formats, the data property of GenomeSpy is identical to Vega-Lite's data property.</p> <p>Type inference</p> <p>GenomeSpy uses vega-loader to parse tabular data and infer its data types. Vega-loader is sometimes overly eager to interpret strings as a dates. In such cases, the field types need to be specified explicitly. On the other hand, explicit type specification also gives a significant performance boost to parsing performance.</p> <p>Handling empty (NA) values</p> <p>Empty or missing values must be presented as empty strings instead of <code>NA</code> that R writes by default. Otherwise type inference fails for numeric fields.</p>"},{"location":"grammar/data/eager/#url-data","title":"URL Data","text":"<p>Data can be loaded from a URL using the <code>url</code> property. The URL can be absolute or relative to the page where GenomeSpy is embedded.</p> <p>In addition to loading data from a single URL, you can also load data from multiple URLs by providing an array of URLs. This is useful when files have different columns that are folded (pivoted) into a long (tidy) format. The transformation pipeline is automatically initialized for each URL, and the final data is a concatenation of the results from all URLs.</p> Example: Loading data from multiple URLs<pre><code>{\n  \"data\": {\n    \"url\": [\n      \"fileWithTabs1.tsv\",\n      \"fileWithTabs2.tsv\"\n    ],\n    \"format\": { \"type\": \"tsv\" }\n  },\n  ...\n}\n</code></pre> <p>When the number of URLs is large, it is more convenient to place the list of files in a separate file instead of the view specification.</p> Example: Loading data from multiple URLs listed in a file<pre><code>{\n  \"data\": {\n    \"url\": { \"urlsFromFile\": \"variant-file-list.tsv\", \"type\": \"tsv\" },\n    \"format\": { \"type\": \"tsv\" }\n  },\n  ...\n}\n</code></pre> <p>The file containing the list of URLs must be a JSON file with a single string array or a tabular file with a single column named <code>url</code>.</p>"},{"location":"grammar/data/eager/#named-data","title":"Named Data","text":"<p>When embedding GenomeSpy in a web application or page, data can be added or updated at runtime using the API. Data sources are referenced by a name, which is passed to the <code>updateNamedData</code> method:</p> <pre><code>{\n    \"data\": {\n        \"name\": \"myResults\"\n    }\n    ...\n}\n</code></pre> <pre><code>const api = await embed(\"#container\", spec);\napi.updateNamedData(\"myResults\", [\n  { x: 1, y: 2 },\n  { x: 2, y: 3 },\n]);\n</code></pre> <p>Although named data can be updated dynamically, it does not automatically respond to user interactions. For practical examples of dynamically updated named data, check the embed-examples package.</p>"},{"location":"grammar/data/eager/#bioinformatic-formats","title":"Bioinformatic Formats","text":"<p>Most bioinformatic data formats are supported through lazy data. The following formats are supported as eager data with the <code>url</code> source.</p>"},{"location":"grammar/data/eager/#fasta","title":"FASTA","text":"<p>The type of FASTA format is <code>\"fasta\"</code> as shown in the example below:</p> <pre><code>{\n  \"data\": {\n    \"url\": \"16SRNA_Deino_87seq_copy.aln\",\n    \"format\": {\n      \"type\": \"fasta\"\n    }\n  },\n  ...\n}\n</code></pre> <p>The FASTA loader produces data objects with two fields: <code>identifier</code> and <code>sequence</code>. With the <code>\"flattenSequence\"</code> transform you can split the sequences into individual bases (one object per base) for easier visualization.</p>"},{"location":"grammar/data/lazy/","title":"Lazy Data Sources","text":"<p>Lazy data sources load data on-demand in response to user interactions. Unlike eager sources, most lazy data sources support indexing, which offers the capability to retrieve and load data partially and incrementally, as users navigate the genome. This is especially useful for very large datasets that are infeasible to load in their entirety.</p> <p>How it works</p> <p>Lazy data sources observe the scale domains of the view where the data source is specified. When the domain changes as a result of an user interaction, the data source invokes a request to fetch a new subset of the data. Lazy sources need the visual <code>channel</code> to be specified, which is used to determine the scale to observe. For genomic data sources, the channel defaults to <code>\"x\"</code>.</p> <p>Lazy data sources are specified using the <code>lazy</code> property of the <code>data</code> object. Unlike in eager data, the <code>type</code> of the data source must be specified explicitly:</p> Example: Specifiying a lazy data source<pre><code>{\n  \"data\": {\n    \"lazy\": {\n      \"type\": \"bigwig\",\n      \"url\": \"https://data.genomespy.app/genomes/hg38/hg38.gc5Base.bw\"\n    }\n  },\n  ...\n}\n</code></pre>"},{"location":"grammar/data/lazy/#indexed-fasta","title":"Indexed FASTA","text":"<p>The <code>\"indexedFasta\"</code> source enable fast random access to a reference sequence. It loads the sequence as three consecutive chuncks that cover and flank the currently visible region (domain), allowing the user to rapidly pan the view. The chunks are provided as data objects with the following fields: <code>chrom</code> (string), <code>start</code> (integer), and <code>sequence</code> (a string of bases).</p>"},{"location":"grammar/data/lazy/#parameters","title":"Parameters","text":"<code>channel</code> Type: <code>\"x\"</code> | <code>\"y\"</code><p>Which channel's scale domain to monitor.</p> <p>Default value: <code>\"x\"</code></p> <code>debounce</code> Type: number | ExprRef<p>Debounce time for data updates, in milliseconds. Debouncing prevents excessive data updates when the user is zooming or panning around.</p> <p>Default value: <code>200</code></p> <code>debounceMode</code> Type: string<p>The debounce mode for data updates. If set to <code>\"domain\"</code>, domain change events (panning and zooming) will be debounced. If set to <code>\"window\"</code>, the data fetches initiated by the changes to the visible window (or tile) will be debounced.  If your data is small, the <code>\"window\"</code> is better as it will start fetching data while the user is still panning around, resulting in a shorter perceived latency.</p> <p>Default value: <code>\"window\"</code></p> <code>indexUrl</code> Type: string<p>URL of the index file.</p> <p>Default value: <code>url</code> + <code>\".fai\"</code>.</p> <code>url</code> Required Type: string<p>URL of the fasta file.</p> <code>windowSize</code> Type: number<p>Size of each chunk when fetching the fasta file. Data is only fetched when the length of the visible domain smaller than the window size.</p> <p>Default value: <code>7000</code></p>"},{"location":"grammar/data/lazy/#example","title":"Example","text":"<p>The example below shows how to specify a sequence track using an indexed FASTA file. The sequence chunks are split into separate data objects using the <code>\"flattenSequence\"</code> transform, and the final position of each nucleotide is computed using the <code>\"formula\"</code> transform. Please note that new data are fetched only when the user zooms into a region smaller than the window size (default: 7000 bp).</p> <pre><code>{\n  \"genome\": { \"name\": \"hg38\" },\n\n  \"data\": {\n    \"lazy\": {\n      \"type\": \"indexedFasta\",\n      \"url\": \"https://data.genomespy.app/genomes/hg38/hg38.fa\"\n    }\n  },\n\n  \"transform\": [\n    {\n      \"type\": \"flattenSequence\",\n      \"field\": \"sequence\",\n      \"as\": [\"rawPos\", \"base\"]\n    },\n    { \"type\": \"formula\", \"expr\": \"datum.rawPos + datum.start\", \"as\": \"pos\" }\n  ],\n\n  \"encoding\": {\n    \"x\": {\n      \"chrom\": \"chrom\",\n      \"pos\": \"pos\",\n      \"type\": \"locus\",\n      \"scale\": {\n        \"domain\": [\n          { \"chrom\": \"chr7\", \"pos\": 20003500 },\n          { \"chrom\": \"chr7\", \"pos\": 20003540 }\n        ]\n      }\n    },\n    \"color\": {\n      \"field\": \"base\",\n      \"type\": \"nominal\",\n      \"scale\": {\n        \"domain\": [\"A\", \"C\", \"T\", \"G\", \"a\", \"c\", \"t\", \"g\", \"N\"],\n        \"range\": [\n          \"#7BD56C\",\n          \"#FF9B9B\",\n          \"#86BBF1\",\n          \"#FFC56C\",\n          \"#7BD56C\",\n          \"#FF9B9B\",\n          \"#86BBF1\",\n          \"#FFC56C\",\n          \"#E0E0E0\"\n        ]\n      }\n    }\n  },\n  \"layer\": [\n    {\n      \"mark\": \"rect\"\n    },\n    {\n      \"mark\": {\n        \"type\": \"text\",\n        \"size\": 13,\n        \"fitToBand\": true,\n        \"paddingX\": 1.5,\n        \"paddingY\": 1,\n        \"opacity\": 0.7,\n        \"flushX\": false,\n        \"tooltip\": null\n      },\n      \"encoding\": {\n        \"color\": { \"value\": \"black\" },\n        \"text\": { \"field\": \"base\" }\n      }\n    }\n  ]\n}\n</code></pre> <p>The data source is based on GMOD's indexedfasta-js library.</p>"},{"location":"grammar/data/lazy/#bigwig","title":"BigWig","text":"<p>The <code>\"bigwig\"</code> source enables the retrieval of dense, continuous data, such as coverage or other signal data stored in BigWig files. It behaves similarly to the indexed FASTA source, loading the data in chunks that cover and flank the currently visible region. However, the window size automatically adapts to the zoom level, and data are fetched in higher resolution when zooming in. The data source provides data objects with the following fields: <code>chrom</code> (string), <code>start</code> (integer), <code>end</code> (integer), and <code>score</code> (number).</p>"},{"location":"grammar/data/lazy/#parameters_1","title":"Parameters","text":"<code>channel</code> Type: <code>\"x\"</code> | <code>\"y\"</code><p>Which channel's scale domain to monitor.</p> <p>Default value: <code>\"x\"</code></p> <code>debounce</code> Type: number | ExprRef<p>Debounce time for data updates, in milliseconds. Debouncing prevents excessive data updates when the user is zooming or panning around.</p> <p>Default value: <code>200</code></p> <code>debounceMode</code> Type: string<p>The debounce mode for data updates. If set to <code>\"domain\"</code>, domain change events (panning and zooming) will be debounced. If set to <code>\"window\"</code>, the data fetches initiated by the changes to the visible window (or tile) will be debounced.  If your data is small, the <code>\"window\"</code> is better as it will start fetching data while the user is still panning around, resulting in a shorter perceived latency.</p> <p>Default value: <code>\"window\"</code></p> <code>pixelsPerBin</code> Type: number | ExprRef<p>The approximate minimum width of each data bin, in pixels.</p> <p>Default value: <code>2</code></p> <code>url</code> Required Type: string | ExprRef<p>URL of the BigWig file.</p>"},{"location":"grammar/data/lazy/#example_1","title":"Example","text":"<p>The example below shows the GC content of the human genome in 5-base windows. When you zoom in, the resolution of the data automatically increases.</p> <pre><code>{\n  \"genome\": { \"name\": \"hg38\" },\n  \"view\": { \"stroke\": \"lightgray\" },\n\n  \"data\": {\n    \"lazy\": {\n      \"type\": \"bigwig\",\n      \"url\": \"https://data.genomespy.app/genomes/hg38/hg38.gc5Base.bw\"\n    }\n  },\n\n  \"encoding\": {\n    \"y\": {\n      \"field\": \"score\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"domain\": [0, 100] },\n      \"axis\": { \"title\": \"GC (%)\", \"grid\": true, \"gridDash\": [2, 2] }\n    },\n    \"x\": { \"chrom\": \"chrom\", \"pos\": \"start\", \"type\": \"locus\" },\n    \"x2\": { \"chrom\": \"chrom\", \"pos\": \"end\" }\n  },\n\n  \"mark\": \"rect\"\n}\n</code></pre> <p>The data source is based on GMOD's bbi-js library.</p>"},{"location":"grammar/data/lazy/#bigbed","title":"BigBed","text":"<p>The <code>\"bigbed\"</code> source enables the retrieval of segmented data, such as annotated genomic regions stored in BigBed files.</p>"},{"location":"grammar/data/lazy/#parameters_2","title":"Parameters","text":"<code>channel</code> Type: <code>\"x\"</code> | <code>\"y\"</code><p>Which channel's scale domain to monitor.</p> <p>Default value: <code>\"x\"</code></p> <code>debounce</code> Type: number | ExprRef<p>Debounce time for data updates, in milliseconds. Debouncing prevents excessive data updates when the user is zooming or panning around.</p> <p>Default value: <code>200</code></p> <code>debounceMode</code> Type: string<p>The debounce mode for data updates. If set to <code>\"domain\"</code>, domain change events (panning and zooming) will be debounced. If set to <code>\"window\"</code>, the data fetches initiated by the changes to the visible window (or tile) will be debounced.  If your data is small, the <code>\"window\"</code> is better as it will start fetching data while the user is still panning around, resulting in a shorter perceived latency.</p> <p>Default value: <code>\"window\"</code></p> <code>url</code> Required Type: string | ExprRef<p>URL of the BigBed file.</p> <code>windowSize</code> Type: number | ExprRef<p>Size of each chunk when fetching the BigBed file. Data is only fetched when the length of the visible domain smaller than the window size.</p> <p>Default value: <code>1000000</code></p>"},{"location":"grammar/data/lazy/#example_2","title":"Example","text":"<p>The example below displays \"ENCODE Candidate Cis-Regulatory Elements (cCREs) combined from all cell types\" dataset for the hg38 genome.</p> <pre><code>{\n  \"genome\": { \"name\": \"hg38\" },\n  \"view\": { \"stroke\": \"lightgray\" },\n\n  \"data\": {\n    \"lazy\": {\n      \"type\": \"bigbed\",\n      \"url\": \"https://data.genomespy.app/sample-data/encodeCcreCombined.hg38.bb\"\n    }\n  },\n\n  \"encoding\": {\n    \"x\": {\n      \"chrom\": \"chrom\",\n      \"pos\": \"chromStart\",\n      \"type\": \"locus\",\n      \"scale\": {\n        \"domain\": [\n          { \"chrom\": \"chr7\", \"pos\": 66600000 },\n          { \"chrom\": \"chr7\", \"pos\": 66800000 }\n        ]\n      }\n    },\n    \"x2\": {\n      \"chrom\": \"chrom\",\n      \"pos\": \"chromEnd\"\n    },\n    \"color\": {\n      \"field\": \"ucscLabel\",\n      \"type\": \"nominal\",\n      \"scale\": {\n        \"domain\": [\"prom\", \"enhP\", \"enhD\", \"K4m3\", \"CTCF\"],\n        \"range\": [\"#FF0000\", \"#FFA700\", \"#FFCD00\", \"#FFAAAA\", \"#00B0F0\"]\n      }\n    }\n  },\n\n  \"mark\": \"rect\"\n}\n</code></pre> <p>The data source is based on GMOD's bbi-js library.</p>"},{"location":"grammar/data/lazy/#vcf","title":"VCF","text":"<p>The tabix-based <code>\"vcf\"</code> source enables the retrieval of variant data stored in VCF files. The object format GenomeSpy uses is described in vcf-js's documentation.</p>"},{"location":"grammar/data/lazy/#parameters_3","title":"Parameters","text":"<code>addChrPrefix</code> Type: boolean | string<p>Add a <code>chr</code> (boolean) or custom (string) prefix to the chromosome names in the Tabix file.</p> <p>Default value: <code>false</code></p> <code>channel</code> Type: <code>\"x\"</code> | <code>\"y\"</code><p>Which channel's scale domain to monitor.</p> <p>Default value: <code>\"x\"</code></p> <code>debounce</code> Type: number | ExprRef<p>Debounce time for data updates, in milliseconds. Debouncing prevents excessive data updates when the user is zooming or panning around.</p> <p>Default value: <code>200</code></p> <code>debounceMode</code> Type: string<p>The debounce mode for data updates. If set to <code>\"domain\"</code>, domain change events (panning and zooming) will be debounced. If set to <code>\"window\"</code>, the data fetches initiated by the changes to the visible window (or tile) will be debounced.  If your data is small, the <code>\"window\"</code> is better as it will start fetching data while the user is still panning around, resulting in a shorter perceived latency.</p> <p>Default value: <code>\"window\"</code></p> <code>indexUrl</code> Type: string<p>Url of the tabix index file.</p> <p>Default value: <code>url</code> + <code>\".tbi\"</code>.</p> <code>url</code> Required Type: string<p>Url of the bgzip compressed file.</p> <code>windowSize</code> Type: number<p>Size of each chunk when fetching the Tabix file. Data is only fetched when the length of the visible domain smaller than the window size.</p> <p>Default value: <code>30000000</code></p>"},{"location":"grammar/data/lazy/#example_3","title":"Example","text":"<p>TODO</p> <p>The data source is vased on GMOD's vcf-js library.</p>"},{"location":"grammar/data/lazy/#gff3","title":"GFF3","text":"<p>The tabix-based <code>\"gff3\"</code> source enables the retrieval of hierarchical data, such as genomic annotations stored in GFF3 files. The object format GenomeSpy uses is described in gff-js's documentation. The flatten and project transforms are useful when extracting the child features and attributes from the hierarchical data structure. See the example below.</p>"},{"location":"grammar/data/lazy/#parameters_4","title":"Parameters","text":"<code>addChrPrefix</code> Type: boolean | string<p>Add a <code>chr</code> (boolean) or custom (string) prefix to the chromosome names in the Tabix file.</p> <p>Default value: <code>false</code></p> <code>channel</code> Type: <code>\"x\"</code> | <code>\"y\"</code><p>Which channel's scale domain to monitor.</p> <p>Default value: <code>\"x\"</code></p> <code>debounce</code> Type: number | ExprRef<p>Debounce time for data updates, in milliseconds. Debouncing prevents excessive data updates when the user is zooming or panning around.</p> <p>Default value: <code>200</code></p> <code>debounceMode</code> Type: string<p>The debounce mode for data updates. If set to <code>\"domain\"</code>, domain change events (panning and zooming) will be debounced. If set to <code>\"window\"</code>, the data fetches initiated by the changes to the visible window (or tile) will be debounced.  If your data is small, the <code>\"window\"</code> is better as it will start fetching data while the user is still panning around, resulting in a shorter perceived latency.</p> <p>Default value: <code>\"window\"</code></p> <code>indexUrl</code> Type: string<p>Url of the tabix index file.</p> <p>Default value: <code>url</code> + <code>\".tbi\"</code>.</p> <code>url</code> Required Type: string<p>Url of the bgzip compressed file.</p> <code>windowSize</code> Type: number<p>Size of each chunk when fetching the Tabix file. Data is only fetched when the length of the visible domain smaller than the window size.</p> <p>Default value: <code>30000000</code></p>"},{"location":"grammar/data/lazy/#example_4","title":"Example","text":"<p>The example below displays the human (GRCh38.p13) GENCODE v43 annotation dataset. Please note that the example shows a maximum of ten overlapping features per locus as vertical scrolling is currently not supported properly.</p> <pre><code>{\n  \"$schema\": \"https://unpkg.com/@genome-spy/core/dist/schema.json\",\n\n  \"genome\": { \"name\": \"hg38\" },\n\n  \"height\": { \"step\": 28 },\n  \"viewportHeight\": \"container\",\n\n  \"view\": { \"stroke\": \"lightgray\" },\n\n  \"data\": {\n    \"lazy\": {\n      \"type\": \"gff3\",\n      \"url\": \"https://data.genomespy.app/sample-data/gencode.v43.annotation.sorted.gff3.gz\",\n      \"windowSize\": 2000000,\n      \"debounceDomainChange\": 300\n    }\n  },\n\n  \"transform\": [\n    {\n      \"type\": \"flatten\"\n    },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"datum.attributes.gene_name\",\n      \"as\": \"gene_name\"\n    },\n    {\n      \"type\": \"flatten\",\n      \"fields\": [\"child_features\"]\n    },\n    {\n      \"type\": \"flatten\",\n      \"fields\": [\"child_features\"],\n      \"as\": [\"child_feature\"]\n    },\n    {\n      \"type\": \"project\",\n      \"fields\": [\n        \"gene_name\",\n        \"child_feature.type\",\n        \"child_feature.strand\",\n        \"child_feature.seq_id\",\n        \"child_feature.start\",\n        \"child_feature.end\",\n        \"child_feature.attributes.gene_type\",\n        \"child_feature.attributes.transcript_type\",\n        \"child_feature.attributes.gene_id\",\n        \"child_feature.attributes.transcript_id\",\n        \"child_feature.attributes.transcript_name\",\n        \"child_feature.attributes.tag\",\n        \"source\",\n        \"child_feature.child_features\"\n      ],\n      \"as\": [\n        \"gene_name\",\n        \"type\",\n        \"strand\",\n        \"seq_id\",\n        \"start\",\n        \"end\",\n        \"gene_type\",\n        \"transcript_type\",\n        \"gene_id\",\n        \"transcript_id\",\n        \"transcript_name\",\n        \"tag\",\n        \"source\",\n        \"_child_features\"\n      ]\n    },\n    {\n      \"type\": \"collect\",\n      \"sort\": {\n        \"field\": [\"seq_id\", \"start\", \"transcript_id\"]\n      }\n    },\n    {\n      \"type\": \"pileup\",\n      \"start\": \"start\",\n      \"end\": \"end\",\n      \"as\": \"_lane\"\n    }\n  ],\n\n  \"encoding\": {\n    \"x\": {\n      \"chrom\": \"seq_id\",\n      \"pos\": \"start\",\n      \"offset\": 1,\n      \"type\": \"locus\",\n      \"scale\": {\n        \"domain\": [\n          { \"chrom\": \"chr5\", \"pos\": 177482500 },\n          { \"chrom\": \"chr5\", \"pos\": 177518000 }\n        ]\n      }\n    },\n    \"x2\": {\n      \"chrom\": \"seq_id\",\n      \"pos\": \"end\"\n    },\n    \"y\": {\n      \"field\": \"_lane\",\n      \"type\": \"index\",\n      \"scale\": {\n        \"zoom\": false,\n        \"reverse\": true,\n        \"domain\": [0, 40],\n        \"padding\": 0.5\n      },\n      \"axis\": null\n    }\n  },\n\n  \"layer\": [\n    {\n      \"name\": \"gencode-transcript\",\n\n      \"layer\": [\n        {\n          \"name\": \"gencode-tooltip-trap\",\n          \"title\": \"GENCODE transcript\",\n          \"mark\": {\n            \"type\": \"rule\",\n            \"color\": \"#b0b0b0\",\n            \"opacity\": 0,\n            \"size\": 7\n          }\n        },\n        {\n          \"name\": \"gencode-transcript-body\",\n          \"mark\": {\n            \"type\": \"rule\",\n            \"color\": \"#b0b0b0\",\n            \"tooltip\": null\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"gencode-exons\",\n\n      \"transform\": [\n        {\n          \"type\": \"flatten\",\n          \"fields\": [\"_child_features\"]\n        },\n        {\n          \"type\": \"flatten\",\n          \"fields\": [\"_child_features\"],\n          \"as\": [\"child_feature\"]\n        },\n        {\n          \"type\": \"project\",\n          \"fields\": [\n            \"gene_name\",\n            \"_lane\",\n            \"child_feature.type\",\n            \"child_feature.seq_id\",\n            \"child_feature.start\",\n            \"child_feature.end\",\n            \"child_feature.attributes.exon_number\",\n            \"child_feature.attributes.exon_id\"\n          ],\n          \"as\": [\n            \"gene_name\",\n            \"_lane\",\n            \"type\",\n            \"seq_id\",\n            \"start\",\n            \"end\",\n            \"exon_number\",\n            \"exon_id\"\n          ]\n        }\n      ],\n\n      \"layer\": [\n        {\n          \"title\": \"GENCODE exon\",\n\n          \"transform\": [{ \"type\": \"filter\", \"expr\": \"datum.type == 'exon'\" }],\n\n          \"mark\": {\n            \"type\": \"rect\",\n            \"minWidth\": 0.5,\n            \"minOpacity\": 0.5,\n            \"stroke\": \"#505050\",\n            \"fill\": \"#fafafa\",\n            \"strokeWidth\": 1.0\n          }\n        },\n        {\n          \"title\": \"GENCODE exon\",\n\n          \"transform\": [\n            {\n              \"type\": \"filter\",\n              \"expr\": \"datum.type != 'exon' &amp;&amp; datum.type != 'start_codon' &amp;&amp; datum.type != 'stop_codon'\"\n            }\n          ],\n\n          \"mark\": {\n            \"type\": \"rect\",\n            \"minWidth\": 0.5,\n            \"minOpacity\": 0,\n            \"strokeWidth\": 1.0,\n            \"strokeOpacity\": 0.0,\n            \"stroke\": \"gray\"\n          },\n          \"encoding\": {\n            \"fill\": {\n              \"field\": \"type\",\n              \"type\": \"nominal\",\n              \"scale\": {\n                \"domain\": [\"five_prime_UTR\", \"CDS\", \"three_prime_UTR\"],\n                \"range\": [\"#83bcb6\", \"#ffbf79\", \"#d6a5c9\"]\n              }\n            }\n          }\n        },\n        {\n          \"transform\": [\n            {\n              \"type\": \"filter\",\n              \"expr\": \"datum.type == 'three_prime_UTR' || datum.type == 'five_prime_UTR'\"\n            },\n            {\n              \"type\": \"formula\",\n              \"expr\": \"datum.type == 'three_prime_UTR' ? \\\"3'\\\" : \\\"5'\\\"\",\n              \"as\": \"label\"\n            }\n          ],\n\n          \"mark\": {\n            \"type\": \"text\",\n            \"color\": \"black\",\n            \"size\": 11,\n            \"opacity\": 0.7,\n            \"paddingX\": 2,\n            \"paddingY\": 1.5,\n            \"tooltip\": null\n          },\n\n          \"encoding\": {\n            \"text\": {\n              \"field\": \"label\"\n            }\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"gencode-transcript-labels\",\n\n      \"transform\": [\n        {\n          \"type\": \"formula\",\n          \"expr\": \"(datum.strand == '-' ? '&lt; ' : '') + datum.transcript_name + ' - ' + datum.transcript_id + (datum.strand == '+' ? ' &gt;' : '')\",\n          \"as\": \"label\"\n        }\n      ],\n\n      \"mark\": {\n        \"type\": \"text\",\n        \"size\": 10,\n        \"yOffset\": 12,\n        \"tooltip\": null,\n        \"color\": \"#505050\"\n      },\n\n      \"encoding\": {\n        \"text\": {\n          \"field\": \"label\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>The data source is based on GMOD's tabix-js and gff-js libraries.</p>"},{"location":"grammar/data/lazy/#bam","title":"BAM","text":"<p>The <code>\"bam\"</code> source is very much work in progress but has a low priority. It currently exposes the reads but provides no handling for variants alleles, CIGARs, etc. Please send a message to GitHub Discussions if you are interested in this feature.</p>"},{"location":"grammar/data/lazy/#parameters_5","title":"Parameters","text":"<code>channel</code> Type: <code>\"x\"</code> | <code>\"y\"</code><p>Which channel's scale domain to monitor.</p> <p>Default value: <code>\"x\"</code></p> <code>debounce</code> Type: number | ExprRef<p>Debounce time for data updates, in milliseconds. Debouncing prevents excessive data updates when the user is zooming or panning around.</p> <p>Default value: <code>200</code></p> <code>debounceMode</code> Type: string<p>The debounce mode for data updates. If set to <code>\"domain\"</code>, domain change events (panning and zooming) will be debounced. If set to <code>\"window\"</code>, the data fetches initiated by the changes to the visible window (or tile) will be debounced.  If your data is small, the <code>\"window\"</code> is better as it will start fetching data while the user is still panning around, resulting in a shorter perceived latency.</p> <p>Default value: <code>\"window\"</code></p> <code>indexUrl</code> Type: string<p>URL of the index file.</p> <p>Default value: <code>url</code> + <code>\".bai\"</code>.</p> <code>url</code> Required Type: string<p>URL of the BigBed file.</p> <code>windowSize</code> Type: number<p>Size of each chunk when fetching the BigBed file. Data is only fetched when the length of the visible domain smaller than the window size.</p> <p>Default value: <code>10000</code></p>"},{"location":"grammar/data/lazy/#example_5","title":"Example","text":"<pre><code>{\n  \"genome\": { \"name\": \"hg18\" },\n\n  \"data\": {\n    \"lazy\": {\n      \"type\": \"bam\",\n      \"url\": \"https://data.genomespy.app/sample-data/bamExample.bam\",\n      \"windowSize\": 30000\n    }\n  },\n\n  \"resolve\": { \"scale\": { \"x\": \"shared\" } },\n\n  \"spacing\": 5,\n\n  \"vconcat\": [\n    {\n      \"view\": { \"stroke\": \"lightgray\" },\n      \"height\": 40,\n\n      \"transform\": [\n        {\n          \"type\": \"coverage\",\n          \"start\": \"start\",\n          \"end\": \"end\",\n          \"as\": \"coverage\",\n          \"chrom\": \"chrom\"\n        }\n      ],\n      \"mark\": \"rect\",\n      \"encoding\": {\n        \"x\": {\n          \"chrom\": \"chrom\",\n          \"pos\": \"start\",\n          \"type\": \"locus\",\n          \"axis\": null\n        },\n        \"x2\": { \"chrom\": \"chrom\", \"pos\": \"end\" },\n        \"y\": { \"field\": \"coverage\", \"type\": \"quantitative\" }\n      }\n    },\n    {\n      \"view\": { \"stroke\": \"lightgray\" },\n\n      \"transform\": [\n        {\n          \"type\": \"pileup\",\n          \"start\": \"start\",\n          \"end\": \"end\",\n          \"as\": \"_lane\"\n        }\n      ],\n\n      \"encoding\": {\n        \"x\": {\n          \"chrom\": \"chrom\",\n          \"pos\": \"start\",\n          \"type\": \"locus\",\n          \"axis\": {},\n          \"scale\": {\n            \"domain\": [\n              { \"chrom\": \"chr21\", \"pos\": 33037317 },\n              { \"chrom\": \"chr21\", \"pos\": 33039137 }\n            ]\n          }\n        },\n        \"x2\": {\n          \"chrom\": \"chrom\",\n          \"pos\": \"end\"\n        },\n        \"y\": {\n          \"field\": \"_lane\",\n          \"type\": \"index\",\n          \"scale\": {\n            \"domain\": [0, 60],\n            \"padding\": 0.3,\n            \"reverse\": true,\n            \"zoom\": false\n          }\n        },\n        \"color\": {\n          \"field\": \"strand\",\n          \"type\": \"nominal\",\n          \"scale\": {\n            \"domain\": [\"+\", \"-\"],\n            \"range\": [\"crimson\", \"orange\"]\n          }\n        }\n      },\n\n      \"mark\": \"rect\"\n    }\n  ]\n}\n</code></pre> <p>The data source is based on GMOD's bam-js library.</p>"},{"location":"grammar/data/lazy/#axis-ticks","title":"Axis ticks","text":"<p>The <code>\"axisTicks\"</code> data source generates a set of ticks for the specified channel. While GenomeSpy internally uses this data source for generating axis ticks, you also have the flexibility to employ it for creating fully customized axes according to your requirements. The data source generates data objects with <code>value</code> and <code>label</code> fields.</p>"},{"location":"grammar/data/lazy/#parameters_6","title":"Parameters","text":"<code>axis</code> Type: Axis<p>Optional axis properties</p> <code>channel</code> Required Type: <code>\"x\"</code> | <code>\"y\"</code><p>Which channel's scale domain to listen to</p>"},{"location":"grammar/data/lazy/#example_6","title":"Example","text":"<p>The example below generates approximately three ticks for the <code>x</code> axis.</p> <pre><code>{\n  \"data\": {\n    \"lazy\": {\n      \"type\": \"axisTicks\",\n      \"channel\": \"x\",\n      \"axis\": {\n        \"tickCount\": 3\n      }\n    }\n  },\n\n  \"mark\": {\n    \"type\": \"text\",\n    \"size\": 20,\n    \"clip\": false\n  },\n\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"value\",\n      \"type\": \"quantitative\",\n      \"scale\": {\n        \"domain\": [0, 10],\n        \"zoom\": true\n      }\n    },\n    \"text\": {\n      \"field\": \"label\"\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/data/lazy/#axis-genome","title":"Axis genome","text":"<p>The <code>axisGenome</code> data source, in fact, does not dynamically update data. However, it provides a convenient access to the genome (chromosomes) of the given channel, allowing creation of customized chromosome ticks or annotations. The data source generates data objects with the following fields: <code>name</code>, <code>size</code> (in bp), <code>continuousStart</code> (linearized coordinate), <code>continuousEnd</code>, <code>odd</code> (boolean), and <code>number</code> (1-based index).</p>"},{"location":"grammar/data/lazy/#parameters_7","title":"Parameters","text":"<code>channel</code> Required Type: <code>\"x\"</code> | <code>\"y\"</code><p>Which channel's scale domain to use</p>"},{"location":"grammar/data/lazy/#example_7","title":"Example","text":"<pre><code>{\n  \"genome\": { \"name\": \"hg38\" },\n\n  \"data\": {\n    \"lazy\": {\n      \"type\": \"axisGenome\",\n      \"channel\": \"x\"\n    }\n  },\n\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"continuousStart\",\n      \"type\": \"locus\"\n    },\n    \"x2\": {\n      \"field\": \"continuousEnd\"\n    },\n    \"text\": {\n      \"field\": \"name\"\n    }\n  },\n\n  \"layer\": [\n    {\n      \"transform\": [\n        {\n          \"type\": \"filter\",\n          \"expr\": \"datum.odd\"\n        }\n      ],\n      \"mark\": {\n        \"type\": \"rect\",\n        \"fill\": \"#f0f0f0\"\n      }\n    },\n    {\n      \"mark\": {\n        \"type\": \"text\",\n        \"size\": 16,\n        \"angle\": -90,\n        \"align\": \"right\",\n        \"baseline\": \"top\",\n        \"paddingX\": 3,\n        \"paddingY\": 5,\n        \"y\": 1\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/mark/","title":"Marks","text":"<p>In GenomeSpy, visualizations are built from marks, which are geometric shapes, such as points, rectangles, and lines, that represent data objects (or rows in tabular data). These marks are mapped to the data using the <code>encoding</code> property, which specifies which visual channels, such as <code>x</code>, <code>color</code>, and <code>size</code>, should be used to encode the data fields. By adjusting the encodings, you can present the same data in a wide range of visual forms, such as scatterplots, bar charts, and heatmaps.</p> Example: Specifying the mark type<pre><code>{\n  ...,\n  \"mark\": \"rect\"\n  ...,\n}\n</code></pre>"},{"location":"grammar/mark/#properties","title":"Properties","text":"<p>Marks also support various properties for controlling their appearance or behavior. The properties can be specified with an object that contains at least the <code>type</code> property:</p> Example: Specifying the mark type and additional properties<pre><code>{\n  ...,\n  \"mark\": {\n    \"type\": \"rect\",\n    \"cornerRadius\": 5\n  },\n  ...,\n}\n</code></pre>"},{"location":"grammar/mark/#encoding","title":"Encoding","text":"<p>While mark properties are static, i.e., same for all mark instances, <code>encoding</code> allows for mapping data to visual channels and using data-driven visual encoding.</p> <p>It's worth noting that while all visual encoding channels are also available as static properties, not all properties can be used for encoding. Only certain properties are suitable for encoding data in a meaningful way.</p> Example: Specifying visual channels with the encoding property<pre><code>{\n  ...,\n  \"mark\": \"rect\",\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"from\", \"type\": \"index\"\n    },\n    \"x2\": {\n      \"field\": \"to\"\n    },\n    \"color\": {\n      \"field\": \"category\", \"type\": \"nominal\"\n    }\n  },\n  ...\n}\n</code></pre> <p>The schematic example above uses the <code>\"rect\"</code> mark to represent the data objects. The <code>\"from\"</code> field is mapped to the positional <code>\"x\"</code> channel, and so on. You can adjust the mapping by specifying a scale for the channel.</p>"},{"location":"grammar/mark/#channels","title":"Channels","text":""},{"location":"grammar/mark/#position-channels","title":"Position channels","text":"<p>All marks support the two position channels, which define the mark instance's placement in the visualization. If a positional channel is left unspecified, the mark instance is placed at the center of the respective axis.</p>"},{"location":"grammar/mark/#primary-channels","title":"Primary channels","text":"<code>x</code> The position on the x axis <code>y</code> The position on the y axis"},{"location":"grammar/mark/#secondary-channels","title":"Secondary channels","text":"<p>Some marks, such as <code>\"rect\"</code> and <code>\"rule\"</code>, also support secondary positional channels, which allow specifying an interval that the mark should cover in the visualization.</p> <code>x2</code> The secondary position on the x axis <code>y2</code> The secondary position on the y axis"},{"location":"grammar/mark/#other-channels","title":"Other channels","text":"<code>color</code> Color of the mark. Affects <code>fill</code> or <code>stroke</code>, depending on the <code>filled</code> property. <code>fill</code> Fill color <code>stroke</code> Stroke color <code>opacity</code> Opacity of the mark. Affects <code>fillOpacity</code> or <code>strokeOpacity</code>, depending on the <code>filled</code> property. <code>fillOpacity</code> Fill opacity <code>strokeOpacity</code> Stroke opacity <code>strokeWidth</code> Stroke width in pixels <code>size</code> Depends on the mark. <code>\"point\"</code>: the area of the rectangle that encloses the mark instance. <code>\"rule\"</code> and <code>\"link\"</code>: stroke width. <code>\"text\"</code>: font size. <code>shape</code> Shape of <code>\"point\"</code> marks. <code>angle</code> Rotational angle of <code>\"point\"</code> and <code>\"text\"</code> marks. <code>text</code> Text that the <code>\"text\"</code> mark should render for a mark instance."},{"location":"grammar/mark/#non-visual-channels","title":"Non-visual channels","text":"<p>Some channels carry metadata for interaction features and are not encoded into visual mark properties.</p> <code>key</code> Defines a stable identity for data objects. This is used by point-selection persistence in the GenomeSpy App. The key can be a single field definition or an array of field definitions for a composite key. For composite keys, the field order is significant."},{"location":"grammar/mark/#channels-for-sample-collections","title":"Channels for sample collections","text":"<p>The GenomeSpy app supports an additional channel.</p> <code>sample</code> Defines the track (or facet) for the sample"},{"location":"grammar/mark/#visual-encoding","title":"Visual Encoding","text":"<p>GenomeSpy provides several methods for controlling how data is mapped to visual channels. The most common method is to map a field of the data to a channel, but you can also use expressions, values, or data values belonging to the data domain.</p> <p>Expect for the <code>value</code> method, all methods require specifying the data type using the <code>type</code> property, which must be one of: <code>\"quantitative\"</code>, <code>\"nominal\"</code>, or <code>\"ordinal\"</code>, <code>\"index\"</code>, or <code>\"locus\"</code>. The first three types are equivalent to the Vega-Lite types of the same name.</p>"},{"location":"grammar/mark/#field","title":"Field","text":"<p><code>field</code> maps a field (or column) of the data to a visual channel.</p> <pre><code>{\n  \"encoding\": {\n    \"color\": { \"field\": \"significance\", \"type\": \"ordinal\" }\n  },\n  ...\n}\n</code></pre>"},{"location":"grammar/mark/#expression","title":"Expression","text":"<p><code>expr</code> applies an expression before passing the value for a scale transformation.</p> <pre><code>{\n  \"encoding\": {\n    \"color\": { \"expr\": \"datum.score &gt; 10\", \"type\": \"nominal\" }\n  },\n  ...\n}\n</code></pre>"},{"location":"grammar/mark/#value","title":"Value","text":"<p><code>value</code> defines a value on channel's range, skipping the scale transformation.</p> <pre><code>{\n  \"encoding\": {\n    \"color\": { \"value\": \"red\" }\n  },\n  ...\n}\n</code></pre>"},{"location":"grammar/mark/#datum","title":"Datum","text":"<p><code>datum</code> defines a value on the domain of the scale used on the channel. Thus, the scale transformation will be applied.</p> <pre><code>{\n  \"encoding\": {\n    \"color\": { \"datum\": \"important\", \"type\": \"ordinal\" }\n  },\n  ...\n}\n</code></pre>"},{"location":"grammar/mark/#chrom-and-pos","title":"Chrom and Pos","text":"<p>See Working with Genomic Data.</p>"},{"location":"grammar/mark/link/","title":"Link","text":"<p>The <code>\"link\"</code> mark displays each data item as a curve that connects two points. The mark can be used to display structural variation and interactions, for example. The mark has several different <code>linkShape</code>s that control how the curve is drawn.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 30, \"as\": \"z\" }\n  },\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"round(random() * 800)\", \"as\": \"x\" },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"round(datum.x + pow(2, random() * 10))\",\n      \"as\": \"x2\"\n    }\n  ],\n  \"mark\": \"link\",\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"index\" },\n    \"x2\": { \"field\": \"x2\" }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/link/#channels","title":"Channels","text":"<p>In addition to the primary and secondary position channels and the <code>color</code> and <code>opacity</code> channels, link mark supports the following channels: <code>size</code>.</p>"},{"location":"grammar/mark/link/#properties","title":"Properties","text":"<code>arcFadingDistance</code> Type: [number, number] | boolean | ExprRef<p>The range of the <code>\"arc\"</code> shape's fading distance in pixels. This property allows for making the arc's opacity fade out as it extends away from the chord. The fading distance is interpolated from one to zero between the interval defined by this property. Both <code>false</code> and <code>[0, 0]</code> disable fading.</p> <p>Default value: <code>false</code></p> <code>arcHeightFactor</code> Type: number | ExprRef<p>Scaling factor for the <code>\"arc</code>\" shape's height. The default value <code>1.0</code> produces roughly circular arcs.</p> <p>Default value: <code>1.0</code></p> <code>clampApex</code> Type: boolean | ExprRef<p>Whether the apex of the <code>\"dome\"</code> shape is clamped to the viewport edge. When over a half of the dome is located outside the viewport, clamping allows for more accurate reading of the value encoded by the apex' position.</p> <p>Default value: <code>false</code></p> <code>clip</code> Type: boolean | <code>\"never\"</code><p>If true, the mark is clipped to the UnitView's rectangle. By default, clipping is enabled for marks that have zoomable positional scales.</p> <code>color</code> Type: string | ExprRef<p>Color of the mark. Affects either <code>fill</code> or <code>stroke</code>, depending on the <code>filled</code> property.</p> <code>linkShape</code> Type: <code>\"arc\"</code> | <code>\"diagonal\"</code> | <code>\"line\"</code> | <code>\"dome\"</code> | ExprRef<p>The shape of the link path.</p> <p>The <code>\"arc\"</code> shape draws a circular arc between the two points. The apex of the arc resides on the left side of the line that connects the two points. The <code>\"dome\"</code> shape draws a vertical or horizontal arc with a specific height. The primary positional channel determines the apex of the arc and the secondary determines the endpoint placement. The <code>\"diagonal\"</code> shape draws an \"S\"-shaped curve between the two points. The <code>\"line\"</code> shape draws a straight line between the two points. See an example of the different shapes below.</p> <p>Default value: <code>\"arc\"</code></p> <code>maxChordLength</code> Type: number | ExprRef<p>The maximum length of <code>\"arc\"</code> shape's chord in pixels. The chord is the line segment between the two points that define the arc. Limiting the chord length serves two purposes when zooming in close enough: 1) it prevents the arc from becoming a straight line and 2) it mitigates the limited precision of floating point numbers in arc rendering.</p> <p>Default value: <code>50000</code></p> <code>minArcHeight</code> Type: number | ExprRef<p>The minimum height of an <code>\"arc\"</code> shape. Makes very short links more clearly visible.</p> <p>Default value: <code>1.5</code></p> <code>minBufferSize</code> Type: number<p>Minimum size for WebGL buffers (number of data items). Allows for using <code>bufferSubData()</code> to update graphics.</p> <p>This property is intended for internal use.</p> <code>minPickingSize</code> Type: number | ExprRef<p>The minimum picking size invisibly increases the stroke width or point diameter of marks when pointing them with the mouse cursor, making it easier to select them. The valus is the minimum size in pixels.</p> <p>Default value: <code>3.0</code> for <code>\"link\"</code> and <code>2.0</code> for <code>\"point\"</code></p> <code>noFadingOnPointSelection</code> Type: boolean | ExprRef<p>Disables fading of the link when an mark instance is subject to any point selection. As the fading distance is unavailable as a visual channel, this property allows for enhancing the visibility of the selected links.</p> <p>Default value: <code>true</code></p> <code>opacity</code> Type: number | ExprRef<p>Opacity of the mark. Affects <code>fillOpacity</code> or <code>strokeOpacity</code>, depending on the <code>filled</code> property.</p> <code>orient</code> Type: <code>\"vertical\"</code> | <code>\"horizontal\"</code> | ExprRef<p>The orientation of the link path. Either <code>\"vertical\"</code> or <code>\"horizontal\"</code>. Only applies to diagonal links.</p> <p>Default value: <code>\"vertical\"</code></p> <code>segments</code> Type: number | ExprRef<p>The number of segments in the b\u00e9zier curve. Affects the rendering quality and performance. Use a higher value for a smoother curve.</p> <p>Default value: <code>101</code></p> <code>size</code> Type: number | ExprRef<p>Stroke width of <code>\"link\"</code> and <code>\"rule\"</code> marks in pixels, the area of the bounding square of <code>\"point\"</code> mark, or the font size of <code>\"text\"</code> mark.</p> <code>tooltip</code> Type: HandledTooltip | null<p>Tooltip handler. If <code>null</code>, no tooltip is shown. If string, specifies the tooltip handler to use.</p> <code>x</code> Type: number | ExprRef<p>Position on the x axis.</p> <code>x2</code> Type: number | ExprRef<p>The secondary position on the x axis.</p> <code>xOffset</code> Type: number<p>Offsets of the <code>x</code> and <code>x2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p> <code>y</code> Type: number | ExprRef<p>Position on the y axis.</p> <code>y2</code> Type: number | ExprRef<p>The secondary position on the y axis.</p> <code>yOffset</code> Type: number<p>Offsets of the <code>y</code> and <code>y2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p>"},{"location":"grammar/mark/link/#examples","title":"Examples","text":""},{"location":"grammar/mark/link/#different-link-shapes-and-orientations","title":"Different link shapes and orientations","text":"<p>This example shows the different link shapes and orientations. All links have the same coordinates: <code>{ x: 2, y: 2, x2: 8, y2: 8 }</code>. The links are arranged in grid with</p> <p><code>linkShape</code> as columns: <code>\"arc\"</code>, <code>\"dome\"</code>, <code>\"diagonal\"</code>, <code>\"line\"</code>. <code>orient</code> as rows: <code>\"vertical\"</code>, <code>\"horizontal\"</code>.</p> <pre><code>{\n  \"data\": { \"values\": [{ \"x\": 2, \"x2\": 8 }] },\n  \"resolve\": {\n    \"scale\": { \"x\": \"shared\", \"y\": \"shared\" },\n    \"axis\": { \"x\": \"shared\", \"y\": \"shared\" }\n  },\n\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"x\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"domain\": [0, 10] },\n      \"axis\": { \"grid\": true }\n    },\n    \"x2\": { \"field\": \"x2\" },\n    \"y\": {\n      \"field\": \"x\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"domain\": [0, 10] },\n      \"axis\": { \"grid\": true }\n    },\n    \"y2\": { \"field\": \"x2\" },\n    \"size\": { \"value\": 2 }\n  },\n\n  \"columns\": 4,\n  \"spacing\": 20,\n\n  \"concat\": [\n    { \"mark\": { \"type\": \"link\", \"linkShape\": \"arc\", \"orient\": \"vertical\" } },\n    { \"mark\": { \"type\": \"link\", \"linkShape\": \"dome\", \"orient\": \"vertical\" } },\n    {\n      \"mark\": { \"type\": \"link\", \"linkShape\": \"diagonal\", \"orient\": \"vertical\" }\n    },\n    { \"mark\": { \"type\": \"link\", \"linkShape\": \"line\", \"orient\": \"vertical\" } },\n    { \"mark\": { \"type\": \"link\", \"linkShape\": \"arc\", \"orient\": \"horizontal\" } },\n    { \"mark\": { \"type\": \"link\", \"linkShape\": \"dome\", \"orient\": \"horizontal\" } },\n    {\n      \"mark\": {\n        \"type\": \"link\",\n        \"linkShape\": \"diagonal\",\n        \"orient\": \"horizontal\"\n      }\n    },\n    { \"mark\": { \"type\": \"link\", \"linkShape\": \"line\", \"orient\": \"horizontal\" } }\n  ]\n}\n</code></pre>"},{"location":"grammar/mark/link/#varying-the-dome-height","title":"Varying the dome height","text":"<p>This example uses the <code>\"dome\"</code> shape to draw links with varying heights. The height is determined by the <code>y</code> channel. The <code>clampApex</code> property is set to <code>true</code> to ensure that the apex of the dome is always visible. Try to zoom in and pan around to see it in action.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 20, \"as\": \"z\" }\n  },\n\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"round(random() * 1000)\", \"as\": \"x\" },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"round(datum.x + random() * 500)\",\n      \"as\": \"x2\"\n    },\n    { \"type\": \"formula\", \"expr\": \"random() * 1000 - 500\", \"as\": \"y\" }\n  ],\n\n  \"mark\": {\n    \"type\": \"link\",\n    \"linkShape\": \"dome\",\n    \"orient\": \"vertical\",\n    \"clampApex\": true,\n    \"color\": \"gray\"\n  },\n\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"index\" },\n    \"x2\": { \"field\": \"x2\" },\n    \"y\": {\n      \"field\": \"y\",\n      \"type\": \"quantitative\",\n      \"axis\": { \"grid\": true }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/point/","title":"Point","text":"<p>Point mark displays each data item as a symbol. Points are often used to create a scatter plot. In the genomic context, they could represent, for example, point mutations at genomic loci.</p> <pre><code>{\n  \"data\": { \"url\": \"sincos.csv\" },\n  \"mark\": \"point\",\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n    \"y\": { \"field\": \"sin\", \"type\": \"quantitative\" },\n    \"size\": { \"field\": \"x\", \"type\": \"quantitative\" }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/point/#channels","title":"Channels","text":"<p>In addition to standard position channels and <code>color</code>, <code>opacity</code>, and <code>strokeWidth</code> channels, point mark has the following channels: <code>size</code>, <code>shape</code>, <code>dx</code>, and <code>dy</code>.</p>"},{"location":"grammar/mark/point/#properties","title":"Properties","text":"<code>angle</code> Type: number | ExprRef<p>The rotation angle in degrees.</p> <p>Default value: <code>0</code></p> <code>clip</code> Type: boolean | <code>\"never\"</code><p>If true, the mark is clipped to the UnitView's rectangle. By default, clipping is enabled for marks that have zoomable positional scales.</p> <code>color</code> Type: string | ExprRef<p>Color of the mark. Affects either <code>fill</code> or <code>stroke</code>, depending on the <code>filled</code> property.</p> <code>fill</code> Type: string | ExprRef<p>The fill color.</p> <code>fillGradientStrength</code> Type: number | ExprRef<p>Gradient strength controls the amount of the gradient eye-candy effect in the fill color. Valid values are between <code>0</code> and <code>1</code>.</p> <p>Default value: <code>0</code></p> <code>fillOpacity</code> Type: number | ExprRef<p>The fill opacity. Value between <code>0</code> and <code>1</code>.</p> <code>filled</code> Type: boolean<p>Whether the <code>color</code> represents the <code>fill</code> color (<code>true</code>) or the <code>stroke</code> color (<code>false</code>).</p> <code>geometricZoomBound</code> Type: number<p>Enables geometric zooming. The value is the base two logarithmic zoom level where the maximum point size is reached.</p> <p>Default value: <code>0</code></p> <code>inwardStroke</code> Type: boolean | ExprRef<p>Should the stroke only grow inwards, e.g, the diameter/outline is not affected by the stroke width. Thus, a point that has a zero size has no visible stroke. This allows strokes to be used with geometric zoom, etc.</p> <p>Default value: <code>false</code></p> <code>minBufferSize</code> Type: number<p>Minimum size for WebGL buffers (number of data items). Allows for using <code>bufferSubData()</code> to update graphics.</p> <p>This property is intended for internal use.</p> <code>minPickingSize</code> Type: number | ExprRef<p>The minimum picking size invisibly increases the stroke width or point diameter of marks when pointing them with the mouse cursor, making it easier to select them. The valus is the minimum size in pixels.</p> <p>Default value: <code>3.0</code> for <code>\"link\"</code> and <code>2.0</code> for <code>\"point\"</code></p> <code>opacity</code> Type: number | ExprRef<p>Opacity of the mark. Affects <code>fillOpacity</code> or <code>strokeOpacity</code>, depending on the <code>filled</code> property.</p> <code>semanticZoomFraction</code> Type: number | ExprRef<p>TODO</p> <p>Default value: <code>0.02</code></p> <code>shape</code> Type: string | ExprRef<p>One of <code>\"circle\"</code>, <code>\"square\"</code>, <code>\"cross\"</code>, <code>\"diamond\"</code>, <code>\"triangle-up\"</code>, <code>\"triangle-down\"</code>, <code>\"triangle-right\"</code>, <code>\"triangle-left\"</code>, <code>\"tick-up\"</code>, <code>\"tick-down\"</code>, <code>\"tick-right\"</code>, or <code>\"tick-left\"</code></p> <p>Default value: <code>\"circle\"</code></p> <code>size</code> Type: number | ExprRef<p>Stroke width of <code>\"link\"</code> and <code>\"rule\"</code> marks in pixels, the area of the bounding square of <code>\"point\"</code> mark, or the font size of <code>\"text\"</code> mark.</p> <code>stroke</code> Type: string | ExprRef<p>The stroke color</p> <code>strokeOpacity</code> Type: number | ExprRef<p>The stroke opacity. Value between <code>0</code> and <code>1</code>.</p> <code>strokeWidth</code> Type: number | ExprRef<p>The stroke width in pixels.</p> <code>tooltip</code> Type: HandledTooltip | null<p>Tooltip handler. If <code>null</code>, no tooltip is shown. If string, specifies the tooltip handler to use.</p> <code>x</code> Type: number | ExprRef<p>Position on the x axis.</p> <code>xOffset</code> Type: number<p>Offsets of the <code>x</code> and <code>x2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p> <code>y</code> Type: number | ExprRef<p>Position on the y axis.</p> <code>yOffset</code> Type: number<p>Offsets of the <code>y</code> and <code>y2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p>"},{"location":"grammar/mark/point/#examples","title":"Examples","text":""},{"location":"grammar/mark/point/#plenty-of-points","title":"Plenty of points","text":"<p>The example below demonstrates how points can be varied by using <code>shape</code>, <code>fill</code>, <code>size</code>, <code>strokeWidth</code>, and <code>angle</code> channels.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 160, \"as\": \"z\" }\n  },\n\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"datum.z % 20\", \"as\": \"x\" },\n    { \"type\": \"formula\", \"expr\": \"floor(datum.z / 20)\", \"as\": \"y\" }\n  ],\n\n  \"mark\": {\n    \"type\": \"point\",\n    \"stroke\": \"black\"\n  },\n\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"ordinal\", \"axis\": null },\n    \"y\": { \"field\": \"y\", \"type\": \"ordinal\", \"axis\": null },\n    \"shape\": { \"field\": \"x\", \"type\": \"nominal\" },\n    \"fill\": { \"field\": \"x\", \"type\": \"nominal\" },\n    \"size\": {\n      \"field\": \"x\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"type\": \"pow\", \"exponent\": 2, \"range\": [0, 900] }\n    },\n    \"strokeWidth\": {\n      \"field\": \"y\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"range\": [0, 4] }\n    },\n    \"angle\": {\n      \"field\": \"y\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"range\": [0, 45] }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/point/#zoom-behavior","title":"Zoom behavior","text":"<p>Although points are infinitely small on the real number line, they have a specific diameter on the screen. Thus, closely located points tend to overlap each other. Decreasing the point size reduces the probability of overlap, but in a zoomed-in view, the plot may become overly sparse.</p> <p>To control overplotting, the point mark provides two zooming behaviors that adjust the point size and visibility based on the zoom level.</p>"},{"location":"grammar/mark/point/#geometric-zoom","title":"Geometric zoom","text":"<p>Geometric zoom automatically changes the size of points as you zoom in or out. In the example below, the <code>size</code> property is set using an expression that references the <code>zoomLevel</code> parameter. The expression <code>min(0.5 * pow(zoomLevel, 1.5), 200)</code> means that as you zoom in, point size increases, but the growth rate is controlled by the exponent. This helps keep points visible and reduces overlap at higher zoom levels, while preventing them from becoming too large. You can adjust the expression to fine-tune how point size responds to zooming for your specific visualization.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 200000, \"as\": \"x\" }\n  },\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"random() * 0.682\", \"as\": \"u\" },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"((datum.u % 1e-8 &gt; 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618 + sin(datum.x / 10000)\",\n      \"as\": \"y\"\n    }\n  ],\n  \"mark\": {\n    \"type\": \"point\",\n    \"size\": { \"expr\": \"min(0.5 * pow(zoomLevel, 1.5), 200)\" }\n  },\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n    \"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n    \"opacity\": { \"value\": 0.6 }\n  }\n}\n</code></pre> <p>Tip</p> <p>You can use geometric zoom to improve rendering performance. Smaller points are faster to render than large points.</p>"},{"location":"grammar/mark/point/#semantic-zoom","title":"Semantic zoom","text":"<p>The score-based semantic zoom adjusts the point visibility by coupling a score threshold to current zoom level. The <code>semanticScore</code> channel enables the semantic zoom and specifies the score field. The <code>semanticZoomFraction</code> property controls the fraction of data items to show in the fully zoomed-out view, i.e., it specifies the threshold score. The fraction is scaled as the viewport is zoomed. Thus, if the data is distributed roughly uniformly along the zoomed axis, roughly constant number of points are visible at all zoom levels. The score can be arbitrarily distributed, as the threshold is computed using p-quantiles.</p> <p>The example below has 200 000 semi-randomly generated points with an exponentially distributed score. As the view is zoomed in, new points appear. Their number in the viewport stays approximately constant until the lowest possible score has been reached.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 200000, \"as\": \"x\" }\n  },\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"random() * 0.682\", \"as\": \"u\" },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"((datum.u % 1e-8 &gt; 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618\",\n      \"as\": \"y\"\n    },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"-log(random())\",\n      \"as\": \"score\"\n    }\n  ],\n  \"mark\": {\n    \"type\": \"point\",\n    \"semanticZoomFraction\": 0.002\n  },\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n    \"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n    \"opacity\": {\n      \"field\": \"score\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"range\": [0.1, 1] }\n    },\n    \"semanticScore\": { \"field\": \"score\", \"type\": \"quantitative\" },\n    \"size\": { \"value\": 100 }\n  }\n}\n</code></pre> <p>Tip</p> <p>The score-based semantic zoom is great for filtering point mutations and indels that are scored using CADD, for example.</p>"},{"location":"grammar/mark/rect/","title":"Rect","text":"<p>Rect mark displays each data object as a rectangle.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 20, \"as\": \"z\" }\n  },\n  \"transform\": [\n    { \"type\": \"formula\", \"as\": \"x\", \"expr\": \"random()\" },\n    { \"type\": \"formula\", \"as\": \"x2\", \"expr\": \"datum.x + random() * 0.3\" },\n    { \"type\": \"formula\", \"as\": \"y\", \"expr\": \"random()\" },\n    { \"type\": \"formula\", \"as\": \"y2\", \"expr\": \"datum.y + random() * 0.4\" }\n  ],\n  \"mark\": {\n    \"type\": \"rect\",\n    \"strokeWidth\": 2,\n    \"stroke\": \"#404040\",\n    \"cornerRadius\": 5\n  },\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n    \"x2\": { \"field\": \"x2\" },\n    \"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n    \"y2\": { \"field\": \"y2\" },\n    \"color\": { \"field\": \"z\", \"type\": \"quantitative\" }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/rect/#channels","title":"Channels","text":"<p>Rect mark supports the primary and secondary position channels and the <code>color</code>, <code>stroke</code>, <code>fill</code>, <code>opacity</code>, <code>strokeOpacity</code>, <code>fillOpacity</code>, and <code>strokeWidth</code> channels.</p>"},{"location":"grammar/mark/rect/#properties","title":"Properties","text":"<code>clip</code> Type: boolean | <code>\"never\"</code><p>If true, the mark is clipped to the UnitView's rectangle. By default, clipping is enabled for marks that have zoomable positional scales.</p> <code>color</code> Type: string | ExprRef<p>Color of the mark. Affects either <code>fill</code> or <code>stroke</code>, depending on the <code>filled</code> property.</p> <code>cornerRadius</code> Type: number | ExprRef<p>Radius of the rounded corners.</p> <p>Default value: <code>0</code></p> <code>cornerRadiusBottomLeft</code> Type: number | ExprRef<p>Radius of the bottom left rounded corner. Has higher precedence than <code>cornerRadius</code>.</p> <p>Default value: (None)</p> <code>cornerRadiusBottomRight</code> Type: number | ExprRef<p>Radius of the bottom right rounded corner. Has higher precedence than <code>cornerRadius</code>.</p> <p>Default value: (None)</p> <code>cornerRadiusTopLeft</code> Type: number | ExprRef<p>Radius of the top left rounded corner. Has higher precedence than <code>cornerRadius</code>.</p> <p>Default value: (None)</p> <code>cornerRadiusTopRight</code> Type: number | ExprRef<p>Radius of the top right rounded corner. Has higher precedence than <code>cornerRadius</code>.</p> <p>Default value: (None)</p> <code>fill</code> Type: string | ExprRef<p>The fill color.</p> <code>fillOpacity</code> Type: number | ExprRef<p>The fill opacity. Value between <code>0</code> and <code>1</code>.</p> <code>filled</code> Type: boolean<p>Whether the <code>color</code> represents the <code>fill</code> color (<code>true</code>) or the <code>stroke</code> color (<code>false</code>).</p> <code>hatch</code> Type: <code>\"none\"</code> | <code>\"diagonal\"</code> | <code>\"antiDiagonal\"</code> | <code>\"cross\"</code> | <code>\"vertical\"</code> | <code>\"horizontal\"</code> | <code>\"grid\"</code> | <code>\"dots\"</code> | <code>\"rings\"</code> | <code>\"ringsLarge\"</code> | ExprRef<p>A hatch pattern drawn inside the mark using the stroke width, color, and opacity. The pattern is aligned in screen space and scaled by the stroke width.</p> <p>Default value: <code>\"none\"</code></p> <code>minBufferSize</code> Type: number<p>Minimum size for WebGL buffers (number of data items). Allows for using <code>bufferSubData()</code> to update graphics.</p> <p>This property is intended for internal use.</p> <code>minHeight</code> Type: number | ExprRef<p>The minimum height of a rectangle in pixels. The property clamps rectangles' heights.</p> <p>Default value: <code>0</code></p> <code>minOpacity</code> Type: number | ExprRef<p>Clamps the minimum size-dependent opacity. The property does not affect the <code>opacity</code> channel. Valid values are between <code>0</code> and <code>1</code>.</p> <p>When a rectangle would be smaller than what is specified in <code>minHeight</code> and <code>minWidth</code>, it is faded out proportionally. Example: a rectangle would be rendered as one pixel wide, but <code>minWidth</code> clamps it to five pixels. The rectangle is actually rendered as five pixels wide, but its opacity is multiplied by 0.2. With this setting, you can limit the factor to, for example, 0.5 to keep the rectangles more clearly visible.</p> <p>Default value: <code>0</code></p> <code>minWidth</code> Type: number | ExprRef<p>The minimum width of a rectangle in pixels. The property clamps rectangles' widths when the viewport is zoomed out.</p> <p>This property also reduces flickering of very narrow rectangles when zooming. The value should generally be at least one.</p> <p>Default value: <code>1</code></p> <code>opacity</code> Type: number | ExprRef<p>Opacity of the mark. Affects <code>fillOpacity</code> or <code>strokeOpacity</code>, depending on the <code>filled</code> property.</p> <code>shadowBlur</code> Type: number | ExprRef<p>The blur radius of the drop shadow in pixels. Higher values produce a more diffuse shadow.</p> <p>Default value: <code>0</code></p> <code>shadowColor</code> Type: string | ExprRef<p>The color of the drop shadow. Any valid CSS color string is allowed.</p> <p>Default value: <code>\"black\"</code></p> <code>shadowOffsetX</code> Type: number | ExprRef<p>The horizontal offset of the drop shadow in pixels. Positive values move the shadow to the right.</p> <p>Default value: <code>0</code></p> <code>shadowOffsetY</code> Type: number | ExprRef<p>The vertical offset of the drop shadow in pixels. Positive values move the shadow downward.</p> <p>Default value: <code>0</code></p> <code>shadowOpacity</code> Type: number | ExprRef<p>The opacity of the drop shadow. Value between <code>0</code> (fully transparent) and <code>1</code> (fully opaque).</p> <p>Default value: <code>0</code> (disabled)</p> <code>stroke</code> Type: string | ExprRef<p>The stroke color</p> <code>strokeOpacity</code> Type: number | ExprRef<p>The stroke opacity. Value between <code>0</code> and <code>1</code>.</p> <code>strokeWidth</code> Type: number | ExprRef<p>The stroke width in pixels.</p> <code>tooltip</code> Type: HandledTooltip | null<p>Tooltip handler. If <code>null</code>, no tooltip is shown. If string, specifies the tooltip handler to use.</p> <code>x</code> Type: number | ExprRef<p>Position on the x axis.</p> <code>x2</code> Type: number | ExprRef<p>The secondary position on the x axis.</p> <code>xOffset</code> Type: number<p>Offsets of the <code>x</code> and <code>x2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p> <code>y</code> Type: number | ExprRef<p>Position on the y axis.</p> <code>y2</code> Type: number | ExprRef<p>The secondary position on the y axis.</p> <code>yOffset</code> Type: number<p>Offsets of the <code>y</code> and <code>y2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p>"},{"location":"grammar/mark/rect/#examples","title":"Examples","text":""},{"location":"grammar/mark/rect/#heatmap","title":"Heatmap","text":"<p>When used with <code>\"band\"</code> or <code>\"index\"</code> scales, the rectangles fill the whole bands when only the primary positional channel is defined.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 800, \"as\": \"z\" }\n  },\n  \"transform\": [\n    { \"type\": \"formula\", \"as\": \"y\", \"expr\": \"floor(datum.z / 40)\" },\n    { \"type\": \"formula\", \"as\": \"x\", \"expr\": \"datum.z % 40\" },\n    {\n      \"type\": \"formula\",\n      \"as\": \"z\",\n      \"expr\": \"sin(datum.x / 8) + cos(datum.y / 10 - 0.5 + sin(datum.x / 20) * 2)\"\n    }\n  ],\n  \"mark\": \"rect\",\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"index\" },\n    \"y\": { \"field\": \"y\", \"type\": \"index\" },\n    \"color\": {\n      \"field\": \"z\",\n      \"type\": \"quantitative\",\n      \"scale\": {\n        \"scheme\": \"magma\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/rect/#bars","title":"Bars","text":"<pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 60, \"as\": \"x\" }\n  },\n  \"transform\": [\n    {\n      \"type\": \"formula\",\n      \"expr\": \"sin((datum.x - 30) / 4) + (datum.x - 30) / 30\",\n      \"as\": \"y\"\n    }\n  ],\n  \"mark\": \"rect\",\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"index\", \"scale\": { \"padding\": 0.1 } },\n    \"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n    \"y2\": { \"datum\": 0 },\n    \"color\": {\n      \"field\": \"y\",\n      \"type\": \"quantitative\",\n      \"scale\": {\n        \"type\": \"threshold\",\n        \"domain\": [0],\n        \"range\": [\"#ed553b\", \"#20639b\"]\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/rect/#hatch-patterns","title":"Hatch Patterns","text":"<p>Rect marks can be filled with hatch patterns using the <code>hatch</code> property. The hatch pattern is drawn inside the mark with the stroke color and stroke opacity, aligned in screen space and scaled by the stroke width. The value can be a fixed pattern string (such as <code>\"diagonal\"</code> or <code>\"dots\"</code>) or an expression that evaluates to one of these patterns.</p> <p>The hatch pattern is currently a mark property, i.e., the same for all instances of the mark, but may be promoted to a visual channel in the future to allow different hatch patterns for different data points.</p> <pre><code>{\n  \"params\": [\n    {\n      \"name\": \"hatch\",\n      \"value\": \"diagonal\",\n      \"bind\": {\n        \"input\": \"select\",\n        \"options\": [\n          \"none\",\n          \"diagonal\",\n          \"antiDiagonal\",\n          \"cross\",\n          \"vertical\",\n          \"horizontal\",\n          \"grid\",\n          \"dots\",\n          \"rings\",\n          \"ringsLarge\"\n        ]\n      }\n    },\n    {\n      \"name\": \"strokeWidth\",\n      \"value\": 2,\n      \"bind\": { \"input\": \"range\", \"min\": 0, \"max\": 50, \"step\": 0.25 }\n    }\n  ],\n  \"data\": { \"values\": {} },\n  \"mark\": {\n    \"type\": \"rect\",\n    \"fill\": \"#caf0f8\",\n    \"stroke\": \"black\",\n    \"strokeWidth\": { \"expr\": \"strokeWidth\" },\n    \"hatch\": { \"expr\": \"hatch\" }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/rect/#drop-shadow","title":"Drop Shadow","text":""},{"location":"grammar/mark/rect/#shadowed-marks","title":"Shadowed marks","text":"<pre><code>{\n  \"padding\": 20,\n  \"data\": { \"values\": [1, 2, 3, 4] },\n  \"mark\": {\n    \"type\": \"rect\",\n    \"shadowOpacity\": 0.4,\n    \"shadowBlur\": 20,\n    \"shadowOffsetX\": 10,\n    \"shadowOffsetY\": 10,\n    \"clip\": true\n  },\n  \"encoding\": {\n    \"x\": { \"field\": \"data\", \"type\": \"ordinal\", \"scale\": { \"padding\": 0.3 } },\n    \"y\": {\n      \"field\": \"data\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"padding\": 0.1 }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/rect/#shadowed-view","title":"Shadowed view","text":"<p>As the view background is a rect, it can also be decorated with a shadow.</p> <pre><code>{\n  \"padding\": 20,\n  \"view\": {\n    \"shadowOpacity\": 0.2,\n    \"shadowBlur\": 15,\n    \"shadowOffsetY\": 3\n  },\n  \"data\": { \"values\": [1, 2, 3, 4] },\n  \"mark\": \"rect\",\n  \"encoding\": {\n    \"x\": { \"field\": \"data\", \"type\": \"ordinal\", \"scale\": { \"padding\": 0.3 } },\n    \"y\": {\n      \"field\": \"data\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"padding\": 0.1 }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/rule/","title":"Rule","text":"<p>Rule mark displays each data item as a line segment. Rules can span the whole width or height of the view. Alternatively, they may have specific endpoints.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 15, \"as\": \"y\" }\n  },\n  \"mark\": {\n    \"type\": \"rule\",\n    \"strokeDash\": [6, 3]\n  },\n  \"encoding\": {\n    \"x\": { \"field\": \"y\", \"type\": \"quantitative\" },\n    \"color\": { \"field\": \"y\", \"type\": \"nominal\" }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/rule/#channels","title":"Channels","text":"<p>Rule mark supports the primary and secondary position channels and the <code>color</code>, <code>opacity</code>, and <code>size</code> channels.</p>"},{"location":"grammar/mark/rule/#properties","title":"Properties","text":"<code>clip</code> Type: boolean | <code>\"never\"</code><p>If true, the mark is clipped to the UnitView's rectangle. By default, clipping is enabled for marks that have zoomable positional scales.</p> <code>color</code> Type: string | ExprRef<p>Color of the mark. Affects either <code>fill</code> or <code>stroke</code>, depending on the <code>filled</code> property.</p> <code>minBufferSize</code> Type: number<p>Minimum size for WebGL buffers (number of data items). Allows for using <code>bufferSubData()</code> to update graphics.</p> <p>This property is intended for internal use.</p> <code>minLength</code> Type: number | ExprRef<p>The minimum length of the rule in pixels. Use this property to ensure that very short ranged rules remain visible even when the user zooms out.</p> <p>Default value: <code>0</code></p> <code>opacity</code> Type: number | ExprRef<p>Opacity of the mark. Affects <code>fillOpacity</code> or <code>strokeOpacity</code>, depending on the <code>filled</code> property.</p> <code>size</code> Type: number | ExprRef<p>Stroke width of <code>\"link\"</code> and <code>\"rule\"</code> marks in pixels, the area of the bounding square of <code>\"point\"</code> mark, or the font size of <code>\"text\"</code> mark.</p> <code>strokeCap</code> Type: <code>\"butt\"</code> | <code>\"square\"</code> | <code>\"round\"</code> | ExprRef<p>The style of stroke ends. Available choices: <code>\"butt\"</code>, <code>\"round</code>\", and <code>\"square\"</code>.</p> <p>Default value: <code>\"butt\"</code></p> <code>strokeDash</code> Type: array<p>An array of of alternating stroke and gap lengths or <code>null</code> for solid strokes.</p> <p>Default value: <code>null</code></p> <code>strokeDashOffset</code> Type: number<p>An offset for the stroke dash pattern.</p> <p>Default value: <code>0</code></p> <code>tooltip</code> Type: HandledTooltip | null<p>Tooltip handler. If <code>null</code>, no tooltip is shown. If string, specifies the tooltip handler to use.</p> <code>x</code> Type: number | ExprRef<p>Position on the x axis.</p> <code>x2</code> Type: number | ExprRef<p>The secondary position on the x axis.</p> <code>xOffset</code> Type: number<p>Offsets of the <code>x</code> and <code>x2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p> <code>y</code> Type: number | ExprRef<p>Position on the y axis.</p> <code>y2</code> Type: number | ExprRef<p>The secondary position on the y axis.</p> <code>yOffset</code> Type: number<p>Offsets of the <code>y</code> and <code>y2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p>"},{"location":"grammar/mark/rule/#examples","title":"Examples","text":""},{"location":"grammar/mark/rule/#ranged-rules","title":"Ranged rules","text":"<pre><code>{\n  \"data\": {\n    \"values\": [\n      { \"y\": \"A\", \"x\": 2, \"x2\": 7 },\n      { \"y\": \"B\", \"x\": 0, \"x2\": 3 },\n      { \"y\": \"B\", \"x\": 5, \"x2\": 6 },\n      { \"y\": \"C\", \"x\": 4, \"x2\": 8 },\n      { \"y\": \"D\", \"x\": 1, \"x2\": 5 }\n    ]\n  },\n  \"mark\": {\n    \"type\": \"rule\",\n    \"size\": 10,\n    \"strokeCap\": \"round\"\n  },\n  \"encoding\": {\n    \"y\": { \"field\": \"y\", \"type\": \"nominal\" },\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n    \"x2\": { \"field\": \"x2\" }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/rule/#plenty-of-diagonal-rules","title":"Plenty of diagonal rules","text":"<pre><code>{\n  \"width\": 300,\n  \"height\": 300,\n\n  \"data\": {\n    \"sequence\": { \"start\": 0, \"stop\": 50 }\n  },\n\n  \"transform\": [\n    {\n      \"type\": \"formula\",\n      \"expr\": \"random()\",\n      \"as\": \"x\"\n    },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"datum.x + random() * 0.5 - 0.25\",\n      \"as\": \"x2\"\n    },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"random()\",\n      \"as\": \"y\"\n    },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"datum.y + random() * 0.5 - 0.25\",\n      \"as\": \"y2\"\n    },\n    {\n      \"type\": \"formula\",\n      \"expr\": \"random()\",\n      \"as\": \"size\"\n    }\n  ],\n\n  \"mark\": {\n    \"type\": \"rule\",\n    \"strokeCap\": \"round\"\n  },\n\n  \"encoding\": {\n    \"x\": {\n      \"field\": \"x\",\n      \"type\": \"quantitative\"\n    },\n    \"x2\": { \"field\": \"x2\" },\n    \"y\": {\n      \"field\": \"y\",\n      \"type\": \"quantitative\"\n    },\n    \"y2\": { \"field\": \"y2\" },\n    \"size\": {\n      \"field\": \"size\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"type\": \"pow\", \"range\": [0, 10] }\n    },\n    \"color\": {\n      \"field\": \"x\",\n      \"type\": \"nominal\",\n      \"scale\": { \"scheme\": \"category20\" }\n    }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/text/","title":"Text","text":"<p>Text mark displays each data item as text.</p> <pre><code>{\n  \"data\": {\n    \"values\": [\n      { \"x\": 1, \"text\": \"Hello\" },\n      { \"x\": 2, \"text\": \"world!\" }\n    ]\n  },\n  \"mark\": \"text\",\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"ordinal\" },\n    \"color\": { \"field\": \"x\", \"type\": \"nominal\" },\n    \"text\": { \"field\": \"text\" },\n    \"size\": { \"value\": 100 }\n  }\n}\n</code></pre>"},{"location":"grammar/mark/text/#channels","title":"Channels","text":"<p>In addition to primary and secondary position channels and <code>color</code> and <code>opacity</code> channels, point mark has the following channels: <code>text</code>, <code>size</code>, and <code>angle</code>.</p>"},{"location":"grammar/mark/text/#properties","title":"Properties","text":"<code>align</code> Type: <code>\"left\"</code> | <code>\"center\"</code> | <code>\"right\"</code><p>The horizontal alignment of the text. One of <code>\"left\"</code>, <code>\"center\"</code>, or <code>\"right\"</code>.</p> <p>Default value: <code>\"left\"</code></p> <code>angle</code> Type: number | ExprRef<p>The rotation angle in degrees.</p> <p>Default value: <code>0</code></p> <code>baseline</code> Type: <code>\"top\"</code> | <code>\"middle\"</code> | <code>\"bottom\"</code> | <code>\"alphabetic\"</code><p>The vertical alignment of the text.  One of <code>\"top\"</code>, <code>\"middle\"</code>, <code>\"bottom\"</code>.</p> <p>Default value: <code>\"bottom\"</code></p> <code>clip</code> Type: boolean | <code>\"never\"</code><p>If true, the mark is clipped to the UnitView's rectangle. By default, clipping is enabled for marks that have zoomable positional scales.</p> <code>color</code> Type: string | ExprRef<p>Color of the mark. Affects either <code>fill</code> or <code>stroke</code>, depending on the <code>filled</code> property.</p> <code>dx</code> Type: number<p>The horizontal offset between the text and its anchor point, in pixels. Applied after the rotation by <code>angle</code>.</p> <code>dy</code> Type: number<p>The vertical offset between the text and its anchor point, in pixels. Applied after the rotation by <code>angle</code>.</p> <code>fitToBand</code> Type: boolean | ExprRef<p>If true, sets the secondary positional channel that allows the text to be squeezed (see the <code>squeeze</code> property). Can be used when: 1) <code>\"band\"</code>, <code>\"index\"</code>, or <code>\"locus\"</code> scale is being used and 2) only the primary positional channel is specified.</p> <p>Default value: <code>false</code></p> <code>flushX</code> Type: boolean | ExprRef<p>If true, the text is kept inside the viewport when the range of <code>x</code> and <code>x2</code> intersect the viewport.</p> <code>flushY</code> Type: boolean | ExprRef<p>If true, the text is kept inside the viewport when the range of <code>y</code> and <code>y2</code> intersect the viewport.</p> <code>font</code> Type: string<p>The font typeface. GenomeSpy uses SDF versions of Google Fonts. Check their availability at the A-Frame Fonts repository. System fonts are not supported.</p> <p>Default value: <code>\"Lato\"</code></p> <code>fontStyle</code> Type: <code>\"normal\"</code> | <code>\"italic\"</code><p>The font style. Valid values: <code>\"normal\"</code> and <code>\"italic\"</code>.</p> <p>Default value: <code>\"normal\"</code></p> <code>fontWeight</code> Type: number | <code>\"thin\"</code> | <code>\"light\"</code> | <code>\"regular\"</code> | <code>\"normal\"</code> | <code>\"medium\"</code> | <code>\"bold\"</code> | <code>\"black\"</code><p>The font weight. The following strings and numbers are valid values: <code>\"thin\"</code> (<code>100</code>), <code>\"light\"</code> (<code>300</code>), <code>\"regular\"</code> (<code>400</code>), <code>\"normal\"</code> (<code>400</code>), <code>\"medium\"</code> (<code>500</code>), <code>\"bold\"</code> (<code>700</code>), <code>\"black\"</code> (<code>900</code>)</p> <p>Default value: <code>\"regular\"</code></p> <code>logoLetters</code> Type: boolean | ExprRef<p>Stretch letters so that they can be used with sequence logos, etc...</p> <code>minBufferSize</code> Type: number<p>Minimum size for WebGL buffers (number of data items). Allows for using <code>bufferSubData()</code> to update graphics.</p> <p>This property is intended for internal use.</p> <code>opacity</code> Type: number | ExprRef<p>Opacity of the mark. Affects <code>fillOpacity</code> or <code>strokeOpacity</code>, depending on the <code>filled</code> property.</p> <code>paddingX</code> Type: number | ExprRef<p>The horizontal padding, in pixels, when the <code>x2</code> channel is used for ranged text.</p> <p>Default value: <code>0</code></p> <code>paddingY</code> Type: number | ExprRef<p>The vertical padding, in pixels, when the <code>y2</code> channel is used for ranged text.</p> <p>Default value: <code>0</code></p> <code>size</code> Type: number | ExprRef<p>The font size in pixels.</p> <p>Default value: <code>11</code></p> <code>squeeze</code> Type: boolean | ExprRef<p>If the <code>squeeze</code> property is true and secondary positional channels (<code>x2</code> and/or <code>y2</code>) are used, the text is scaled to fit mark's width and/or height.</p> <p>Default value: <code>true</code></p> <code>text</code> Type: Scalar | ExprRef<p>The text to display. The format of numeric data can be customized by setting a format specifier to channel definition's <code>format</code> property.</p> <p>Default value: <code>\"\"</code></p> <code>tooltip</code> Type: HandledTooltip | null<p>Tooltip handler. If <code>null</code>, no tooltip is shown. If string, specifies the tooltip handler to use.</p> <code>viewportEdgeFadeDistanceBottom</code> Type: number<p>TODO</p> <code>viewportEdgeFadeDistanceLeft</code> Type: number<p>TODO</p> <code>viewportEdgeFadeDistanceRight</code> Type: number<p>TODO</p> <code>viewportEdgeFadeDistanceTop</code> Type: number<p>TODO</p> <code>viewportEdgeFadeWidthBottom</code> Type: number<p>TODO</p> <code>viewportEdgeFadeWidthLeft</code> Type: number<p>TODO</p> <code>viewportEdgeFadeWidthRight</code> Type: number<p>TODO</p> <code>viewportEdgeFadeWidthTop</code> Type: number<p>TODO</p> <code>x</code> Type: number | ExprRef<p>Position on the x axis.</p> <code>x2</code> Type: number | ExprRef<p>The secondary position on the x axis.</p> <code>xOffset</code> Type: number<p>Offsets of the <code>x</code> and <code>x2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p> <code>y</code> Type: number | ExprRef<p>Position on the y axis.</p> <code>y2</code> Type: number | ExprRef<p>The secondary position on the y axis.</p> <code>yOffset</code> Type: number<p>Offsets of the <code>y</code> and <code>y2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p>"},{"location":"grammar/mark/text/#examples","title":"Examples","text":"<p>GenomeSpy's text mark provides several tricks useful with segmented data and zoomable visualizations.</p>"},{"location":"grammar/mark/text/#ranged-text","title":"Ranged text","text":"<p>The <code>x2</code> and <code>y2</code> channels allow for positioning the text inside a segment. The text is either squeezed (default) or hidden when it does not fit in the segment. The <code>squeeze</code> property controls the behavior.</p> <p>The example below has two layers: gray rectangles at the bottom and ranged text on the top. Try to zoom and pan to see how they behave!</p> <pre><code>{\n  \"data\": {\n    \"values\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]\n  },\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"round(random() * 100)\", \"as\": \"a\" },\n    { \"type\": \"formula\", \"expr\": \"datum.a + round(random() * 60)\", \"as\": \"b\" }\n  ],\n  \"encoding\": {\n    \"x\": { \"field\": \"a\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n    \"x2\": { \"field\": \"b\" },\n    \"y\": {\n      \"field\": \"data\",\n      \"type\": \"nominal\",\n      \"scale\": {\n        \"padding\": 0.3\n      }\n    }\n  },\n  \"layer\": [\n    {\n      \"mark\": \"rect\",\n      \"encoding\": { \"color\": { \"value\": \"#eaeaea\" } }\n    },\n    {\n      \"mark\": {\n        \"type\": \"text\",\n        \"align\": \"center\",\n        \"baseline\": \"middle\",\n        \"paddingX\": 5\n      },\n      \"encoding\": {\n        \"text\": {\n          \"expr\": \"'Hello ' + floor(datum.a)\"\n        },\n        \"size\": { \"value\": 12 }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/mark/text/#sequence-logo","title":"Sequence logo","text":"<p>The example below demonstrates the use of the <code>logoLetters</code>, <code>squeeze</code>, and <code>fitToBand</code> properties to ensure that the letters fully cover the rectangles defined by the primary and secondary positional channels. Not all fonts look good in sequence logos, but Source Sans Pro seems decent.</p> <pre><code>{\n  \"data\": {\n    \"values\": [\n      { \"pos\": 1, \"base\": \"A\", \"count\": 2 },\n      { \"pos\": 1, \"base\": \"C\", \"count\": 3 },\n      { \"pos\": 1, \"base\": \"T\", \"count\": 5 },\n      { \"pos\": 2, \"base\": \"A\", \"count\": 7 },\n      { \"pos\": 2, \"base\": \"C\", \"count\": 3 },\n      { \"pos\": 3, \"base\": \"A\", \"count\": 10 },\n      { \"pos\": 4, \"base\": \"T\", \"count\": 9 },\n      { \"pos\": 4, \"base\": \"G\", \"count\": 1 },\n      { \"pos\": 5, \"base\": \"G\", \"count\": 8 },\n      { \"pos\": 6, \"base\": \"G\", \"count\": 7 }\n    ]\n  },\n  \"transform\": [\n    {\n      \"type\": \"stack\",\n      \"field\": \"count\",\n      \"groupby\": [\"pos\"],\n      \"offset\": \"information\",\n      \"as\": [\"_y0\", \"_y1\"],\n      \"baseField\": \"base\",\n      \"sort\": { \"field\": \"count\", \"order\": \"ascending\" }\n    }\n  ],\n  \"encoding\": {\n    \"x\": { \"field\": \"pos\", \"type\": \"index\" },\n    \"y\": {\n      \"field\": \"_y0\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"domain\": [0, 2] },\n      \"title\": \"Information\"\n    },\n    \"y2\": { \"field\": \"_y1\" },\n    \"text\": { \"field\": \"base\", \"type\": \"nominal\" },\n    \"color\": {\n      \"field\": \"base\",\n      \"type\": \"nominal\",\n      \"scale\": {\n        \"type\": \"ordinal\",\n        \"domain\": [\"A\", \"C\", \"T\", \"G\"],\n        \"range\": [\"#7BD56C\", \"#FF9B9B\", \"#86BBF1\", \"#FFC56C\"]\n      }\n    }\n  },\n  \"mark\": {\n    \"type\": \"text\",\n    \"font\": \"Source Sans Pro\",\n    \"fontWeight\": 700,\n    \"size\": 100,\n    \"squeeze\": true,\n    \"fitToBand\": true,\n\n    \"paddingX\": 0,\n    \"paddingY\": 0,\n\n    \"logoLetters\": true\n  }\n}\n</code></pre>"},{"location":"grammar/transform/","title":"Data transformation","text":"<p>With transforms, you can build a pipeline that modifies the data before the data objects are mapped to mark instances. In an abstract sense, a transformation inputs a list of data items and outputs a list of new items that may be filtered, modified, or generated from the original items.</p> <p>The data flow is a forest of data sources and subsequent transformations, which may form trees. For instance, a layer view might have a data source, which is then filtered and mutated in a different way for each child layer.</p> <p>Departure from Vega-Lite</p> <p>The notation of transforms is different from Vega-Lite to enable more straghtforward addition of new operations. Each transform has to be specified using an explicit <code>type</code> property like in the lower-level Vega visualization grammar. Thus, the transform type is not inferred from the presence of transform-specific properties.</p>"},{"location":"grammar/transform/#example","title":"Example","text":"<p>The following example uses the <code>\"filter\"</code> transform to retain only the rows that match the predicate expression.</p> <pre><code>{\n  ...,\n  \"data\": { ... },\n  \"transform\": [\n    {\n      \"type\": \"filter\",\n      \"expr\": \"datum.end - datum.start &lt; 5000\"\n    }\n  ],\n  ...\n}\n</code></pre>"},{"location":"grammar/transform/#debugging-the-data-flow","title":"Debugging the Data Flow","text":"<p>Complex visualizations may involve multiple data sources and transformations, which can make it difficult to understand the data flow, particularly when no data objects appear to pass through the flow. The Dataflow Inspector shows the structure of the data flow and allows you to inspect the parameters of each node, the number of propagated data objects, and a recorded copy of the first data object that passes through the node. The Inspector is currently available in the toolbar () of the GenomeSpy App.</p>"},{"location":"grammar/transform/aggregate/","title":"Aggregate","text":"<p>The <code>\"aggregate\"</code> transform summarizes data fields using aggregate functions, such as <code>\"sum\"</code> or <code>\"max\"</code>. The data can be grouped by one or more fields, which results in a list of objects with the grouped fields and the aggregate values.</p>"},{"location":"grammar/transform/aggregate/#parameters","title":"Parameters","text":"<code>as</code> Type: array<p>The names for the output fields corresponding to each aggregated field. If not provided, names will be automatically created using the operation and field names (e.g., <code>sum_field</code>, <code>average_field</code>).</p> <code>fields</code> Type: array<p>The data fields to apply aggregate functions to. This array should correspond with the <code>ops</code> and <code>as</code> arrays. If no fields or operations are specified, a count aggregation will be applied by default.</p> <code>groupby</code> Type: array<p>The fields by which to group the data. If these are not defined, all data objects will be grouped into a single category.</p> <code>ops</code> Type: array<p>The aggregation operations to be performed on the fields, such as <code>\"sum\"</code>, <code>\"average\"</code>, or <code>\"count\"</code>.</p>"},{"location":"grammar/transform/aggregate/#available-aggregate-functions","title":"Available aggregate functions","text":"<p>Aggregate functions are applied to the data fields in each group.</p> <ul> <li><code>\"count\"</code>: Count the number of records in each group.</li> <li><code>\"valid\"</code>: Count the number of non-null and non-NaN values.</li> <li><code>\"sum\"</code>: Sum the values.</li> <li><code>\"mean\"</code>: Calculate the mean value.</li> <li><code>\"average\"</code>: A synonym for <code>\"mean\"</code>.</li> <li><code>\"median\"</code>: Calculate the median value.</li> <li><code>\"min\"</code>: Find the minimum value.</li> <li><code>\"max\"</code>: Find the maximum value.</li> <li><code>\"variance\"</code>: Calculate the variance.</li> </ul>"},{"location":"grammar/transform/aggregate/#example","title":"Example","text":"<p>Given the following data:</p> x y first 123 first 456 second 789 <p>... and configuration:</p> <pre><code>{\n  \"type\": \"aggregate\",\n  \"groupby\": [\"x\"]\n}\n</code></pre> <p>A new list of data objects is created:</p> x count first 2 second 1"},{"location":"grammar/transform/aggregate/#calculating-min-and-max","title":"Calculating min and max","text":"<pre><code>{\n  \"data\": {\n    \"values\": [\n      { \"Category\": \"A\", \"Value\": 5 },\n      { \"Category\": \"A\", \"Value\": 9 },\n      { \"Category\": \"A\", \"Value\": 9.5 },\n      { \"Category\": \"B\", \"Value\": 3 },\n      { \"Category\": \"B\", \"Value\": 5 },\n      { \"Category\": \"B\", \"Value\": 7.5 },\n      { \"Category\": \"B\", \"Value\": 8 }\n    ]\n  },\n\n  \"encoding\": {\n    \"y\": { \"field\": \"Category\", \"type\": \"nominal\" }\n  },\n\n  \"layer\": [\n    {\n      \"encoding\": {\n        \"x\": { \"field\": \"Value\", \"type\": \"quantitative\" }\n      },\n      \"mark\": \"point\"\n    },\n    {\n      \"transform\": [\n        {\n          \"type\": \"aggregate\",\n          \"groupby\": [\"Category\"],\n          \"fields\": [\"Value\", \"Value\"],\n          \"ops\": [\"min\", \"max\"],\n          \"as\": [\"minValue\", \"maxValue\"]\n        }\n      ],\n      \"encoding\": {\n        \"x\": { \"field\": \"minValue\", \"type\": \"quantitative\" },\n        \"x2\": { \"field\": \"maxValue\" }\n      },\n      \"mark\": \"rule\"\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/transform/collect/","title":"Collect","text":"<p>The <code>\"collect\"</code> transform collects (buffers) the data items from the data flow into an internal array and optionally sorts them.</p>"},{"location":"grammar/transform/collect/#parameters","title":"Parameters","text":"<code>groupby</code> Type: array<p>Arranges the data into consecutive batches based on the groups. This is mainly intended for internal use so that faceted data can be handled as batches.</p> <code>sort</code> Type: CompareParams<p>The sort order.</p>"},{"location":"grammar/transform/collect/#example","title":"Example","text":"<pre><code>{\n  \"type\": \"collect\",\n  \"sort\": {\n    \"field\": [\"score\"],\n    \"order\": [\"descending\"]\n  }\n}\n</code></pre>"},{"location":"grammar/transform/coverage/","title":"Coverage","text":"<p>The <code>\"coverage\"</code> transform computes coverage for overlapping segments. The result is a new list of non-overlapping segments with the coverage values. The segments must be sorted by their start coordinates before passing them to the coverage transform.</p>"},{"location":"grammar/transform/coverage/#parameters","title":"Parameters","text":"<code>as</code> Type: string<p>The output field for the computed coverage.</p> <code>asChrom</code> Type: string<p>The output field for the chromosome.</p> <p>Default: Same as <code>chrom</code></p> <code>asEnd</code> Type: string<p>The output field for the end coordinate.</p> <p>Default: Same as <code>end</code></p> <code>asStart</code> Type: string<p>The output field for the start coordinate.</p> <p>Default: Same as <code>start</code></p> <code>chrom</code> Type: string (field name)<p>An optional chromosome field that is passed through. TODO: groupby</p> <code>end</code> Required Type: string (field name)<p>The field representing the end coordinate of the segment (exclusive).</p> <code>start</code> Required Type: string (field name)<p>The field representing the start coordinate of the segment (inclusive).</p> <code>weight</code> Type: string (field name)<p>A field representing an optional weight for the segment. Can be used with copy ratios, for example.</p>"},{"location":"grammar/transform/coverage/#example","title":"Example","text":"<p>Given the following data:</p> start end 0 4 1 3 <p>... and configuration:</p> <pre><code>{\n  \"type\": \"coverage\",\n  \"start\": \"startpos\",\n  \"end\": \"endpos\"\n}\n</code></pre> <p>A new list of segments is produced:</p> start end coverage 0 1 1 1 3 2 3 4 1"},{"location":"grammar/transform/coverage/#interactive-example","title":"Interactive example","text":"<p>The following example demonstrates both <code>\"coverage\"</code> and <code>\"pileup\"</code> transforms.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": {\n      \"start\": 1,\n      \"stop\": 100,\n      \"as\": \"start\"\n    }\n  },\n  \"transform\": [\n    {\n      \"type\": \"formula\",\n      \"expr\": \"datum.start + ceil(random() * 20)\",\n      \"as\": \"end\"\n    }\n  ],\n  \"resolve\": { \"scale\": { \"x\": \"shared\" } },\n  \"vconcat\": [\n    {\n      \"transform\": [\n        {\n          \"type\": \"coverage\",\n          \"start\": \"start\",\n          \"end\": \"end\",\n          \"as\": \"coverage\"\n        }\n      ],\n      \"mark\": \"rect\",\n      \"encoding\": {\n        \"x\": { \"field\": \"start\", \"type\": \"index\" },\n        \"x2\": { \"field\": \"end\" },\n        \"y\": { \"field\": \"coverage\", \"type\": \"quantitative\" }\n      }\n    },\n    {\n      \"transform\": [\n        {\n          \"type\": \"pileup\",\n          \"start\": \"start\",\n          \"end\": \"end\",\n          \"as\": \"lane\"\n        }\n      ],\n      \"mark\": \"rect\",\n      \"encoding\": {\n        \"x\": { \"field\": \"start\", \"type\": \"index\" },\n        \"x2\": { \"field\": \"end\" },\n        \"y\": {\n          \"field\": \"lane\",\n          \"type\": \"index\",\n          \"scale\": {\n            \"padding\": 0.2,\n            \"reverse\": true,\n            \"zoom\": false\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/transform/filter-scored-labels/","title":"Filter Scored Lables","text":"<p>The <code>\"filterScoredLabels\"</code> transform fits prioritized elements such as labels into the available space, dynamically adjusting as the scale domain changes (such as during zooming). It is particularly suited for gene annotation tracks, where genes have an associated importance or score, such as their popularity or relevance, and only the most significant labels should be displayed when space is limited. This transform is typically used in conjunction with the <code>measureText</code> transform to calculate the width of each label.</p> <p>For an usage example, check the Annotation Tracks notebook or the example below.</p>"},{"location":"grammar/transform/filter-scored-labels/#parameters","title":"Parameters","text":"<code>asMidpoint</code> Type: string<p>Outputs the average of pos and pos2 as the midpoint of the element. This is useful for elements that have a width, such as transcripts. The midpoint is clamped to the visible region of the element.</p> <code>channel</code> Type: string<p>Default: <code>\"x\"</code></p> <code>lane</code> Type: string (field name)<p>An optional field representing element's lane, e.g., if transcripts are shown using a piled up layout. Each line is processed separately.</p> <code>padding</code> Type: number<p>Padding (in pixels) around the element.</p> <p>Default: <code>0</code></p> <code>pos</code> Required Type: string (field name)<p>The field representing element's start position on the domain.</p> <code>pos2</code> Type: string (field name)<p>The field representing element's end position on the domain. If not specified, the <code>pos</code> field is used.</p> <code>score</code> Required Type: string (field name)<p>The field representing the score used for prioritization.</p> <code>width</code> Required Type: string (field name)<p>The field representing element's width in pixels.</p>"},{"location":"grammar/transform/filter-scored-labels/#example","title":"Example","text":"<p>Zoom in to see how the labels are filtered based on their score and the available space.</p> <pre><code>{\n  \"data\": { \"sequence\": { \"start\": 0, \"stop\": 100000, \"step\": 1, \"as\": \"_z\" } },\n\n  \"transform\": [\n    { \"type\": \"formula\", \"expr\": \"floor(random() * 10000000)\", \"as\": \"x\" },\n    { \"type\": \"formula\", \"expr\": \"floor(random() * 100000)\", \"as\": \"score\" },\n    { \"type\": \"formula\", \"expr\": \"'' + datum.score\", \"as\": \"label\" },\n    {\n      \"type\": \"measureText\",\n      \"fontSize\": 16,\n      \"field\": \"label\",\n      \"as\": \"textWidth\"\n    },\n    {\n      \"type\": \"filterScoredLabels\",\n      \"score\": \"score\",\n      \"width\": \"textWidth\",\n      \"pos\": \"x\",\n      \"padding\": 5\n    }\n  ],\n\n  \"mark\": {\n    \"type\": \"text\",\n    \"size\": 16\n  },\n\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"index\", \"scale\": { \"domain\": [0, 1000000] } },\n    \"text\": { \"field\": \"label\" }\n  }\n}\n</code></pre>"},{"location":"grammar/transform/filter/","title":"Filter","text":"<p>The <code>\"filter\"</code> transform removes data objects based on a predicate expression or a selection predicate.</p>"},{"location":"grammar/transform/filter/#parameters","title":"Parameters","text":""},{"location":"grammar/transform/filter/#predicate-expression","title":"Predicate Expression","text":"<code>expr</code> Required Type: string<p>An expression string. The data object is removed if the expression evaluates to false.</p>"},{"location":"grammar/transform/filter/#selection-predicate","title":"Selection Predicate","text":"<code>empty</code> Type: boolean<p>If true, the filter retains all data objects when the selection is empty.</p> <p>Default: <code>true</code></p> <code>fields</code> Type: object<p>An optional mapping of positional channels to fields. Used to determine which fields are checked against the selection intervals.</p> <code>param</code> Required Type: string<p>A selection parameter. The data object is removed if it is not part of the selection.</p>"},{"location":"grammar/transform/filter/#example","title":"Example","text":""},{"location":"grammar/transform/filter/#filtering-by-a-predicate-expression","title":"Filtering by a Predicate Expression","text":"<pre><code>{\n  \"type\": \"filter\",\n  \"expr\": \"datum.p &lt;= 0.05\"\n}\n</code></pre> <p>The example above passes through all rows for which the field <code>p</code> is less than or equal to 0.05.</p>"},{"location":"grammar/transform/filter/#filtering-by-a-selection-predicate","title":"Filtering by a Selection Predicate","text":"<p>Interval selections in GenomeSpy are defined by their data extent along the x and/or y channels. When filtering data based on a selection, you must explicitly map the visual channels (x or y) to the corresponding data fields to ensure correct filtering. This ensures that the filter correctly interprets the selection in the context of your dataset.</p> <pre><code>{\n  \"data\": { \"url\": \"sincos.csv\" },\n\n  \"params\": [{ \"name\": \"brush\" }],\n\n  \"vconcat\": [\n    {\n      \"height\": 30,\n      \"transform\": [\n        { \"type\": \"collect\" },\n        {\n          \"type\": \"filter\",\n          \"param\": \"brush\",\n          \"fields\": { \"x\": \"x\", \"y\": \"sin\" }\n        },\n        { \"type\": \"aggregate\" },\n        {\n          \"type\": \"formula\",\n          \"as\": \"text\",\n          \"expr\": \"datum.count + ' points selected'\"\n        }\n      ],\n      \"mark\": { \"type\": \"text\", \"size\": 20 },\n      \"encoding\": {\n        \"text\": { \"field\": \"text\" }\n      }\n    },\n    {\n      \"params\": [\n        {\n          \"name\": \"brush\",\n          \"value\": { \"x\": [2.5, 4], \"y\": [-0.6, 0.6] },\n          \"select\": {\n            \"type\": \"interval\",\n            \"encodings\": [\"x\", \"y\"]\n          },\n          \"push\": \"outer\"\n        }\n      ],\n\n      \"mark\": { \"type\": \"point\", \"size\": 100 },\n\n      \"encoding\": {\n        \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n        \"y\": { \"field\": \"sin\", \"type\": \"quantitative\" }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/transform/flatten-compressed-exons/","title":"Flatten Compressed Exons","text":"<p>The <code>\"flattenCompressedExons\"</code> transform flattens \"delta encoded\" exons. The transform inputs the start coordinate of the gene body and a comma-delimited string of alternating intron and exon lengths. A new data object is created for each exon.</p> <p>This transform is mainly intended to be used with an optimized gene annotation track. Read more at Annotation Tracks notebook.</p>"},{"location":"grammar/transform/flatten-compressed-exons/#parameters","title":"Parameters","text":"<code>as</code> Type: array<p>Field names for the flattened exons.</p> <p>Default: <code>[\"exonStart\", \"exonEnd\"]</code></p> <code>exons</code> Type: string (field name)<p>The field containing the exons.</p> <p>Default: <code>\"exons\"</code></p> <code>start</code> Type: string (field name)<p>Start coordinate of the gene body.</p> <p>Default: <code>\"start\"</code></p>"},{"location":"grammar/transform/flatten-delimited/","title":"Flatten Delimited","text":"<p>The <code>\"flattenDelimited\"</code> transform flattens (or normalizes) a field or a set of fields that contain delimited values. In other words, each delimited value is written into a new data object that contains a single value from the delimited field. All other fields are copied as such.</p>"},{"location":"grammar/transform/flatten-delimited/#parameters","title":"Parameters","text":"<code>as</code> Type: string[] | string<p>The output field name(s) for the flattened field.</p> <p>Default: the input fields.</p> <code>field</code> Required Type: string (field name)[] | string (field name)<p>The field(s) to split and flatten</p> <code>separator</code> Required Type: string[] | string<p>Separator(s) used on the field(s) TODO: Rename to delimiter</p>"},{"location":"grammar/transform/flatten-delimited/#example","title":"Example","text":"<p>Given the following data:</p> patient tissue value A Ova,Asc 4,2 B Adn,Asc,Ute 6,3,4 <p>... and configuration:</p> <pre><code>{\n  \"type\": \"flattenDelimited\",\n  \"field\": [\"tissue\", \"value\"],\n  \"separator\": [\",\", \",\"]\n}\n</code></pre> <p>TODO: Rename separator to delimiter</p> <p>Flattened data is produced:</p> patient tissue value A Ova 4 A Asc 2 B Adn 6 B Asc 3 B Ute 4"},{"location":"grammar/transform/flatten-sequence/","title":"Flatten Sequence","text":"<p>The <code>\"flattenSequence\"</code> transform flattens strings such as FASTA sequences into data objecsts with position and character fields.</p>"},{"location":"grammar/transform/flatten-sequence/#parameters","title":"Parameters","text":"<code>as</code> Type: array<p>Name of the fields where the zero-based index number and flattened sequence letter are written to.</p> <p>Default: <code>[\"pos\", \"sequence\"]</code></p> <code>field</code> Type: string (field name)<p>The field to flatten.</p> <p>Default: <code>\"sequence\"</code></p>"},{"location":"grammar/transform/flatten-sequence/#example","title":"Example","text":"<p>Given the following data:</p> identifier sequence X AC Y ACTG <p>... and parameters:</p> <pre><code>{\n  \"type\": \"flattenSequence\",\n  \"field\": \"sequence\",\n  \"as\": [\"base\", \"pos\"]\n}\n</code></pre> <p>The sequences are flattened into:</p> identifier sequence base pos X AC A 0 X AC C 1 Y ACTG A 0 Y ACTG C 1 Y ACTG T 2 Y ACTG G 3"},{"location":"grammar/transform/flatten/","title":"Flatten","text":"<p>The <code>\"flatten\"</code> transform converts fields that hold arrays into distinct, individual data objects. This creates a new sequence of data, where each element encompasses both an extracted array component and all the original fields from the corresponding input object.</p>"},{"location":"grammar/transform/flatten/#parameters","title":"Parameters","text":"<code>as</code> Type: string[] | string<p>The output field name(s) for the flattened field.</p> <p>Default: the input fields.</p> <code>fields</code> Type: string (field name)[] | string (field name)<p>The field(s) to flatten. If no field is defined, the data object itself is treated as an array to be flattened.</p> <code>index</code> Type: string<p>The output field name for the zero-based index of the array values. If unspecified, an index field is not added.</p>"},{"location":"grammar/transform/flatten/#example","title":"Example","text":""},{"location":"grammar/transform/flatten/#single-field-flattening","title":"Single-Field Flattening","text":"<p>This example flattens the array-valued field named <code>foo</code>. Note that all fields except <code>foo</code> are repeated in every output datum.</p> <pre><code>{ \"type\": \"flatten\", \"fields\": [\"foo\"] }\n</code></pre> <p>Input data:</p> <pre><code>[\n  { \"name\": \"alpha\", \"data\": 123, \"foo\": [1, 2] },\n  { \"name\": \"beta\", \"data\": 456, \"foo\": [3, 4, 5] }\n]\n</code></pre> <p>Result:</p> <pre><code>[\n  { \"name\": \"alpha\", \"data\": 123, \"foo\": 1 },\n  { \"name\": \"alpha\", \"data\": 123, \"foo\": 2 },\n  { \"name\": \"beta\", \"data\": 456, \"foo\": 3 },\n  { \"name\": \"beta\", \"data\": 456, \"foo\": 4 },\n  { \"name\": \"beta\", \"data\": 456, \"foo\": 5 }\n]\n</code></pre>"},{"location":"grammar/transform/flatten/#adding-an-index-field","title":"Adding an Index Field","text":"<pre><code>{ \"type\": \"flatten\", \"fields\": [\"foo\"], \"index\": \"idx\" }\n</code></pre> <p>This example adds an field containing the array index that each item originated from.</p> <pre><code>[\n  { \"name\": \"alpha\", \"data\": 123, \"foo\": [1, 2] },\n  { \"name\": \"beta\", \"data\": 456, \"foo\": [3, 4, 5] }\n]\n</code></pre> <p>Result:</p> <pre><code>[\n  { \"name\": \"alpha\", \"data\": 123, \"foo\": 1, \"idx\": 0 },\n  { \"name\": \"alpha\", \"data\": 123, \"foo\": 2, \"idx\": 1 },\n  { \"name\": \"beta\", \"data\": 456, \"foo\": 3, \"idx\": 0 },\n  { \"name\": \"beta\", \"data\": 456, \"foo\": 4, \"idx\": 1 },\n  { \"name\": \"beta\", \"data\": 456, \"foo\": 5, \"idx\": 2 }\n]\n</code></pre>"},{"location":"grammar/transform/flatten/#multi-field-flattening","title":"Multi-Field Flattening","text":"<pre><code>{ \"type\": \"flatten\", \"fields\": [\"foo\", \"bar\"] }\n</code></pre> <p>This example simultaneously flattens the array-valued fields <code>foo</code> and <code>bar</code>. Given the input data</p> <pre><code>[\n  { \"key\": \"alpha\", \"foo\": [1, 2], \"bar\": [\"A\", \"B\"] },\n  { \"key\": \"beta\", \"foo\": [3, 4, 5], \"bar\": [\"C\", \"D\"] }\n]\n</code></pre> <p>this example produces the output:</p> <pre><code>[\n  { \"key\": \"alpha\", \"foo\": 1, \"bar\": \"A\" },\n  { \"key\": \"alpha\", \"foo\": 2, \"bar\": \"B\" },\n  { \"key\": \"beta\", \"foo\": 3, \"bar\": \"C\" },\n  { \"key\": \"beta\", \"foo\": 4, \"bar\": \"D\" },\n  { \"key\": \"beta\", \"foo\": 5, \"bar\": null }\n]\n</code></pre>"},{"location":"grammar/transform/flatten/#flattening-array-objects","title":"Flattening Array Objects","text":"<pre><code>{ \"type\": \"flatten\" }\n</code></pre> <p>This example treats the data objects as arrays that should be flattened. Given the input data</p> <pre><code>[[{ \"foo\": 1 }], [{ \"foo\": 2 }, { \"foo\": 3 }]]\n</code></pre> <p>this example produces the output:</p> <pre><code>[{ \"foo\": 1 }, { \"foo\": 2 }, { \"foo\": 3 }]\n</code></pre>"},{"location":"grammar/transform/formula/","title":"Formula","text":"<p>The <code>\"formula\"</code> transform uses an expression to calculate and add a new field to the data objects.</p>"},{"location":"grammar/transform/formula/#parameters","title":"Parameters","text":"<code>as</code> Required Type: string<p>The (new) field where the computed value is written to</p> <code>expr</code> Required Type: string<p>An expression string</p>"},{"location":"grammar/transform/formula/#example","title":"Example","text":"<p>Given the following data:</p> x y 1 2 3 4 <p>... and configuration:</p> <pre><code>{\n  \"type\": \"formula\",\n  \"expr\": \"datum.x + datum.y\",\n  \"as\": \"z\"\n}\n</code></pre> <p>A new field is added:</p> x y z 1 2 3 3 4 7"},{"location":"grammar/transform/formula/#using-with-parameters","title":"Using with Parameters","text":"<p>As expressions have access to parameters, they can be used to create dynamic visualizations. The following example uses a formula to calculate the sum of two sine waves with different wave lengths. The wave lengths are controlled by the <code>a</code> and <code>b</code> parameters.</p> <p>Under the hood, when any of the parameters change, the formula transform finds the closest collector or data source in the data pipeline and triggers a re-propagation of the data, resulting in a re-evaluation of the formula expression.</p> <pre><code>{\n  \"params\": [\n    {\n      \"name\": \"a\",\n      \"value\": 200,\n      \"bind\": { \"input\": \"range\", \"min\": 10, \"max\": 2000, \"step\": 1 }\n    },\n    {\n      \"name\": \"b\",\n      \"value\": 270,\n      \"bind\": { \"input\": \"range\", \"min\": 10, \"max\": 2000, \"step\": 1 }\n    }\n  ],\n\n  \"data\": { \"sequence\": { \"start\": 0, \"stop\": 1000, \"as\": \"x\" } },\n\n  \"transform\": [\n    {\n      \"type\": \"formula\",\n      \"expr\": \"sin(datum.x * 2 * PI / a) + sin(datum.x * 2 * PI / b)\",\n      \"as\": \"y\"\n    }\n  ],\n\n  \"mark\": \"point\",\n\n  \"encoding\": {\n    \"size\": { \"value\": 4 },\n    \"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n    \"y\": { \"field\": \"y\", \"type\": \"quantitative\" }\n  }\n}\n</code></pre>"},{"location":"grammar/transform/linearize-genomic-coordinate/","title":"Linearize Genomic Coordinate","text":"<p>The <code>linearizeGenomicCoordinate</code> transform maps the (chromosome, position) pairs into a linear coordinate space using the chromosome sizes of the current genome assembly.</p>"},{"location":"grammar/transform/linearize-genomic-coordinate/#parameters","title":"Parameters","text":"<code>as</code> Required Type: string | string[]<p>The output field or fields for linearized coordinates.</p> <code>channel</code> Type: string<p>Get the genome assembly from the scale of the channel.</p> <p>Default: <code>\"x\"</code></p> <code>chrom</code> Required Type: string (field name)<p>The chromosome/contig field</p> <code>offset</code> Type: number | number[]<p>An offset or offsets that allow for adjusting the numbering base. The offset is subtracted from the positions.</p> <p>GenomeSpy uses internally zero-based indexing with half-open intervals. UCSC-based formats (BED, etc.) generally use this scheme. However, for example, VCF files use one-based indexing and must be adjusted by setting the offset to <code>1</code>.</p> <p>Default: <code>0</code></p> <code>pos</code> Required Type: string (field name) | string (field name)[]<p>The field or fields that contain intra-chromosomal positions</p>"},{"location":"grammar/transform/linearize-genomic-coordinate/#example","title":"Example","text":"<pre><code>{\n  \"type\": \"linearizeGenomicCoordinate\",\n  \"chrom\": \"chrom\",\n  \"pos\": \"start\",\n  \"as\": \"_start\"\n}\n</code></pre>"},{"location":"grammar/transform/measure-text/","title":"Measure Text","text":"<p>The <code>\"measureText\"</code> transforms measures the length of a string in pixels. The measurement can be used in downstream layout computations with the filterScoredLabels transform.</p> <p>For an usage example, check the Annotation Tracks notebook.</p>"},{"location":"grammar/transform/measure-text/#parameters","title":"Parameters","text":"<code>as</code> Required Type: string<p>TODO</p> <code>field</code> Required Type: string (field name)<p>TODO</p> <code>fontSize</code> Required Type: number | ExprRef<p>TODO</p>"},{"location":"grammar/transform/measure-text/#example","title":"Example","text":"<pre><code>{\n  \"type\": \"measureText\",\n  \"fontSize\": 11,\n  \"field\": \"symbol\",\n  \"as\": \"_textWidth\"\n}\n</code></pre>"},{"location":"grammar/transform/pileup/","title":"Pileup","text":"<p>The <code>\"pileup\"</code> transform computes a piled up layout for overlapping segments. The computed lane can be used to position the segments in a visualization. The segments must be sorted by their start coordinates before passing them to the pileup transform.</p>"},{"location":"grammar/transform/pileup/#parameters","title":"Parameters","text":"<code>as</code> Type: string<p>The output field name for the computed lane.</p> <p>Default: <code>\"lane\"</code>.</p> <code>end</code> Required Type: string (field name)<p>The field representing the end coordinate of the segment (exclusive).</p> <code>preference</code> Type: string (field name)<p>An optional field indicating the preferred lane. Use together with the <code>preferredOrder</code> property.</p> <code>preferredOrder</code> Type: string[] | number[] | boolean[]<p>The order of the lane preferences. The first element contains the value that should place the segment on the first lane and so forth. If the preferred lane is occupied, the first available lane is taken.</p> <code>spacing</code> Type: number<p>The spacing between adjacent segments on the same lane in coordinate units.</p> <p>Default: <code>1</code>.</p> <code>start</code> Required Type: string (field name)<p>The field representing the start coordinate of the segment (inclusive).</p>"},{"location":"grammar/transform/pileup/#example","title":"Example","text":"<p>Given the following data:</p> start end 0 4 1 3 2 6 4 8 <p>... and configuration:</p> <pre><code>{\n  \"type\": \"pileup\",\n  \"start\": \"start\",\n  \"end\": \"end\",\n  \"as\": \"lane\"\n}\n</code></pre> <p>A new field is added:</p> start end lane 0 4 0 1 3 1 2 6 2 4 8 1"},{"location":"grammar/transform/pileup/#interactive-example","title":"Interactive example","text":"<p>The following example demonstrates both <code>\"coverage\"</code> and <code>\"pileup\"</code> transforms.</p> <pre><code>{\n  \"data\": {\n    \"sequence\": {\n      \"start\": 1,\n      \"stop\": 100,\n      \"as\": \"start\"\n    }\n  },\n  \"transform\": [\n    {\n      \"type\": \"formula\",\n      \"expr\": \"datum.start + ceil(random() * 20)\",\n      \"as\": \"end\"\n    }\n  ],\n  \"resolve\": { \"scale\": { \"x\": \"shared\" } },\n  \"vconcat\": [\n    {\n      \"transform\": [\n        {\n          \"type\": \"coverage\",\n          \"start\": \"start\",\n          \"end\": \"end\",\n          \"as\": \"coverage\"\n        }\n      ],\n      \"mark\": \"rect\",\n      \"encoding\": {\n        \"x\": { \"field\": \"start\", \"type\": \"index\" },\n        \"x2\": { \"field\": \"end\" },\n        \"y\": { \"field\": \"coverage\", \"type\": \"quantitative\" }\n      }\n    },\n    {\n      \"transform\": [\n        {\n          \"type\": \"pileup\",\n          \"start\": \"start\",\n          \"end\": \"end\",\n          \"as\": \"lane\"\n        }\n      ],\n      \"mark\": \"rect\",\n      \"encoding\": {\n        \"x\": { \"field\": \"start\", \"type\": \"index\" },\n        \"x2\": { \"field\": \"end\" },\n        \"y\": {\n          \"field\": \"lane\",\n          \"type\": \"index\",\n          \"scale\": {\n            \"padding\": 0.2,\n            \"reverse\": true,\n            \"zoom\": false\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"grammar/transform/project/","title":"Project","text":"<p>The <code>\"project\"</code> transform retains the specified fields of the data objects, optionally renaming them. All other fields are removed.</p>"},{"location":"grammar/transform/project/#parameters","title":"Parameters","text":"<code>as</code> Type: array<p>New names for the projected fields. If omitted, the names of the source fields are used.</p> <code>fields</code> Required Type: array<p>The fields to be projected.</p>"},{"location":"grammar/transform/project/#example","title":"Example","text":"<pre><code>{\n  \"type\": \"project\",\n  \"fields\": [\"lane\", \"start\", \"exons\"]\n}\n</code></pre>"},{"location":"grammar/transform/regex-extract/","title":"Regex Extract","text":"<p>The <code>\"regexExtract\"</code> transform extracts groups from a string field and adds them to the data objects as new fields.</p>"},{"location":"grammar/transform/regex-extract/#parameters","title":"Parameters","text":"<code>as</code> Required Type: string | string[]<p>The new field or an array of fields where the extracted values are written.</p> <code>field</code> Required Type: string (field name)<p>The source field</p> <code>regex</code> Required Type: string<p>A valid JavaScript regular expression with at least one group. For example: <code>\"^Sample(\\\\d+)$\"</code>.</p> <p>Read more at: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions</p> <code>skipInvalidInput</code> Type: boolean<p>Do not complain about invalid input. Just skip it and leave the new fields undefined on the affected datum.</p> <p>Default: <code>false</code></p>"},{"location":"grammar/transform/regex-extract/#example","title":"Example","text":"<p>Given the following data:</p> Gene Genome Location AKT1 14:104770341-104792643 <p>... and configuration:</p> <pre><code>{\n  \"type\": \"regexExtract\",\n  \"field\": \"Genome Location\",\n  \"regex\": \"^(X|Y|\\\\d+):(\\\\d+)-(\\\\d+)$\",\n  \"as\": [\"Chrom\", \"Start\", \"End\"]\n}\n</code></pre> <p>Three new fields are added to the data:</p> Gene Genome Location Chrom Start End AKT1 14:104770341-104792643 14 104770341 104792643"},{"location":"grammar/transform/regex-fold/","title":"Regex Fold","text":"<p>The <code>\"regexFold\"</code> transform gathers columns into key-value pairs using a regular expression.</p>"},{"location":"grammar/transform/regex-fold/#parameters","title":"Parameters","text":"<code>asKey</code> Type: string<p>Default: <code>\"sample\"</code></p> <code>asValue</code> Required Type: string[] | string<p>A new column name for the extracted values.</p> <code>columnRegex</code> Required Type: string[] | string<p>A regular expression that matches to column names. The regex must have one capturing group that is used for extracting the key (e.g., a sample id) from the column name.</p> <code>skipRegex</code> Type: string<p>An optional regex that matches to fields that should not be included in the new folded data objects.</p>"},{"location":"grammar/transform/regex-fold/#example","title":"Example","text":"<p>Given the following data:</p> SNP foo.AF bar.AF baz.AF rs99924582 0.3 0.24 0.94 rs22238423 0.92 0.21 0.42 <p>... and configuration:</p> <pre><code>{\n  \"type\": \"regexFold\",\n  \"columnRegex\": [\"^(.*)\\\\.AF$\"],\n  \"asValue\": [\"VAF\"],\n  \"asKey\": \"sample\"\n}\n</code></pre> <p>The matched columns are folded into new data objects. All others are left intact:</p> SNP sample VAF rs99924582 foo 0.3 rs99924582 bar 0.24 rs99924582 baz 0.94 rs22238423 foo 0.92 rs22238423 bar 0.21 rs22238423 baz 0.42"},{"location":"grammar/transform/sample/","title":"Sample","text":"<p>The <code>\"sample\"</code> transform takes a random sample of the data objects.</p>"},{"location":"grammar/transform/sample/#parameters","title":"Parameters","text":"<code>size</code> Type: number<p>The maximum sample size.</p> <p>Default: <code>500</code></p>"},{"location":"grammar/transform/sample/#example","title":"Example","text":"<pre><code>{\n  \"type\": \"sample\",\n  \"size\": 100\n}\n</code></pre>"},{"location":"grammar/transform/stack/","title":"Stack","text":"<p>The <code>\"stack\"</code> transform computes a stacked layout. Stacked bar plots and sequence logos are some of its applications.</p>"},{"location":"grammar/transform/stack/#parameters","title":"Parameters","text":"<code>as</code> Required Type: array<p>Fields to write the stacked values.</p> <p>Default: <code>[\"y0\", \"y1\"]</code></p> <code>baseField</code> Type: string (field name)<p>The field that contains the base or amino acid. Used for information content calculation when the offset is <code>\"information\"</code>. The data objects that have <code>null</code> in the baseField are considered gaps and they are taken into account when scaling the the locus' information content.</p> <code>cardinality</code> Type: number<p>Cardinality, e.g., the number if distinct bases or amino acids. Used for information content calculation when the offset is <code>\"information\"</code>.</p> <p>Default: <code>4</code></p> <code>field</code> Type: string (field name)<p>The field to stack. If no field is defined, a constant value of one is assumed.</p> <code>groupby</code> Required Type: array<p>The fields to be used for forming groups for different stacks.</p> <code>offset</code> Type: string<p>How to offset the values in a stack. <code>\"zero\"</code> (default) starts stacking at 0. <code>\"center\"</code> centers the values around zero. <code>\"normalize\"</code> computes intra-stack percentages and normalizes the values to the range of <code>[0, 1]</code>. <code>\"information\"</code> computes a layout for a sequence logo. The total height of the stack reflects the group's information content.</p> <code>sort</code> Type: CompareParams<p>The sort order of data in each stack.</p>"},{"location":"grammar/transform/stack/#examples","title":"Examples","text":""},{"location":"grammar/transform/stack/#stacked-bar-plot","title":"Stacked bar plot","text":"<pre><code>{\n  \"data\": {\n    \"values\": [\n      { \"x\": 1, \"q\": \"A\", \"z\": 7 },\n      { \"x\": 1, \"q\": \"B\", \"z\": 3 },\n      { \"x\": 1, \"q\": \"C\", \"z\": 10 },\n      { \"x\": 2, \"q\": \"A\", \"z\": 8 },\n      { \"x\": 2, \"q\": \"B\", \"z\": 5 },\n      { \"x\": 3, \"q\": \"B\", \"z\": 10 }\n    ]\n  },\n  \"transform\": [\n    {\n      \"type\": \"stack\",\n      \"field\": \"z\",\n      \"groupby\": [\"x\"]\n    }\n  ],\n  \"mark\": \"rect\",\n  \"encoding\": {\n    \"x\": { \"field\": \"x\", \"type\": \"nominal\", \"band\": 0.8 },\n    \"y\": { \"field\": \"y0\", \"type\": \"quantitative\" },\n    \"y2\": { \"field\": \"y1\" },\n    \"color\": { \"field\": \"q\", \"type\": \"nominal\" }\n  }\n}\n</code></pre>"},{"location":"grammar/transform/stack/#sequence-logo","title":"Sequence logo","text":"<pre><code>{\n  \"data\": {\n    \"values\": [\n      { \"pos\": 1, \"base\": \"A\", \"count\": 2 },\n      { \"pos\": 1, \"base\": \"C\", \"count\": 3 },\n      { \"pos\": 1, \"base\": \"T\", \"count\": 5 },\n      { \"pos\": 2, \"base\": \"A\", \"count\": 7 },\n      { \"pos\": 2, \"base\": \"C\", \"count\": 3 },\n      { \"pos\": 3, \"base\": \"A\", \"count\": 10 },\n      { \"pos\": 4, \"base\": \"T\", \"count\": 9 },\n      { \"pos\": 4, \"base\": \"G\", \"count\": 1 },\n      { \"pos\": 5, \"base\": \"G\", \"count\": 8 },\n      { \"pos\": 6, \"base\": \"G\", \"count\": 7 }\n    ]\n  },\n  \"transform\": [\n    {\n      \"type\": \"stack\",\n      \"field\": \"count\",\n      \"groupby\": [\"pos\"],\n      \"offset\": \"information\",\n      \"as\": [\"_y0\", \"_y1\"],\n      \"baseField\": \"base\",\n      \"sort\": { \"field\": \"count\", \"order\": \"ascending\" }\n    }\n  ],\n  \"encoding\": {\n    \"x\": { \"field\": \"pos\", \"type\": \"index\" },\n    \"y\": {\n      \"field\": \"_y0\",\n      \"type\": \"quantitative\",\n      \"scale\": { \"domain\": [0, 2] },\n      \"title\": \"Information\"\n    },\n    \"y2\": { \"field\": \"_y1\" },\n    \"text\": { \"field\": \"base\", \"type\": \"nominal\" },\n    \"color\": {\n      \"field\": \"base\",\n      \"type\": \"nominal\",\n      \"scale\": {\n        \"type\": \"ordinal\",\n        \"domain\": [\"A\", \"C\", \"T\", \"G\"],\n        \"range\": [\"#7BD56C\", \"#FF9B9B\", \"#86BBF1\", \"#FFC56C\"]\n      }\n    }\n  },\n  \"mark\": {\n    \"type\": \"text\",\n    \"font\": \"Source Sans Pro\",\n    \"fontWeight\": 700,\n    \"size\": 100,\n    \"squeeze\": true,\n    \"fitToBand\": true,\n\n    \"paddingX\": 0,\n    \"paddingY\": 0,\n\n    \"logoLetters\": true\n  }\n}\n</code></pre>"},{"location":"sample-collections/","title":"Working with Sample Collections","text":"<p>The app package of the GenomeSpy toolkit enables an interactive analysis of large sample collections. It builds upon the core package, which allows developers to build tailored visualizations using the visualization grammar and GPU-accelerated rendering engine. The app extends the grammar with a facet operator that makes it possible to repeat a single visualization for thousands of samples. The end users of the visualization have access to several interactions that facilitate the exploration of such sample collections.</p> <p></p> <p>The documentation of the app package is split into two parts serving different audiences:</p> <ol> <li>Visualizing Sample Collections (for method developers)</li> <li>Analyzing Sample Collections (for end users)</li> </ol>"},{"location":"sample-collections/analyzing/","title":"Analyzing Sample Collections","text":"<p>End-User Documentation</p> <p>This page is mainly intended for end users who analyze sample collections interactively using the GenomeSpy app.</p>"},{"location":"sample-collections/analyzing/#elements-of-the-user-interface","title":"Elements of the user interface","text":"<p>Because GenomeSpy visualizations are highly customizable, the actual visualization and the available user-interface elements may differ significantly from what is shown below.</p> <p></p> <ol> <li>Location / search field shows the genomic coordinates of the current viewport    in a UCSC-style format. You can look up features such as gene symbols using the    field. In addition, you can filter the sample collection by categorical    metadata attibutes by typing a categorical value into this field.</li> <li>Undo history and provenance allows you to undo and redo actions performed on the    sample collection. The provenance () button shows    all perfomed actions, allowing you to better understand how the current    visualization state was constructed.</li> <li>View visibility menu allows for toggling the visibility of elements such as    metadata attributes or annotation tracks.</li> <li>Bookmark menu shows a list of pre-defined bookmarks and allows you to save    the visualization state as a local bookmark into your web browser. The adjacent    Share () button constructs a shareable URL, which    captures the visualization state and optional notes related to the current    visualization state.</li> <li>Fullscreen toggle opens the visualization in fullscreen mode.</li> <li>Group markers become visible when the sample collection has been stratified    using some attribute.</li> <li>Sample names identify the samples.</li> <li>Metadata such as clinical attributes or computed variables shown as a heatmap.</li> <li>Genomic data is shown here.</li> </ol>"},{"location":"sample-collections/analyzing/#navigation-interactions","title":"Navigation interactions","text":""},{"location":"sample-collections/analyzing/#navigating-around-the-genome","title":"Navigating around the genome","text":"<p>To navigate around the genome in GenomeSpy, you can use either a mouse or a touchpad. If you're using a mouse, you can zoom the genome axis in and out using the scroll wheel. To pan the view, click with the left mouse button and start dragging.</p> <p>If you're using a touchpad, you can zoom the genome axis by performing a vertical two-finger gesture. Similarly, you can pan the view by performing a horizontal gesture.</p>"},{"location":"sample-collections/analyzing/#peeking-samples","title":"Peeking samples","text":"<p>The GenomeSpy app is designed for the exploration of large datasets containing hundreds or thousands of samples. To provide a better overview of patterns across the entire sample collection, GenomeSpy displays the samples as a bird's eye view that fits them into the available vertical space. If you discover interesting patterns or outliers in the dataset, you can peek individual samples by activating a close-up view from the context menu or by pressing the E key on the keyboard.</p> <p>Once the close-up view is activated, the zooming interaction will change to vertical scrolling. However, you can still zoom in and out by holding down the Ctrl key while operating the mouse wheel or touchpad.</p>"},{"location":"sample-collections/analyzing/#manipulating-the-sample-collection","title":"Manipulating the sample collection","text":"<p>Sorting, filtering, and stratifying a large sample collection can provide valuable insights into the data by helping to identify patterns and outliers. By sorting samples based on a particular attribute or filtering out irrelevant samples, you can more easily identify patterns or trends in the data that might be difficult to see otherwise. Stratifying the sample collection by grouping samples into distinct categories can also help to identify meaningful differences between groups and reveal new insights into the data.</p> <p>The GenomeSpy app enables users to manipulate the sample collection using incremental actions that operate on abstract attributes, such as metadata variables or measured values at specific genomic loci. By applying a series of these stepwise actions, users can gradually shape the sample collection to their needs, enabling complex analyses. The applied actions are saved in an undo history, which also serves as provenance information for bookmarks and shared links.</p> <p>An example scenario</p> <p>Suppose a user has a sample collection that includes multiple tumor samples from each patient and wants to keep a single representative sample from each patient. The user defines a representative sample as having a tumor purity greater or equal to 15% and the highest copy number at the MYC locus. To form a sample collection with only the representative samples, the user performs the following actions:</p> <ol> <li>Retains samples with purity greater than or equal to 15%</li> <li>Sorts the samples in descending order by the copy number at the MYC locus</li> <li>Retains only the top sample from each patient, based on the sorting in Step 2</li> </ol> <p>Following these steps, the user is left with the representative samples.</p>"},{"location":"sample-collections/analyzing/#accessing-the-actions","title":"Accessing the actions","text":"<p>You can access the actions via a context menu, which appears when you right-click on a metadata attribute in the heatmap or a location in the genomic data panel.</p> <p>There are two types of attributes: quantitative and categorical. Each type has a different set of supported actions. For example, quantitative attributes can be filtered using a threshold, while categorical attributes support retention or removal of selected categories.</p> <p>The context menu also provides shortcuts to some actions based on the value under the cursor. For example, a context menu opened on a categorical attribute will give you actions for retaining or removing samples with the selected categorical value.</p>"},{"location":"sample-collections/analyzing/#undo-history-and-provenance","title":"Undo history and provenance","text":"<p>GenomeSpy stores the applied actions in an undo history, allowing you to easily experiment with different analyses and revert back to previous states if needed. The provenance button () reveals a menu that shows the applied actions together with the used attributes and parameters. You can jump to different states in the undo history by clicking the menu items or the adjacent previous/next buttons.</p>"},{"location":"sample-collections/analyzing/#the-actions","title":"The actions","text":""},{"location":"sample-collections/analyzing/#sort","title":"Sort","text":"<p>The Sort by action arranges the samples in a descending order based on the chosen quantitative attribute.</p>"},{"location":"sample-collections/analyzing/#filter-by-a-categorical-attribute","title":"Filter by a categorical attribute","text":"<p>The context menu provides two shortcut actions for retaining and removing samples having the chosen value in the selected attribute. The Advanced filter... option allows you to choose multiple categories to be retained or removed.</p>"},{"location":"sample-collections/analyzing/#filter-by-a-quantitative-attribute","title":"Filter by a quantitative attribute","text":"<p>For quantitative attributes, the menu offers shortcut actions for retaining samples with a value greater or equal to or less or equal to the chosen value. For more precise thresholding, you can use the Advanced filter... option, which opens a dialog with a histogram and options for choosing open or closed thresholds.</p>"},{"location":"sample-collections/analyzing/#retain-the-first-of-each","title":"Retain the first of each","text":"<p>In many analyses, it is necessary to select a single, representative sample from each category. This action retains the first, topmost sample from each category. It is not necessary to sort the samples by the categorical attribute, but rather they should be sorted according to the attributes used to select the representative samples. For a usage example, refer to the example scenario provided in the box above.</p>"},{"location":"sample-collections/analyzing/#retain-first-n-categories","title":"Retain first n categories","text":"<p>Sometimes you might be interested in a small number of categories that contain samples with the most extreme values in another attribute. For example, if each patient (the category) has multiple samples, this action allows you to retain all samples from the top-5 patients based on the highest number of mutations (the another attribute) in any of their samples.</p>"},{"location":"sample-collections/analyzing/#create-custom-groups","title":"Create custom groups","text":"<p>Use this action to manually select and group multiple categories together according to your specific requirements. This feature allows you to create new groups that contain any combination of categories from your data, giving you the flexibility to organize and view your data in customized groupings.</p>"},{"location":"sample-collections/analyzing/#group-by-categorical-attribute","title":"Group by categorical attribute","text":"<p>This action stratifies the data based on the selected categorical attribute. The groups will be shown to the left of the sample names, as shown above.</p>"},{"location":"sample-collections/analyzing/#group-by-quartiles","title":"Group by quartiles","text":"<p>This action enables rapid stratification into four groups using a quantitative attribute. The implementation uses the R-7 method, the default in the R programming language and Excel.</p>"},{"location":"sample-collections/analyzing/#group-by-thresholds","title":"Group by thresholds","text":"<p>The group by thresholds action allows stratifying the samples using custom thresholds on a quantitative attribute. Upon selecting this action, you are shown a dialog with a histogram, where you can add any number of thresholds and specify which side of the threshold should be open or closed.</p>"},{"location":"sample-collections/analyzing/#retain-matched","title":"Retain matched","text":"<p>This action retains categories that are common to all of the current groups. For example, suppose you are working with a sample collection with multiple samples from each patient. You have grouped the samples into two groups based on the anatomical site of the sample. By applying this action to the categorical patient attribute, you can ensure that your sample collection comprises only those patients with samples from both anatomical sites. In other words, the patients with only a single anatomical site are removed.</p>"},{"location":"sample-collections/analyzing/#bookmarking-and-sharing","title":"Bookmarking and sharing","text":"<p>Saving a visualization state together with provenance as a bookmark is a practical way to revisit a particular visualization later or share it with others. Bookmarks store the entire state of the visualization, including the actions taken to arrive at that state. This allows for easy and reproducible sharing of findings from the data. Moreover, bookmarks support optional Markdown-formatted notes that allow communicating essential background information and possible implications related to the discovery.</p>"},{"location":"sample-collections/analyzing/#bookmarks","title":"Bookmarks","text":"<p>GenomeSpy supports two types of bookmarks: pre-defined bookmarks that the visualization author may have included with the visualization and local bookmarks that you can save in your web browser. You can access both types of bookmarks from the bookmark menu (). Additionally, you can remove or edit existing bookmarks through a submenu that appears when you click the ellipsis button ().</p>"},{"location":"sample-collections/analyzing/#sharing","title":"Sharing","text":"<p>The current visualization state is constantly updated to the web browser's address bar, allowing you to quickly share the state with others. However, for better context, GenomeSpy's sharing function provides the option to include a name and notes with the shared state. Additionally, recipients can conveniently import the shared link into their local GenomeSpy bookmarks. You can share the current state by clicking on the Share () button, or share an existing bookmark by selecting the Share option from the bookmark's submenu.</p>"},{"location":"sample-collections/visualizing/","title":"Visualizing Sample Collections","text":"<p>Developer Documentation</p> <p>This page is intended for users who develop tailored visualizations using the GenomeSpy app.</p>"},{"location":"sample-collections/visualizing/#getting-started","title":"Getting started","text":"<p>You can use the following HTML template to create a web page for your visualization. The template loads the app from a content delivery network and the visualization specification from a separate <code>spec.json</code> file placed in the same directory. See the getting started page for more information.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;GenomeSpy&lt;/title&gt;\n    &lt;link\n      rel=\"stylesheet\"\n      type=\"text/css\"\n      href=\"https://cdn.jsdelivr.net/npm/@genome-spy/app@0.51.x/dist/style.css\"\n    /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script\n      type=\"text/javascript\"\n      src=\"https://cdn.jsdelivr.net/npm/@genome-spy/app@0.51.x\"\n    &gt;&lt;/script&gt;\n\n    &lt;script&gt;\n      genomeSpyApp.embed(document.body, \"spec.json\", {\n        // Show the dataflow inspector button in the toolbar (default: true)\n        showInspectorButton: true,\n      });\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>For a complete example, check the website-examples repository on GitHub.</p>"},{"location":"sample-collections/visualizing/#specifying-a-sample-view","title":"Specifying a Sample View","text":"<p>The GenomeSpy app extends the core library with a new view composition operator that allows visualization of multiple samples. In this context, a sample means a set of data objects representing an organism, a piece of tissue, a cell line, a single cell, etc. Each sample gets its own track in the visualization, and the behavior resembles the facet operator of Vega-Lite. However, there are subtle differences in the behavior.</p> <p>A sample view is defined by the <code>samples</code> and <code>spec</code> properties. To assign a track for a data object, define a sample-identifier field using the <code>sample</code> channel. More complex visualizations can be created using the <code>layer</code> operator. Each composed view may have a different data source, enabling concurrent visualization of multiple data types. For instance, the bottom layer could display segmented copy-number data, while the top layer might show single-nucleotide variants.</p> <pre><code>{\n  \"samples\": {\n    // Optional sample identifiers and metadata\n    ...\n  },\n  \"spec\": {\n    // A single or layer specification\n    ...,\n    \"encoding\": {\n      ...,\n      // The sample channel identifies the track\n      \"sample\": {\n        \"field\": \"sampleId\"\n      }\n    }\n  }\n}\n</code></pre> <p>Y axis ticks</p> <p>The Y axis ticks are not available in sample views at the moment. Will be fixed at a later time. However, they would not be particularly practical with high number of samples.</p> <p>But we have Band scale?</p> <p>Superficially similar results can be achieved by using the \"band\" scale on the <code>y</code> channel. However, you can not adjust the intra-band y-position, as the <code>y</code> channel is already reserved for assigning a band for a datum. On the other hand, with the band scale, the graphical marks can span multiple bands. You could, for example, draw lines between the bands.</p>"},{"location":"sample-collections/visualizing/#implicit-sample-identifiers","title":"Implicit sample identifiers","text":"<p>By default, the identifiers of the samples are extracted from the data, and each sample gets its own track.</p>"},{"location":"sample-collections/visualizing/#explicit-sample-identifiers-and-metadata-attributes","title":"Explicit sample identifiers and metadata attributes","text":"<p>Genomic data is commonly supplemented with metadata that contains various clinical and computational annotations. To show such metadata alongside the genomic data as a color-coded heat map, you can provide a <code>data</code> source with sample identifiers and metadata columns.</p> Explicit sample identifiers<pre><code>{\n  \"samples\": {\n    \"data\": { \"url\": \"samples.tsv\" }\n  },\n  \"spec\": {\n    ...\n  }\n}\n</code></pre> <p>The data source must have a <code>sample</code> field matching the sample identifiers used in the genomic data. In addition, an optional <code>displayName</code> field can be provided if the sample names should be shown, for example, in a shortened form. All other fields are shown as metadata attributes, and their data types are inferred automatically from the data: numeric attributes are interpreted as <code>\"quantitative\"</code> data, all others as <code>\"nominal\"</code>.</p> <p>An example of a metadata file (<code>samples.tsv</code>):</p> sample displayName treatment ploidy purity EOC52_pPer_DNA4 EOC52_pPer NACT 3.37 0.29 EOC702_pOme1_DNA1 EOC702_pOme1 PDS 3.74 0.155 EOC912_p2Bow2_DNA1 EOC912_p2Bow2 PDS 3.29 0.53"},{"location":"sample-collections/visualizing/#specifying-data-types-of-metadata-attributes","title":"Specifying data types of metadata attributes","text":"<p>To adjust the data types, scales, and default visibility of the attributes, they can be specified explicitly using the <code>attributes</code> object, as shown in the example below:</p> Specifying a purity attribute<pre><code>{\n  \"samples\": {\n    \"data\": { \"url\": \"samples.tsv\" },\n    \"attributes\": {\n      \"purity\": {\n        \"type\": \"quantitative\",\n        \"scale\": {\n          \"domain\": [0, 1],\n          \"scheme\": \"yellowgreenblue\"\n        },\n        \"barScale\": { },\n        \"visible\": false\n      },\n      ...\n    }\n  },\n  ...\n}\n</code></pre> <p>The <code>scale</code> property specifies a scale for the <code>color</code> channel used to encode the values on the metadata heatmap. The optional <code>barScale</code> property enables positional encoding, changing the heatmap cells into a horizontal bar chart. The <code>visible</code> property configures the default visibility for the attribute.</p>"},{"location":"sample-collections/visualizing/#hierarchical-metadata-attributes","title":"Hierarchical metadata attributes","text":"<p>Metadata attributes can be grouped into hierarchical categories, which is practical when the number of attributes is large. You only need to define the data types and scales for the categories, and the attributes inherit these settings. Moreover, the user can easily toggle the visibility of the entire category with a single checkbox.</p> <p>Suppose you have the following metadata attributes that you would like to configure hierarchically:</p> <ul> <li>patientId</li> <li>Clinical data<ul> <li>PFI</li> <li>OS</li> </ul> </li> <li>Mutational signatures<ul> <li>HRD</li> <li>APOBEC</li> </ul> </li> </ul> <p>To use hierarchical metadata attributes, the attribute names must have a (multi-level) group prefix, where a designated character separates the levels of the hierarchy. Use the <code>attributeGroupSeparator</code> property to delimit attribute names into groups. Then, specify settings for both individual attributes and groups if needed. The <code>visible</code> and <code>title</code> properties are not inherited; they only apply to the group itself.</p>"},{"location":"sample-collections/visualizing/#example","title":"Example","text":"<p>The above-mentioned metadata attributes could be named as follows:</p> <ul> <li><code>patientId</code></li> <li><code>clinical.PFI</code></li> <li><code>clinical.OS</code></li> <li><code>signature.HRD</code></li> <li><code>signature.APOBEC</code></li> </ul> <p>... and configured as follows:</p> Hierarchical metadata attributes<pre><code>{\n  \"samples\": {\n    \"data\": { \"url\": \"samples.tsv\" },\n    \"attributeGroupSeparator\": \".\",\n    \"attributes\": {\n      \"patientId\": {\n        \"type\": \"nominal\"\n      },\n      \"clinical\": {\n        \"type\": \"quantitative\",\n        \"scale\": {\n          \"scheme\": \"blues\"\n        }\n      },\n      \"clinical.OS\": {\n        \"visible\": false\n      },\n      \"signature\": {\n        \"type\": \"quantitative\",\n        \"scale\": { \"scheme\": \"yelloworangered\" },\n        \"visible\": false\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"sample-collections/visualizing/#adjusting-font-sizes-etc","title":"Adjusting font sizes, etc.","text":"<p>The <code>samples</code> object can also be used to adjust the font sizes, etc. of the metadata attributes. For example, to increase the font sizes of the sample and attribute labels, use the following configuration:</p> Adjusting font sizes<pre><code>{\n  \"samples\": {\n    ...,\n    \"labelFontSize\": 12,\n    \"attributeLabelFontSize\": 10\n  },\n  ...\n}\n</code></pre> <p>The following properties allow for fine-grained control of the font styles: <code>labelFont</code>, <code>labelFontSize</code>, <code>labelFontWeight</code>, <code>labelFontStyle</code>, <code>labelAlign</code>, <code>attributeLabelFont</code>, <code>attributeLabelFontSize</code>, <code>attributeLabelFontWeight</code>, <code>attributeLabelFontStyle</code>.</p> <p>In addition, the following properties are supported:</p> <code>labelTitleText</code> The title of the sample labels.<p>Default value: <code>\"Sample name\"</code></p> <code>labelLength</code> The space allocated for the sample labels in pixels.<p>Default value: <code>140</code></p> <code>labelAlign</code> The horizontal alignment of the text. One of <code>\"left\"</code>, <code>\"center\"</code>, or <code>\"right\"</code>.<p>Default value: <code>\"left\"</code></p> <code>attributeSize</code> Default size (width) of the metadata attribute columns. Can be configured per attribute using the <code>attributes</code> property.<p>Default value: <code>10</code></p> <code>attributeLabelAngle</code> Angle to be added to the default label angle (-90).<p>Default value: <code>0</code></p> <code>attributeSpacing</code> Spacing between attribute columns in pixels.<p>Default value: <code>1</code></p>"},{"location":"sample-collections/visualizing/#handling-variable-sample-heights","title":"Handling variable sample heights","text":"<p>The height of a single sample depend on the number of samples and the height of the sample view. Moreover, the end user can toggle between a bird's eye view and a closeup view making the height very dynamic.</p> <p>To adapt the maximum size of <code>\"point\"</code> marks to the height of the samples, you need to specify a dynamic scale range for the <code>size</code> channel. The following example demonstrates how to use expressions and the <code>height</code> parameter to adjust the point size:</p> Dynamic point sizes<pre><code>\"encoding\": {\n  \"size\": {\n    \"field\": \"VAF\",\n    \"type\": \"quantitative\",\n    \"scale\": {\n      \"domain\": [0, 1],\n      \"range\": [\n        { \"expr\": \"0\" },\n        { \"expr\": \"pow(clamp(height * 0.65, 2, 18), 2)\" }\n      ]\n    }\n  },\n  ...\n}\n</code></pre> <p>In this example, the <code>height</code> parameter, provided by the sample view, contains the height of a single sample. By multiplying it with <code>0.65</code>, the points get some padding at the top and bottom. To prevent the points from becoming too small or excessively large, the <code>clamp</code> function is used to limit the point's diameter to a minimum of <code>2</code> and a maximum of <code>18</code> pixels. As the <code>size</code> channel encodes the area, not the diameter of the points, the <code>pow</code> function is used to square the value. The technique shown here is used in the PARPiCL example.</p>"},{"location":"sample-collections/visualizing/#aggregation","title":"Aggregation","text":"<p>TODO</p>"},{"location":"sample-collections/visualizing/#bookmarking","title":"Bookmarking","text":"<p>With the GenomeSpy app, users can save the current visualization state, including scale domains and view visibilities, as bookmarks. These bookmarks are stored in the IndexedDB of the user's web browser. Each database is unique to an origin, which typically refers to the hostname and domain of the web server hosting the visualization. Since the server may host multiple visualizations, each visualization must have a unique ID assigned to it. To enable bookmarking, simply add the <code>specId</code> property with an arbitrary but unique string value to the top-level view. Example:</p> <pre><code>{\n  \"specId\": \"My example visualization\",\n\n  \"vconcat\": { ... },\n  ...\n}\n</code></pre>"},{"location":"sample-collections/visualizing/#pre-defined-bookmarks-and-bookmark-tour","title":"Pre-defined bookmarks and bookmark tour","text":"<p>You may want to provide users with a few pre-defined bookmarks that showcase interesting findings from the data. Since bookmarks support Markdown-formatted notes, you can also explain the implications of the findings and present essential background information.</p> <p>The remote bookmarks feature allows for storing bookmarks in a JSON file on a web server and provides them to users through the bookmark menu. In addition, you can optionally enable the <code>tour</code> function, which automatically opens the first bookmark in the file and allows the user navigate the tour using previous/next buttons.</p>"},{"location":"sample-collections/visualizing/#enabling-remote-bookmarks","title":"Enabling remote bookmarks","text":"View specification<pre><code>{\n  \"bookmarks\": {\n    \"remote\": {\n      \"url\": \"tour.json\",\n      \"tour\": true\n    }\n  },\n\n  \"vconcat\": { ... },\n  ...\n}\n</code></pre> <p>The <code>remote</code> object accepts the following properties:</p> <code>url</code> (string) A URL to the remote bookmark file. <code>initialBookmark</code> (string) Name of the bookmark that should be loaded as the initial state. The bookmark description dialog is shown only if the <code>tour</code> property is set to <code>true</code>. <code>tour</code> (boolean, optional) Should the user be shown a tour of the remote bookmarks when the visualization is launched? If the <code>initialBookmark</code> property is not defined, the tour starts from the first bookmark.<p>Default: <code>false</code></p> <code>afterTourBookmark</code> (string, optional) Name of the bookmark that should be loaded when the user ends the tour. If <code>null</code>, the dialog will be closed and the current state is retained. If undefined, the default state without any performed actions will be loaded."},{"location":"sample-collections/visualizing/#the-bookmark-file","title":"The bookmark file","text":"<p>The remote bookmark file consists of an array of bookmark objects. The easiest way to create such bookmark objects is to create a bookmark in the app and choose Share from the submenu () of the bookmark item. The sharing dialog provides the bookmark in a URL-encoded format and as a JSON object. Just copy-paste the JSON object into the bookmark file to make it available to all users. A simplified example:</p> Bookmark file (tour.json)<pre><code>[\n  {\n    \"name\": \"First bookmark\",\n    \"actions\": [ ... ],\n    ...\n  },\n  {\n    \"name\": \"Second bookmark\",\n    \"actions\": [ ... ],\n    ...\n  }\n]\n</code></pre> <p>Providing the user with an initial state</p> <p>If you want to provide the user with an initial state comprising specific actions performed on the samples, a particular visible genomic region, etc., you can create a bookmark with the desired settings and set the <code>initialBookmark</code> property to the bookmark's name. See the documentation above for details.</p>"},{"location":"sample-collections/visualizing/#toggleable-view-visibility","title":"Toggleable View Visibility","text":"<p>When working with a complex visualization that includes multiple tracks and extensive metadata, it may not always be necessary to display all views simultaneously. The GenomeSpy app offers users the ability to toggle the visibility of nodes within the view hierarchy. This visibility state is also included in shareable links and bookmarks, allowing users to easily access their preferred configurations.</p> <p>Views have two properties for controlling the visibility:</p> <code>visible</code> (boolean) If true, the view is visible. This property can be used to set the default visibility.<p>Default: <code>true</code></p> <code>configurableVisibility</code> (boolean) If true, the visibility is configurable from a menu in the app<p>Configurability requires an explicitly specified <code>name</code>. Views are   addressed by name within their   import scope,   so if you instantiate the same template multiple times, give each   import instance a unique <code>name</code> to make its descendants addressable   for visibility toggles and bookmarks.</p> <p>Default: <code>false</code> for children of <code>layer</code>, <code>true</code> for others</p>"},{"location":"sample-collections/visualizing/#search","title":"Search","text":"<p>The location/search field in the toolbar allows users to quickly navigate to features in the data. To make features searchable, use the <code>search</code> channel on marks that represent the searchable data objects.</p> <p><code>search</code> accepts either a single field definition or an array of field definitions. When multiple fields are provided, a datum matches if any of the fields matches the entered term (case-insensitive exact match).</p> <p>Examples:</p> <pre><code>{\n  ...,\n  \"mark\": \"rect\",\n  \"encoding\": {\n    \"search\": {\n      \"field\": \"geneSymbol\"\n    },\n    ...,\n  },\n  ...\n}\n</code></pre> <pre><code>{\n  ...,\n  \"mark\": \"rect\",\n  \"encoding\": {\n    \"search\": [\n      { \"field\": \"geneSymbol\" },\n      { \"field\": \"geneId\" },\n      { \"field\": \"alias\" }\n    ],\n    ...,\n  },\n  ...\n}\n</code></pre>"},{"location":"sample-collections/visualizing/#a-practical-example","title":"A practical example","text":"<p>Work in progress</p> <p>This part of the documentation is still under construction.  For a live example, check the PARPiCL visualization, which is also available for interactive exploration</p>"}]}