{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 GenomeSpy is an interactive visualization tool for genomic and other data. It provides a declarative grammar for mapping data to visual channels (position, color, etc.) and composing complex visualization from primitive graphical marks ( points , rectangles , etc.). The grammar is heavily inspired by Vega-Lite . The visualizations are rendered using a carefully crafted WebGL-based engine, and thus, GenomeSpy is able to provide fluid interactions and smooth animations for datasets as large as a few million data points. To facilitate exploration of large cohorts of patients and (biological) samples, GenomeSpy supports aggregation and interactive manipulation of large sample sets. Example \u00b6 TODO: A simple example with some sensible, preferably genomic data. About \u00b6 GenomeSpy is developed by Kari Lavikka in The Systems Biology of Drug Resistance in Cancer group at the University of Helsinki .","title":"Introduction"},{"location":"#introduction","text":"GenomeSpy is an interactive visualization tool for genomic and other data. It provides a declarative grammar for mapping data to visual channels (position, color, etc.) and composing complex visualization from primitive graphical marks ( points , rectangles , etc.). The grammar is heavily inspired by Vega-Lite . The visualizations are rendered using a carefully crafted WebGL-based engine, and thus, GenomeSpy is able to provide fluid interactions and smooth animations for datasets as large as a few million data points. To facilitate exploration of large cohorts of patients and (biological) samples, GenomeSpy supports aggregation and interactive manipulation of large sample sets.","title":"Introduction"},{"location":"#example","text":"TODO: A simple example with some sensible, preferably genomic data.","title":"Example"},{"location":"#about","text":"GenomeSpy is developed by Kari Lavikka in The Systems Biology of Drug Resistance in Cancer group at the University of Helsinki .","title":"About"},{"location":"api/","text":"JavaScript API \u00b6 The public JavaScript API is currently quite minimal. Embedding \u00b6 See the getting started page. The API \u00b6 The embed function returns a promise that resolves into an object that provides the current public API. The API is documented in the interface definition . For practical examples on using the API, check the embed-examples package. Embed options \u00b6 The embed function accepts an optional options object. Named data provider \u00b6 See the API definition. Custom tooltip handlers \u00b6 GenomeSpy provides two built-in tooltip handlers. The default handler displays the underlying datum's properties in a table. Property names starting with an underscore are omitted. The values are formatted nicely. The refseqgene handler fetches a summary description for a gene symbol using the Entrez API. For an example, check the RefSeq gene track in this notebook . Handlers are functions that receive the hovered mark's underlying datum and return a promise that resolves into a string, HTMLElement, or lit-html TemplateResult . The function signature: export type TooltipHandler = ( datum : Record < string , any > , mark : Mark , /** Optional parameters from the view specification */ params? : Record < string , any > ) => Promise < string | TemplateResult | HTMLElement > ; Use the tooltipHandlers option to register custom handlers or override the default. See the example below. Examples \u00b6 Overriding the default handler: import { html } from \"lit-html\" ; const options = { tooltipHandlers : { default : async ( datum , mark , props ) => html ` The datum has <strong> ${ Object . keys ( datum ). length } </strong> attributes! ` , }, }; embed ( container , spec , options ); To use a specific (custom) handler in a view specification: { \"mark\" : { \"type\" : \"point\" , \"tooltip\" : { \"handler\" : \"myhandler\" , \"params\" : { \"custom\" : \"param\" } } }, ... }","title":"JavaScript API"},{"location":"api/#javascript-api","text":"The public JavaScript API is currently quite minimal.","title":"JavaScript API"},{"location":"api/#embedding","text":"See the getting started page.","title":"Embedding"},{"location":"api/#the-api","text":"The embed function returns a promise that resolves into an object that provides the current public API. The API is documented in the interface definition . For practical examples on using the API, check the embed-examples package.","title":"The API"},{"location":"api/#embed-options","text":"The embed function accepts an optional options object.","title":"Embed options"},{"location":"api/#named-data-provider","text":"See the API definition.","title":"Named data provider"},{"location":"api/#custom-tooltip-handlers","text":"GenomeSpy provides two built-in tooltip handlers. The default handler displays the underlying datum's properties in a table. Property names starting with an underscore are omitted. The values are formatted nicely. The refseqgene handler fetches a summary description for a gene symbol using the Entrez API. For an example, check the RefSeq gene track in this notebook . Handlers are functions that receive the hovered mark's underlying datum and return a promise that resolves into a string, HTMLElement, or lit-html TemplateResult . The function signature: export type TooltipHandler = ( datum : Record < string , any > , mark : Mark , /** Optional parameters from the view specification */ params? : Record < string , any > ) => Promise < string | TemplateResult | HTMLElement > ; Use the tooltipHandlers option to register custom handlers or override the default. See the example below.","title":"Custom tooltip handlers"},{"location":"api/#examples","text":"Overriding the default handler: import { html } from \"lit-html\" ; const options = { tooltipHandlers : { default : async ( datum , mark , props ) => html ` The datum has <strong> ${ Object . keys ( datum ). length } </strong> attributes! ` , }, }; embed ( container , spec , options ); To use a specific (custom) handler in a view specification: { \"mark\" : { \"type\" : \"point\" , \"tooltip\" : { \"handler\" : \"myhandler\" , \"params\" : { \"custom\" : \"param\" } } }, ... }","title":"Examples"},{"location":"getting-started/","text":"Quick Start \u00b6 Playground \u00b6 The easiest way to try out GenomeSpy is the Playground app , which allows you to experiment with different visualization specifications directly in the web browser. You can load data from publicly accessible web servers or your computer. The app is still rudimentary and does not support saving or sharing visualizations. Observable notebooks \u00b6 You can embed GenomeSpy into an Observable notebook. Please check the GenomeSpy collection for usage examples. Local or remote web server \u00b6 For more serious work, you should use the GenomeSpy JavaScript library to create a web page for the visualization: Create an HTML document (web page) by using the example below Place the visualization spec and your data files into the same directory as the HTML document Copy them onto a web server or start a local web server in the directory Local web server \u00b6 Python comes with an HTTP server module that can be started from command line: python3 -m http.server --bind 127.0.0.1 By default, it serves files from the current working directory. See Python's documentation for details. HTML template \u00b6 The templates below load GenomeSpy from a content delivery network. Because the specification schema and the JavaScript API are not yet 100% stable, it is recommended to use a specific version. Check the latest version! The versions in the examples below may be slightly out of date. The current version is: Stylesheet filename index.css was renamed to style.css in v0.4.0! Load the spec from a file \u00b6 This template loads the spec from the spec.json file. <!DOCTYPE html> < html > < head > < title > GenomeSpy </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"https://unpkg.com/@genome-spy/core@0.14.0/dist/style.css\" /> </ head > < body > < script type = \"text/javascript\" src = \"https://unpkg.com/@genome-spy/core@0.14.0/dist/index.js\" ></ script > < script > genomeSpyEmbed . embed ( document . body , \"spec.json\" , {}); </ script > </ body > </ html > Embed the spec in the HTML document \u00b6 <!DOCTYPE html> < html > < head > < title > GenomeSpy </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"https://unpkg.com/@genome-spy/core@0.14.0/dist/style.css\" /> </ head > < body > < script type = \"text/javascript\" src = \"https://unpkg.com/@genome-spy/core@0.14.0/dist/index.js\" ></ script > < script > const spec = { data : { sequence : { start : 0 , stop : 6.284 , step : 0.39269908169 , as : \"x\" }, }, transform : [{ type : \"formula\" , expr : \"sin(datum.x)\" , as : \"sin\" }], mark : \"point\" , encoding : { x : { field : \"x\" , type : \"quantitative\" }, y : { field : \"sin\" , type : \"quantitative\" }, }, }; genomeSpyEmbed . embed ( document . body , spec , {}); </ script > </ body > </ html >","title":"Getting Started"},{"location":"getting-started/#quick-start","text":"","title":"Quick Start"},{"location":"getting-started/#playground","text":"The easiest way to try out GenomeSpy is the Playground app , which allows you to experiment with different visualization specifications directly in the web browser. You can load data from publicly accessible web servers or your computer. The app is still rudimentary and does not support saving or sharing visualizations.","title":"Playground"},{"location":"getting-started/#observable-notebooks","text":"You can embed GenomeSpy into an Observable notebook. Please check the GenomeSpy collection for usage examples.","title":"Observable notebooks"},{"location":"getting-started/#local-or-remote-web-server","text":"For more serious work, you should use the GenomeSpy JavaScript library to create a web page for the visualization: Create an HTML document (web page) by using the example below Place the visualization spec and your data files into the same directory as the HTML document Copy them onto a web server or start a local web server in the directory","title":"Local or remote web server"},{"location":"getting-started/#local-web-server","text":"Python comes with an HTTP server module that can be started from command line: python3 -m http.server --bind 127.0.0.1 By default, it serves files from the current working directory. See Python's documentation for details.","title":"Local web server"},{"location":"getting-started/#html-template","text":"The templates below load GenomeSpy from a content delivery network. Because the specification schema and the JavaScript API are not yet 100% stable, it is recommended to use a specific version. Check the latest version! The versions in the examples below may be slightly out of date. The current version is: Stylesheet filename index.css was renamed to style.css in v0.4.0!","title":"HTML template"},{"location":"getting-started/#load-the-spec-from-a-file","text":"This template loads the spec from the spec.json file. <!DOCTYPE html> < html > < head > < title > GenomeSpy </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"https://unpkg.com/@genome-spy/core@0.14.0/dist/style.css\" /> </ head > < body > < script type = \"text/javascript\" src = \"https://unpkg.com/@genome-spy/core@0.14.0/dist/index.js\" ></ script > < script > genomeSpyEmbed . embed ( document . body , \"spec.json\" , {}); </ script > </ body > </ html >","title":"Load the spec from a file"},{"location":"getting-started/#embed-the-spec-in-the-html-document","text":"<!DOCTYPE html> < html > < head > < title > GenomeSpy </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"https://unpkg.com/@genome-spy/core@0.14.0/dist/style.css\" /> </ head > < body > < script type = \"text/javascript\" src = \"https://unpkg.com/@genome-spy/core@0.14.0/dist/index.js\" ></ script > < script > const spec = { data : { sequence : { start : 0 , stop : 6.284 , step : 0.39269908169 , as : \"x\" }, }, transform : [{ type : \"formula\" , expr : \"sin(datum.x)\" , as : \"sin\" }], mark : \"point\" , encoding : { x : { field : \"x\" , type : \"quantitative\" }, y : { field : \"sin\" , type : \"quantitative\" }, }, }; genomeSpyEmbed . embed ( document . body , spec , {}); </ script > </ body > </ html >","title":"Embed the spec in the HTML document"},{"location":"license/","text":"License \u00b6 BSD 2-Clause License Copyright (c) 2018-2021 Kari Lavikka Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Contains Code From \u00b6 Vega and Vega-Lite \u00b6 Copyright (c) 2015, University of Washington Interactive Data Lab. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the University of Washington Interactive Data Lab nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. luma.gl \u00b6 Copyright (c) 2015 Uber Technologies, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"BSD 2-Clause License Copyright (c) 2018-2021 Kari Lavikka Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"license/#contains-code-from","text":"","title":"Contains Code From"},{"location":"license/#vega-and-vega-lite","text":"Copyright (c) 2015, University of Washington Interactive Data Lab. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the University of Washington Interactive Data Lab nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Vega and Vega-Lite"},{"location":"license/#lumagl","text":"Copyright (c) 2015 Uber Technologies, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"luma.gl"},{"location":"genomic-data/genomic-coordinates/","text":"Genomic coordinates \u00b6 To allow easy visualization of coordinate-based genomic data, GenomeSpy can concatenate the discrete chromosomes onto a single continuous linear axis. Concatenation needs the sizes and preferred order for the contigs or chromosomes. These are usually provided with a genome assembly. To activate support for genomic coordinates, add the genome property with the name of the assembly to the top level view specification: { \"genome\" : { \"name\" : \"hg38\" }, ... } Only a single genome assembly Currently, a visualization may have only a single globally configured genome. Different genomes for different scales (for x and y axes, for example) will be supported in the future. Supported genomes \u00b6 By default, GenomeSpy loads genomes from the genomespy.app website. The following assemblies are provided: \"hg38\" , \"hg19\" , \"hg18\" , \"mm10\" , \"mm9\" , and \"dm6\" . Custom genomes \u00b6 At minimum, a custom genome needs a list of contigs and their sizes, which can be loaded from a \"chrom.sizes\" file or provided inline. Cytoband and Gene annotation tracks require additional files. As files \u00b6 The baseUrl property specifies the location of genomes: { \"genome\" : { \"name\" : \"hg99\" , \"baseUrl\" : \"https://your.site/genomes/\" }, ... } The directory must have the following structure: hg99/hg99.chrom.sizes hg99/cytoBand.hg99.txt (optional) hg99/refSeq_genes_scored_compressed.hg99.txt (optional) Inline \u00b6 Example: { \"genome\" : { \"contigs\" : [ \"name\" : \"chr3R\" , \"size\" : \"32079331\" , \"name\" : \"chr3L\" , \"size\" : \"28110227\" , \"name\" : \"chr2R\" , \"size\" : \"25286936\" , \"name\" : \"chrX\" , \"size\" : \"23542271\" , \"name\" : \"chr2L\" , \"size\" : \"23513712\" , \"name\" : \"chrY\" , \"size\" : \"3667352\" , \"name\" : \"chr4\" , \"size\" : \"1348131\" , ] }, ... } Cytobands and genome annotations cannot be provided inline. Encoding genomic coordinates \u00b6 When a genome has been specified, you can encode the genomic coordinates conveniently: { ... , \"encoding\" : { \"x\" : { \"chrom\" : \"Chr\" , \"pos\" : \"Pos\" , \"offset\" : -1.0 , \"type\" : \"locus\" }, ... } } The example above specifies that the chromosome and the intra-chromosomal position is read from the \"Chr\" and \"Pos\" fields, respectively. The \"locus\" data type pairs the channel with a \"locus\" scale. However, you can also use the field property with the locus data type. What happens under the hood When the chrom and pos properties are used used in channel definitions, GenomeSpy inserts an implicit linearizeGenomicCoordinate transform into the data flow. The transform introduces a new field that contains a linearized (concatenated) coordinate for the chromosome-position pair. The channel definition is modified to use the new field. In some cases you may want to insert an explicit transform to the data flow to have better control on its behavior. Coordinate counting \u00b6 The offset property allows for aligning and adjusting for different coordinate notations: zero or one based, closed or half-open. The offset is added to the final coordinate. GenomeSpy's \"locus\" scale expects half-open , zero-based coordinates. Read more about coordinates at the UCSC Genome Browser Blog .","title":"Genomic Coordinates"},{"location":"genomic-data/genomic-coordinates/#genomic-coordinates","text":"To allow easy visualization of coordinate-based genomic data, GenomeSpy can concatenate the discrete chromosomes onto a single continuous linear axis. Concatenation needs the sizes and preferred order for the contigs or chromosomes. These are usually provided with a genome assembly. To activate support for genomic coordinates, add the genome property with the name of the assembly to the top level view specification: { \"genome\" : { \"name\" : \"hg38\" }, ... } Only a single genome assembly Currently, a visualization may have only a single globally configured genome. Different genomes for different scales (for x and y axes, for example) will be supported in the future.","title":"Genomic coordinates"},{"location":"genomic-data/genomic-coordinates/#supported-genomes","text":"By default, GenomeSpy loads genomes from the genomespy.app website. The following assemblies are provided: \"hg38\" , \"hg19\" , \"hg18\" , \"mm10\" , \"mm9\" , and \"dm6\" .","title":"Supported genomes"},{"location":"genomic-data/genomic-coordinates/#custom-genomes","text":"At minimum, a custom genome needs a list of contigs and their sizes, which can be loaded from a \"chrom.sizes\" file or provided inline. Cytoband and Gene annotation tracks require additional files.","title":"Custom genomes"},{"location":"genomic-data/genomic-coordinates/#as-files","text":"The baseUrl property specifies the location of genomes: { \"genome\" : { \"name\" : \"hg99\" , \"baseUrl\" : \"https://your.site/genomes/\" }, ... } The directory must have the following structure: hg99/hg99.chrom.sizes hg99/cytoBand.hg99.txt (optional) hg99/refSeq_genes_scored_compressed.hg99.txt (optional)","title":"As files"},{"location":"genomic-data/genomic-coordinates/#inline","text":"Example: { \"genome\" : { \"contigs\" : [ \"name\" : \"chr3R\" , \"size\" : \"32079331\" , \"name\" : \"chr3L\" , \"size\" : \"28110227\" , \"name\" : \"chr2R\" , \"size\" : \"25286936\" , \"name\" : \"chrX\" , \"size\" : \"23542271\" , \"name\" : \"chr2L\" , \"size\" : \"23513712\" , \"name\" : \"chrY\" , \"size\" : \"3667352\" , \"name\" : \"chr4\" , \"size\" : \"1348131\" , ] }, ... } Cytobands and genome annotations cannot be provided inline.","title":"Inline"},{"location":"genomic-data/genomic-coordinates/#encoding-genomic-coordinates","text":"When a genome has been specified, you can encode the genomic coordinates conveniently: { ... , \"encoding\" : { \"x\" : { \"chrom\" : \"Chr\" , \"pos\" : \"Pos\" , \"offset\" : -1.0 , \"type\" : \"locus\" }, ... } } The example above specifies that the chromosome and the intra-chromosomal position is read from the \"Chr\" and \"Pos\" fields, respectively. The \"locus\" data type pairs the channel with a \"locus\" scale. However, you can also use the field property with the locus data type. What happens under the hood When the chrom and pos properties are used used in channel definitions, GenomeSpy inserts an implicit linearizeGenomicCoordinate transform into the data flow. The transform introduces a new field that contains a linearized (concatenated) coordinate for the chromosome-position pair. The channel definition is modified to use the new field. In some cases you may want to insert an explicit transform to the data flow to have better control on its behavior.","title":"Encoding genomic coordinates"},{"location":"genomic-data/genomic-coordinates/#coordinate-counting","text":"The offset property allows for aligning and adjusting for different coordinate notations: zero or one based, closed or half-open. The offset is added to the final coordinate. GenomeSpy's \"locus\" scale expects half-open , zero-based coordinates. Read more about coordinates at the UCSC Genome Browser Blog .","title":"Coordinate counting"},{"location":"genomic-data/tracks/","text":"Provided Genome Tracks \u00b6 Outdated information This functionality is currently broken. The annotations must be imported from external view specifications. GenomeSpy provides two tracks, that are intended to be used with genomic data. To add any of these tracks to your view specification, use the import directive. Cytoband track \u00b6 Name: cytobands Cytoband track displays the cytobands if the genome configuration provides them. Gene annotations \u00b6 Name: geneAnnotation Gene track displays RefSeq gene annotations. As it is impractical to show all 20 000 gene symbols at the same time, gene track uses score-based prioritization to display only the most popular genes of the currently visible region. For profound discussion on the popularity metric, read more in \" The most popular genes in the human genome \" in Nature. To save some precious screen estate, the isoforms of the genes in the provided annotation are unioned. Thus, each gene is displayed as a single \"virtual isoform\" (there are a few exceptions, though). Hovering the gene symbols with the mouse pointer fetches gene summary information from RefSeq and displays it in a tooltip. How the scoring is actually done Follow https://docs.higlass.io/data_preparation.html#gene-annotation-tracks Use utils/compressGeneAnnotations.py to compress the geneAnnotations.bed file. Save the file as refSeq_genes_scored_compressed.GENOME_NAME.txt and place it in the genome directory . Example \u00b6 This example displays cytobands and gene annotations using the hg38 genome assembly. It also imports a COSMIC Cancer Gene Census track from genomespy.app website. { \"genome\" : { \"name\" : \"hg38\" }, \"vconcat\" : [ { \"import\" : { \"name\" : \"cytobands\" } }, { \"import\" : { \"name\" : \"geneAnnotation\" } }, { \"import\" : { \"url\" : \"https://genomespy.app/tracks/cosmic/census_hg38.json\" } } ] }","title":"Tracks"},{"location":"genomic-data/tracks/#provided-genome-tracks","text":"Outdated information This functionality is currently broken. The annotations must be imported from external view specifications. GenomeSpy provides two tracks, that are intended to be used with genomic data. To add any of these tracks to your view specification, use the import directive.","title":"Provided Genome Tracks"},{"location":"genomic-data/tracks/#cytoband-track","text":"Name: cytobands Cytoband track displays the cytobands if the genome configuration provides them.","title":"Cytoband track"},{"location":"genomic-data/tracks/#gene-annotations","text":"Name: geneAnnotation Gene track displays RefSeq gene annotations. As it is impractical to show all 20 000 gene symbols at the same time, gene track uses score-based prioritization to display only the most popular genes of the currently visible region. For profound discussion on the popularity metric, read more in \" The most popular genes in the human genome \" in Nature. To save some precious screen estate, the isoforms of the genes in the provided annotation are unioned. Thus, each gene is displayed as a single \"virtual isoform\" (there are a few exceptions, though). Hovering the gene symbols with the mouse pointer fetches gene summary information from RefSeq and displays it in a tooltip. How the scoring is actually done Follow https://docs.higlass.io/data_preparation.html#gene-annotation-tracks Use utils/compressGeneAnnotations.py to compress the geneAnnotations.bed file. Save the file as refSeq_genes_scored_compressed.GENOME_NAME.txt and place it in the genome directory .","title":"Gene annotations"},{"location":"genomic-data/tracks/#example","text":"This example displays cytobands and gene annotations using the hg38 genome assembly. It also imports a COSMIC Cancer Gene Census track from genomespy.app website. { \"genome\" : { \"name\" : \"hg38\" }, \"vconcat\" : [ { \"import\" : { \"name\" : \"cytobands\" } }, { \"import\" : { \"name\" : \"geneAnnotation\" } }, { \"import\" : { \"url\" : \"https://genomespy.app/tracks/cosmic/census_hg38.json\" } } ] }","title":"Example"},{"location":"genomic-data/examples/ascat/","text":"Visualizing ASCAT profiles \u00b6 This example visualizes an ASCAT profile and an allele-specific copy number segmentation along with the raw LogR and BAF data. The example has been moved to Observable .","title":"ASCAT"},{"location":"genomic-data/examples/ascat/#visualizing-ascat-profiles","text":"This example visualizes an ASCAT profile and an allele-specific copy number segmentation along with the raw LogR and BAF data. The example has been moved to Observable .","title":"Visualizing ASCAT profiles"},{"location":"genomic-data/examples/seg-file/","text":"Visualizing a SEG file \u00b6 Outdated information This example is currently broken because of recent changes made to the sample handling and importing . These examples visualize segmented data with two different visual encodings. The example data consists of segmentations for two samples. Each segment has a chromosome, intra-chromosomal start and end coordinates, and two quantitative values: 'ID chrom loc.start loc.end num.mark seg.mean GenomeWideSNP_416532 1 51598 76187 14 -0.7116 GenomeWideSNP_416532 1 76204 16022502 8510 -0.029 GenomeWideSNP_416532 1 16026084 16026512 6 -2.0424 GenomeWideSNP_416532 1 16026788 17063449 424 -0.1024 ... ... ... ... ... ... Data source: https://software.broadinstitute.org/software/igv/SEG A simple example \u00b6 The following example uses a conventional heatmap ( rect mark) to display the segments. The color scale has been configured to match the Integrative Genomics Viewer . { \"genome\" : { \"name\" : \"hg18\" }, \"concat\" : [ { \"import\" : { \"name\" : \"cytobands\" } }, { \"data\" : { \"url\" : \"example.seg\" , \"format\" : { \"type\" : \"tsv\" } }, \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"chrom\" : \"chrom\" , \"pos\" : \"loc\\\\.start\" , \"type\" : \"quantitative\" }, \"x2\" : { \"chrom\" : \"chrom\" , \"pos\" : \"loc\\\\.end\" }, \"y\" : { \"field\" : \"\\\\'ID\" , \"type\" : \"nominal\" }, \"color\" : { \"field\" : \"seg\\\\.mean\" , \"type\" : \"quantitative\" , \"scale\" : { \"domain\" : [ -1.5 , 1.5 ], \"range\" : [ \"blue\" , \"white\" , \"red\" ] } } } }, { \"import\" : { \"name\" : \"genomeAxis\" } } ] } An advanced example: emphasizing focal segments \u00b6 The data contains focal segments that are short and barely visible. Although zooming reveals them, finding them all requires a lot of effort. The following example uses an alternative visual encoding for the data, emphasizing the focal segments. The quantitative value is encoded as position (height) instead of color. Focal segments are extracted from the data using the filter transform and displayed using point mark. { \"genome\" : { \"name\" : \"hg18\" }, \"concat\" : [ { \"import\" : { \"name\" : \"cytobands\" } }, { \"name\" : \"layers\" , \"data\" : { \"url\" : \"example.seg\" , \"format\" : { \"type\" : \"tsv\" } }, \"encoding\" : { \"sample\" : { \"field\" : \"\\\\'ID\" , \"type\" : \"nominal\" }, \"color\" : { \"field\" : \"seg\\\\.mean\" , \"type\" : \"quantitative\" , \"scale\" : { \"type\" : \"threshold\" , \"domain\" : [ 0 ], \"range\" : [ \"#2277ff\" , \"#dd4422\" ] } }, \"y\" : { \"field\" : \"seg\\\\.mean\" , \"type\" : \"quantitative\" } }, \"layer\" : [ { \"mark\" : { \"type\" : \"rect\" , \"minWidth\" : 1 , \"minOpacity\" : 0.2 }, \"encoding\" : { \"x\" : { \"chrom\" : \"chrom\" , \"pos\" : \"loc\\\\.start\" , \"type\" : \"quantitative\" }, \"x2\" : { \"chrom\" : \"chrom\" , \"pos\" : \"loc\\\\.end\" } } }, { \"transform\" : [ { \"type\" : \"filter\" , \"expr\" : \"datum['loc.end'] - datum['loc.start'] < 8000\" }, { \"type\" : \"formula\" , \"expr\" : \"(datum['loc.start'] + datum['loc.end']) / 2\" , \"as\" : \"centre\" } ], \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"chrom\" : \"chrom\" , \"pos\" : \"centre\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"seg\\\\.mean\" , \"type\" : \"quantitative\" }, \"size\" : { \"value\" : 40 } } } ] }, { \"import\" : { \"name\" : \"genomeAxis\" } } ] }","title":"SEG file"},{"location":"genomic-data/examples/seg-file/#visualizing-a-seg-file","text":"Outdated information This example is currently broken because of recent changes made to the sample handling and importing . These examples visualize segmented data with two different visual encodings. The example data consists of segmentations for two samples. Each segment has a chromosome, intra-chromosomal start and end coordinates, and two quantitative values: 'ID chrom loc.start loc.end num.mark seg.mean GenomeWideSNP_416532 1 51598 76187 14 -0.7116 GenomeWideSNP_416532 1 76204 16022502 8510 -0.029 GenomeWideSNP_416532 1 16026084 16026512 6 -2.0424 GenomeWideSNP_416532 1 16026788 17063449 424 -0.1024 ... ... ... ... ... ... Data source: https://software.broadinstitute.org/software/igv/SEG","title":"Visualizing a SEG file"},{"location":"genomic-data/examples/seg-file/#a-simple-example","text":"The following example uses a conventional heatmap ( rect mark) to display the segments. The color scale has been configured to match the Integrative Genomics Viewer . { \"genome\" : { \"name\" : \"hg18\" }, \"concat\" : [ { \"import\" : { \"name\" : \"cytobands\" } }, { \"data\" : { \"url\" : \"example.seg\" , \"format\" : { \"type\" : \"tsv\" } }, \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"chrom\" : \"chrom\" , \"pos\" : \"loc\\\\.start\" , \"type\" : \"quantitative\" }, \"x2\" : { \"chrom\" : \"chrom\" , \"pos\" : \"loc\\\\.end\" }, \"y\" : { \"field\" : \"\\\\'ID\" , \"type\" : \"nominal\" }, \"color\" : { \"field\" : \"seg\\\\.mean\" , \"type\" : \"quantitative\" , \"scale\" : { \"domain\" : [ -1.5 , 1.5 ], \"range\" : [ \"blue\" , \"white\" , \"red\" ] } } } }, { \"import\" : { \"name\" : \"genomeAxis\" } } ] }","title":"A simple example"},{"location":"genomic-data/examples/seg-file/#an-advanced-example-emphasizing-focal-segments","text":"The data contains focal segments that are short and barely visible. Although zooming reveals them, finding them all requires a lot of effort. The following example uses an alternative visual encoding for the data, emphasizing the focal segments. The quantitative value is encoded as position (height) instead of color. Focal segments are extracted from the data using the filter transform and displayed using point mark. { \"genome\" : { \"name\" : \"hg18\" }, \"concat\" : [ { \"import\" : { \"name\" : \"cytobands\" } }, { \"name\" : \"layers\" , \"data\" : { \"url\" : \"example.seg\" , \"format\" : { \"type\" : \"tsv\" } }, \"encoding\" : { \"sample\" : { \"field\" : \"\\\\'ID\" , \"type\" : \"nominal\" }, \"color\" : { \"field\" : \"seg\\\\.mean\" , \"type\" : \"quantitative\" , \"scale\" : { \"type\" : \"threshold\" , \"domain\" : [ 0 ], \"range\" : [ \"#2277ff\" , \"#dd4422\" ] } }, \"y\" : { \"field\" : \"seg\\\\.mean\" , \"type\" : \"quantitative\" } }, \"layer\" : [ { \"mark\" : { \"type\" : \"rect\" , \"minWidth\" : 1 , \"minOpacity\" : 0.2 }, \"encoding\" : { \"x\" : { \"chrom\" : \"chrom\" , \"pos\" : \"loc\\\\.start\" , \"type\" : \"quantitative\" }, \"x2\" : { \"chrom\" : \"chrom\" , \"pos\" : \"loc\\\\.end\" } } }, { \"transform\" : [ { \"type\" : \"filter\" , \"expr\" : \"datum['loc.end'] - datum['loc.start'] < 8000\" }, { \"type\" : \"formula\" , \"expr\" : \"(datum['loc.start'] + datum['loc.end']) / 2\" , \"as\" : \"centre\" } ], \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"chrom\" : \"chrom\" , \"pos\" : \"centre\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"seg\\\\.mean\" , \"type\" : \"quantitative\" }, \"size\" : { \"value\" : 40 } } } ] }, { \"import\" : { \"name\" : \"genomeAxis\" } } ] }","title":"An advanced example: emphasizing focal segments"},{"location":"grammar/","text":"Visualization Grammar \u00b6 Genome browser applications typically couple the visual representations to specific file formats and provide few customization options. GenomeSpy has a more abstract approach to visualization, providing combinatorial building blocks such as marks , transforms , and scales . Users can author novel visualizations that display the underlying data more effectively. The concept was first introduced in The Grammar of Graphics and developer further in ggplot2 and Vega-Lite . TODO: Quick introduction to view specifications. Meanwhile, have a look at Vega-Lite's view specification documentation to get the general idea. A subset of Vega-Lite The visualization grammar of GenomeSpy is a subset and a dialect of Vega-Lite . However, the goals of GenomeSpy and Vega-Lite are different \u2013 GenomeSpy is more domain specific and is intended for visualization and analysis of large datasets that contain genomic coordinates. GenomeSpy tries to faithfully follow Vega-Lite's grammar where practical. Thus, this documentation has many references to its documentation.","title":"Visualization Grammar"},{"location":"grammar/#visualization-grammar","text":"Genome browser applications typically couple the visual representations to specific file formats and provide few customization options. GenomeSpy has a more abstract approach to visualization, providing combinatorial building blocks such as marks , transforms , and scales . Users can author novel visualizations that display the underlying data more effectively. The concept was first introduced in The Grammar of Graphics and developer further in ggplot2 and Vega-Lite . TODO: Quick introduction to view specifications. Meanwhile, have a look at Vega-Lite's view specification documentation to get the general idea. A subset of Vega-Lite The visualization grammar of GenomeSpy is a subset and a dialect of Vega-Lite . However, the goals of GenomeSpy and Vega-Lite are different \u2013 GenomeSpy is more domain specific and is intended for visualization and analysis of large datasets that contain genomic coordinates. GenomeSpy tries to faithfully follow Vega-Lite's grammar where practical. Thus, this documentation has many references to its documentation.","title":"Visualization Grammar"},{"location":"grammar/data/","text":"Data Input \u00b6 GenomeSpy inputs tabular data as \"csv\" , \"tsv\" , and \"json\" files. Currently, the only supported bioinformatic file format is non-indexed \"fasta\" . Other formats such as BED or BigWig are not directly supported. They must be first converted into one of the above tabular formats. GenomeSpy can load data from external files or use inline data. You can also use generators to generate data on the fly and modify them using transforms . The data property of the view specification describes a data source. The following example loads a tab-delimited file. By default, the format is inferred from the file extension. However, in bioinformatics, CSV files are often actually tab-delimited and the \"tsv\" format must be specified explicitly: { \"data\" : { \"url\" : \"fileWithTabs.csv\" , \"format\" : { \"type\" : \"tsv\" } }, ... } With the exception of the unsupported geographical formats, the data property of GenomeSpy is identical to Vega-Lite's data property. Type inference GenomeSpy uses vega-loader to parse tabular data and infer its data types. Vega-loader is sometimes overly eager to interpret strings as a dates. In such cases, the field types need to be specified explicitly. On the other hand, explicit type specification also gives a significant performance boost to parsing performance. Named Data Sources \u00b6 Data can be added or updated at runtime using the API . Data sources are referenced by a name, which is passed to the updateNamedData method: { \"name\" : \"dynamicData\" } const api = await embed ( \"#container\" , spec ); api . updateNamedData ( \"dynamicData\" , [ { x : 1 , y : 2 }, { x : 2 , y : 3 }, ]); For practical examples, check the embed-examples package. Bioinformatic Formats \u00b6 FASTA \u00b6 The type of FASTA format is \"fasta\" as shown in the example below: { \"data\" : { \"url\" : \"16SRNA_Deino_87seq_copy.aln\" , \"format\" : { \"type\" : \"fasta\" } }, ... } The FASTA loader produces data objects with two fields: \"identifier\" and \"sequence\" . With the \"flattenSequence\" transform you can split the sequences into individual bases (one object per base) for easier visualization.","title":"Data Input"},{"location":"grammar/data/#data-input","text":"GenomeSpy inputs tabular data as \"csv\" , \"tsv\" , and \"json\" files. Currently, the only supported bioinformatic file format is non-indexed \"fasta\" . Other formats such as BED or BigWig are not directly supported. They must be first converted into one of the above tabular formats. GenomeSpy can load data from external files or use inline data. You can also use generators to generate data on the fly and modify them using transforms . The data property of the view specification describes a data source. The following example loads a tab-delimited file. By default, the format is inferred from the file extension. However, in bioinformatics, CSV files are often actually tab-delimited and the \"tsv\" format must be specified explicitly: { \"data\" : { \"url\" : \"fileWithTabs.csv\" , \"format\" : { \"type\" : \"tsv\" } }, ... } With the exception of the unsupported geographical formats, the data property of GenomeSpy is identical to Vega-Lite's data property. Type inference GenomeSpy uses vega-loader to parse tabular data and infer its data types. Vega-loader is sometimes overly eager to interpret strings as a dates. In such cases, the field types need to be specified explicitly. On the other hand, explicit type specification also gives a significant performance boost to parsing performance.","title":"Data Input"},{"location":"grammar/data/#named-data-sources","text":"Data can be added or updated at runtime using the API . Data sources are referenced by a name, which is passed to the updateNamedData method: { \"name\" : \"dynamicData\" } const api = await embed ( \"#container\" , spec ); api . updateNamedData ( \"dynamicData\" , [ { x : 1 , y : 2 }, { x : 2 , y : 3 }, ]); For practical examples, check the embed-examples package.","title":"Named Data Sources"},{"location":"grammar/data/#bioinformatic-formats","text":"","title":"Bioinformatic Formats"},{"location":"grammar/data/#fasta","text":"The type of FASTA format is \"fasta\" as shown in the example below: { \"data\" : { \"url\" : \"16SRNA_Deino_87seq_copy.aln\" , \"format\" : { \"type\" : \"fasta\" } }, ... } The FASTA loader produces data objects with two fields: \"identifier\" and \"sequence\" . With the \"flattenSequence\" transform you can split the sequences into individual bases (one object per base) for easier visualization.","title":"FASTA"},{"location":"grammar/expressions/","text":"Expressions \u00b6 Expressions allow for defining predicates or computing new variables based on existing data. The expression language is based on JavaScript, but provides only a limited set of features, guaranteeing secure execution. Expressions can be used with the \"filter\" and \"formula\" transforms. Usage \u00b6 All basic arithmetic operators are supported: ( 1 + 2 ) * 3 / 4 The current data object is provided as the datum object. Its properties (fields) can be accessed by using the dot or bracket notation: datum . foo + 2 If the name of the property contains special characters such as \" . \", \" ! \", or \" \" (a space) the bracket notation must be used: datum [ 'A very *special* name!' ] > 100 Conditional operators \u00b6 Ternary operator: datum . foo < 5 ? 'small' : 'large' And an equivalent if construct: if ( datum . foo < 5 , 'small' , 'large' ) Provided constants and functions \u00b6 Common mathematical functions are supported: ( datum . u % 1e-8 > 5e-9 ? 1 : - 1 ) * ( sqrt ( - log ( max ( 1e-9 , datum . u ))) - 0.618 ) * 1.618 The full list of built-in constants and functions are documented in vega-expression .","title":"Expressions"},{"location":"grammar/expressions/#expressions","text":"Expressions allow for defining predicates or computing new variables based on existing data. The expression language is based on JavaScript, but provides only a limited set of features, guaranteeing secure execution. Expressions can be used with the \"filter\" and \"formula\" transforms.","title":"Expressions"},{"location":"grammar/expressions/#usage","text":"All basic arithmetic operators are supported: ( 1 + 2 ) * 3 / 4 The current data object is provided as the datum object. Its properties (fields) can be accessed by using the dot or bracket notation: datum . foo + 2 If the name of the property contains special characters such as \" . \", \" ! \", or \" \" (a space) the bracket notation must be used: datum [ 'A very *special* name!' ] > 100","title":"Usage"},{"location":"grammar/expressions/#conditional-operators","text":"Ternary operator: datum . foo < 5 ? 'small' : 'large' And an equivalent if construct: if ( datum . foo < 5 , 'small' , 'large' )","title":"Conditional operators"},{"location":"grammar/expressions/#provided-constants-and-functions","text":"Common mathematical functions are supported: ( datum . u % 1e-8 > 5e-9 ? 1 : - 1 ) * ( sqrt ( - log ( max ( 1e-9 , datum . u ))) - 0.618 ) * 1.618 The full list of built-in constants and functions are documented in vega-expression .","title":"Provided constants and functions"},{"location":"grammar/import/","text":"Importing Views \u00b6 GenomeSpy facilitates reusing views by allowing them to be imported from external specification files. The files can be placed flexibly \u2013 it may be practical to split large specifications into multiple files and put them in the same directory. On the other hand, if you have created, for example, an annotation track that you would like the share with the research community, you can upload the specification file and the associated data to a publicly accessible web server. Importing named tracks \u00b6 Currently unsupported Named imports are currently not supported. Will be back at some point. GenomeSpy provides a few built-in tracks, mainly to support genomic data exploration. They must be imported by a name. Read more at genome tracks . Usage: { ... , \"concat\" : [ ... , { \"import\" : { \"name\" : \"cytobands\" } } ] } Importing from a URL \u00b6 You can also import views from relative or absolute URLs. Relative URLs are imported with respect to the current baseUrl . (TODO: Document baseUrl somewhere) The imported specification may contain a single, concatenated, or layered view. The baseUrl of the imported specification is updated to match its directory. Thus, you can publish a view (or track as known in genome browsers) by placing its specification and data available in the same directory on a web server. Usage: { ... , \"vconcat\" : [ ... , { \"import\" : { \"url\" : \"includes/annotations.json\" } }, { \"import\" : { \"url\" : \"https://genomespy.app/tracks/cosmic/census_hg38.json\" } } ] }","title":"Importing Views"},{"location":"grammar/import/#importing-views","text":"GenomeSpy facilitates reusing views by allowing them to be imported from external specification files. The files can be placed flexibly \u2013 it may be practical to split large specifications into multiple files and put them in the same directory. On the other hand, if you have created, for example, an annotation track that you would like the share with the research community, you can upload the specification file and the associated data to a publicly accessible web server.","title":"Importing Views"},{"location":"grammar/import/#importing-named-tracks","text":"Currently unsupported Named imports are currently not supported. Will be back at some point. GenomeSpy provides a few built-in tracks, mainly to support genomic data exploration. They must be imported by a name. Read more at genome tracks . Usage: { ... , \"concat\" : [ ... , { \"import\" : { \"name\" : \"cytobands\" } } ] }","title":"Importing named tracks"},{"location":"grammar/import/#importing-from-a-url","text":"You can also import views from relative or absolute URLs. Relative URLs are imported with respect to the current baseUrl . (TODO: Document baseUrl somewhere) The imported specification may contain a single, concatenated, or layered view. The baseUrl of the imported specification is updated to match its directory. Thus, you can publish a view (or track as known in genome browsers) by placing its specification and data available in the same directory on a web server. Usage: { ... , \"vconcat\" : [ ... , { \"import\" : { \"url\" : \"includes/annotations.json\" } }, { \"import\" : { \"url\" : \"https://genomespy.app/tracks/cosmic/census_hg38.json\" } } ] }","title":"Importing from a URL"},{"location":"grammar/samples/","text":"Faceting Multiple Samples \u00b6 Work in progress This part of the documentation is under construction and some features are still a bit unstable. For a live example, check the PARPiCL visualization. GenomeSpy supports visualization and interactive manipulation of large sample sets using a track-based layout. The samples operator splits (facets) the data into groups and displays each group as a track. The same view specification together with shared scales is used for all groups. This is also known as small multiples, conditioning, or trellising. The sample view scales to thousands of samples. You can look at a birds-eye view of the whole sample set and rapidly peek (zoom) into a few interesting samples. The interactive sorting, filtering, and grouping allows for analyzing patterns and outliers in the data. Usage \u00b6 A sample view is defined by the samples and spec properties. To assign a track for a data object, define a sample-identifier field using the sample channel. Layered views can flexibly use multiple data sources with different sample fields. { \"samples\" : { // Explicit sample indentifiers and optional metadata ... }, \"spec\" : { // A single or layer specification ... , \"encoding\" : { ... , \"sample\" : { \"field\" : \"sampleId\" , \"type\" : \"nominal\" } } } } Multidimensional data The sample view can flexibly display multidimensional data. For instance, copy numbers and point mutations of multiple samples can be shown at the same time. Y axis ticks The Y axis ticks are not available on faceted views at the moment. Will be fixed at a later time. But we have Band scale? Superficially similar results can be achieved by using the \"band\" scale on the y channel. However, you can not adjust the intra-band y-position, as the y channel is already reserved for assigning a band for a datum. On the other hand, with the band scale, the graphical marks can span multiple bands. You could, for example, draw lines between the bands. Explicit sample identifiers and attributes \u00b6 By default, the identifiers of the samples (groups) are extracted from the data. (That's currently broken, sorry). However, you can also explicitly specify the sample ids along with optional metadata attributes such as various clinical data. The attributes are shown as color-coded columns in the left axis area. The user can use these attributes to interactively filter , group, and sort the samples. The associated data must contain a sample column, which identifies the sample. All other columns are interpreted as attributes. By default, the attribute data types are inferred from the data; numeric attributes are interpreted as quantitative data, all others as nominal . To adjust the data types and scales , the attributes can be specified explicitly as shown in the example below: { \"samples\" : { \"data\" : { \"url\" : \"samples.tsv\" }, \"attributes\" : { \"RIN_Qual\" : { \"type\" : \"ordinal\" , \"scale\" : { \"domain\" : [ \"<5UQ\" , \"5-7UQ\" , \"5-7R\" , \">7R\" , \">7Q\" ], \"scheme\" : \"orangered\" } }, ... } }, ... } Aggregation \u00b6 TODO Interactions \u00b6 Peeking \u00b6 GenomeSpy is designed to handle up to thousands of concurrently visible samples. In order to see phenomena that span multiple samples, the whole sample set is shown at the same time. To focus on a few specific samples, you can activate the peek tool by pressing and holding the e key on the keyboard. You can try it in the example below: TODO { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 1000 } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"'sample-' + floor(random() * 100)\" , \"as\" : \"sample\" }, { \"type\" : \"formula\" , \"expr\" : \"floor(random() * 20)\" , \"as\" : \"x\" }, { \"type\" : \"stack\" , \"field\" : \"x\" , \"groupby\" : [ \"sample\" ], \"offset\" : \"normalize\" , \"sort\" : { \"field\" : \"x\" } } ], \"mark\" : \"rect\" , \"encoding\" : { \"sample\" : { \"field\" : \"sample\" , \"type\" : \"nominal\" }, \"x\" : { \"field\" : \"y0\" , \"type\" : \"quantitative\" }, \"x2\" : { \"field\" : \"y1\" , \"type\" : \"quantitative\" }, \"color\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" } } } Sorting \u00b6 Samples can be interactively sorted by sample-specific attributes and the actual data. By sample-specific attributes \u00b6 You can sort the samples by clicking the labels of the attributes. TODO: A link to a visualization By the actual data \u00b6 TODO: How to sort Screenshot of the context-menu How to specify Grouping \u00b6 TODO Filtering \u00b6 SampleTrack also allows for interactive filtering of the samples. To filter, open a context-menu by clicking on the attributes with the right mouse button: Retain first sample of each Your data may have, for example, multiple samples from each patient. However, you might want to study only the \"best\" or \"worst\" samples from each patient and compare them with each other. This action groups the samples by the chosen attribute and drops all but the topmost sample of each group. Thus, you can first sort the samples by an attribute that ranks them and then retain only the top ranked samples. Retain TODO Remove TODO GenomeSpy maintains a history of the visible samples and their orders. To return to the previous state, click the backtrack (TODO: picture) button or press the backspace key on the keyboard. TODO: Provide an interactive example right here","title":"Samples"},{"location":"grammar/samples/#faceting-multiple-samples","text":"Work in progress This part of the documentation is under construction and some features are still a bit unstable. For a live example, check the PARPiCL visualization. GenomeSpy supports visualization and interactive manipulation of large sample sets using a track-based layout. The samples operator splits (facets) the data into groups and displays each group as a track. The same view specification together with shared scales is used for all groups. This is also known as small multiples, conditioning, or trellising. The sample view scales to thousands of samples. You can look at a birds-eye view of the whole sample set and rapidly peek (zoom) into a few interesting samples. The interactive sorting, filtering, and grouping allows for analyzing patterns and outliers in the data.","title":"Faceting Multiple Samples"},{"location":"grammar/samples/#usage","text":"A sample view is defined by the samples and spec properties. To assign a track for a data object, define a sample-identifier field using the sample channel. Layered views can flexibly use multiple data sources with different sample fields. { \"samples\" : { // Explicit sample indentifiers and optional metadata ... }, \"spec\" : { // A single or layer specification ... , \"encoding\" : { ... , \"sample\" : { \"field\" : \"sampleId\" , \"type\" : \"nominal\" } } } } Multidimensional data The sample view can flexibly display multidimensional data. For instance, copy numbers and point mutations of multiple samples can be shown at the same time. Y axis ticks The Y axis ticks are not available on faceted views at the moment. Will be fixed at a later time. But we have Band scale? Superficially similar results can be achieved by using the \"band\" scale on the y channel. However, you can not adjust the intra-band y-position, as the y channel is already reserved for assigning a band for a datum. On the other hand, with the band scale, the graphical marks can span multiple bands. You could, for example, draw lines between the bands.","title":"Usage"},{"location":"grammar/samples/#explicit-sample-identifiers-and-attributes","text":"By default, the identifiers of the samples (groups) are extracted from the data. (That's currently broken, sorry). However, you can also explicitly specify the sample ids along with optional metadata attributes such as various clinical data. The attributes are shown as color-coded columns in the left axis area. The user can use these attributes to interactively filter , group, and sort the samples. The associated data must contain a sample column, which identifies the sample. All other columns are interpreted as attributes. By default, the attribute data types are inferred from the data; numeric attributes are interpreted as quantitative data, all others as nominal . To adjust the data types and scales , the attributes can be specified explicitly as shown in the example below: { \"samples\" : { \"data\" : { \"url\" : \"samples.tsv\" }, \"attributes\" : { \"RIN_Qual\" : { \"type\" : \"ordinal\" , \"scale\" : { \"domain\" : [ \"<5UQ\" , \"5-7UQ\" , \"5-7R\" , \">7R\" , \">7Q\" ], \"scheme\" : \"orangered\" } }, ... } }, ... }","title":"Explicit sample identifiers and attributes"},{"location":"grammar/samples/#aggregation","text":"TODO","title":"Aggregation"},{"location":"grammar/samples/#interactions","text":"","title":"Interactions"},{"location":"grammar/samples/#peeking","text":"GenomeSpy is designed to handle up to thousands of concurrently visible samples. In order to see phenomena that span multiple samples, the whole sample set is shown at the same time. To focus on a few specific samples, you can activate the peek tool by pressing and holding the e key on the keyboard. You can try it in the example below: TODO { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 1000 } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"'sample-' + floor(random() * 100)\" , \"as\" : \"sample\" }, { \"type\" : \"formula\" , \"expr\" : \"floor(random() * 20)\" , \"as\" : \"x\" }, { \"type\" : \"stack\" , \"field\" : \"x\" , \"groupby\" : [ \"sample\" ], \"offset\" : \"normalize\" , \"sort\" : { \"field\" : \"x\" } } ], \"mark\" : \"rect\" , \"encoding\" : { \"sample\" : { \"field\" : \"sample\" , \"type\" : \"nominal\" }, \"x\" : { \"field\" : \"y0\" , \"type\" : \"quantitative\" }, \"x2\" : { \"field\" : \"y1\" , \"type\" : \"quantitative\" }, \"color\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" } } }","title":"Peeking"},{"location":"grammar/samples/#sorting","text":"Samples can be interactively sorted by sample-specific attributes and the actual data.","title":"Sorting"},{"location":"grammar/samples/#by-sample-specific-attributes","text":"You can sort the samples by clicking the labels of the attributes. TODO: A link to a visualization","title":"By sample-specific attributes"},{"location":"grammar/samples/#by-the-actual-data","text":"TODO: How to sort Screenshot of the context-menu How to specify","title":"By the actual data"},{"location":"grammar/samples/#grouping","text":"TODO","title":"Grouping"},{"location":"grammar/samples/#filtering","text":"SampleTrack also allows for interactive filtering of the samples. To filter, open a context-menu by clicking on the attributes with the right mouse button: Retain first sample of each Your data may have, for example, multiple samples from each patient. However, you might want to study only the \"best\" or \"worst\" samples from each patient and compare them with each other. This action groups the samples by the chosen attribute and drops all but the topmost sample of each group. Thus, you can first sort the samples by an attribute that ranks them and then retain only the top ranked samples. Retain TODO Remove TODO GenomeSpy maintains a history of the visible samples and their orders. To return to the previous state, click the backtrack (TODO: picture) button or press the backspace key on the keyboard. TODO: Provide an interactive example right here","title":"Filtering"},{"location":"grammar/scale/","text":"Scale \u00b6 Scales are functions that map abstract values (e.g., a type of a point mutation) in the data to visual values (e.g., colors that indicate the type). By default, GenomeSpy configures scales automatically, based on the data type (e.g., \"ordinal\" ), visual channel, and the data domain. The defaults may not always be optimal, and you can configure them by yourself. Vega-Lite scales \u00b6 GenomeSpy implements the majority of the scale types of Vega-Lite . The aim is to replicate their behavior identically (unless stated otherwise) in GenomeSpy. Although that has not yet fully materialized, Vega-Lite's scale documentation generally applies to GenomeSpy as well. The supported scales are: \"linear\" , \"pow\" , \"sqrt\" , \"symlog\" , \"log\" , \"ordinal\" , \"band\" , \"point\" , \"quantize\" , and \"threshold\" . Disabled scale is supported on quantitative channels such as x and opacity . Currently, the following scales are not supported: \"time\" , \"utc\" , \"quantile\" , \"bin-linear\" , \"bin-ordinal\" . Also, the sort property that allows for sorting the domain values is yet to be implemented. Relation to Vega scales In fact, GenomeSpy uses Vega scales , which are based on d3-scale . However, GenomeSpy has GPU-based implementations for the actual scale transformations. GenomeSpy-specific scales \u00b6 GenomeSpy provides two additional scales that are designed for molecular sequence data. Index scale \u00b6 The \"index\" scale allows mapping index-based values such as nucleotide or amino-acid locations to positional visual channels. It has traits from both the continuous \"linear\" and the discrete \"band\" scale. It is linear and zoomable but maps indices to the range like the band scale does \u2013 each index has its own band. Properties such as padding work just as in the band scale. The indices must be zero-based, i.e., the counting must start from zero. The numbering of the axis labels can be adjusted to give an impression of, for example, one-based indexing. The index scale is used by default when the field type is \"index\" . Point indices \u00b6 When only the primary positional channel is defined, marks such as \"rect\" fill the whole band. { \"data\" : { \"values\" : [ 0 , 2 , 4 , 7 , 8 , 10 , 12 ] }, \"encoding\" : { \"x\" : { \"field\" : \"data\" , \"type\" : \"index\" } }, \"layer\" : [ { \"mark\" : \"rect\" , \"encoding\" : { \"color\" : { \"field\" : \"data\" , \"type\" : \"nominal\" } } }, { \"mark\" : \"text\" , \"encoding\" : { \"text\" : { \"field\" : \"data\" , \"type\" : \"quantitative\" } } } ] } Marks such as \"point\" that do not support the secondary positional channel are centered. { \"data\" : { \"values\" : [ 0 , 2 , 4 , 7 , 8 , 10 , 12 ] }, \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"data\" , \"type\" : \"index\" }, \"color\" : { \"field\" : \"data\" , \"type\" : \"nominal\" }, \"size\" : { \"value\" : 300 } } } Range indices \u00b6 When the index scale is used with ranges, e.g., a \"rect\" mark that has both the x and x2 channels defined, the ranges must be half open . For example, if a segment should cover the indices 2, 3, and 4, a half-open range would be defined as: x = 2 (inclusive), x2 = 5 (exclusive). { \"data\" : { \"values\" : [ { \"from\" : 0 , \"to\" : 2 }, { \"from\" : 2 , \"to\" : 5 }, { \"from\" : 8 , \"to\" : 9 }, { \"from\" : 10 , \"to\" : 13 } ] }, \"encoding\" : { \"x\" : { \"field\" : \"from\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"to\" } }, \"layer\" : [ { \"mark\" : \"rect\" , \"encoding\" : { \"color\" : { \"field\" : \"from\" , \"type\" : \"nominal\" } } }, { \"mark\" : \"text\" , \"encoding\" : { \"text\" : { \"expr\" : \"'[' + datum.from + ', ' + datum.to + ')'\" , \"type\" : \"nominal\" } } } ] } Adjusting the indexing of axis labels \u00b6 The index scale expects zero-based indexing. However, it may be desirable to display the axis labels using one-based indexing. Use the numberingOffset property adjust the label indices. { \"data\" : { \"values\" : [ 0 , 2 , 4 , 7 , 8 , 10 , 12 ] }, \"encoding\" : { \"x\" : { \"field\" : \"data\" , \"type\" : \"index\" , \"scale\" : { \"numberingOffset\" : 1 } } }, \"layer\" : [ { \"mark\" : \"rect\" , \"encoding\" : { \"color\" : { \"field\" : \"data\" , \"type\" : \"nominal\" } } }, { \"mark\" : \"text\" , \"encoding\" : { \"text\" : { \"field\" : \"data\" , \"type\" : \"quantitative\" } } } ] } Locus scale \u00b6 The \"locus\" scale is similar to the \"index\" scale, but provides a genome-aware axis with concatenated chromosomes. To use the locus scale, a genome must be specified. The locus scale is used by default when the field type is \"locus\" . Note The locus scale does not map the discrete chromosomes onto the concatenated axis. It's done by the linearizeGenomicCoordinate transform. Specifying the domain \u00b6 By default, the domain of the locus scale consists of the whole genome. However, You can specify a custom domain using either linearized or genomic coordinates. A genomic coordinate consists of a chromosome ( chrom ) and an optional position ( pos ). The left bound's position defaults to zero, whereas the right bound's position defaults to the size of the chromosome. Thus, the chromosomes are inclusive. For example, chromosomes 3, 4, and 5: [{ \"chrom\" : \"chr3\" }, { \"chrom\" : \"chr5\" }] Only the chromosome 3: [{ \"chrom\" : \"chr3\" }] A specific region inside the chromosome 3: [ { \"chrom\" : \"chr3\" , \"pos\" : 1000000 }, { \"chrom\" : \"chr3\" , \"pos\" : 2000000 } ] Somewhere inside the chromosome 1: [ 1000000 , 2000000 ] Example \u00b6 { \"genome\" : { \"name\" : \"hg38\" }, \"data\" : { \"values\" : [ { \"chrom\" : \"chr3\" , \"pos\" : 134567890 }, { \"chrom\" : \"chr4\" , \"pos\" : 123456789 }, { \"chrom\" : \"chr9\" , \"pos\" : 34567890 } ] }, \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"chrom\" : \"chrom\" , \"pos\" : \"pos\" , \"type\" : \"locus\" , \"scale\" : { \"domain\" : [{ \"chrom\" : \"chr3\" }, { \"chrom\" : \"chr9\" }] } }, \"size\" : { \"value\" : 200 } } } Zooming and panning \u00b6 To enable zooming and panning of continuous scales on positional channels, set the zoom scale property to true . Example: { \"x\" : { \"field\" : \"foo\" , \"type\" : \"quantitative\" , \"scale\" : { \"zoom\" : true } } } Both \"index\" and \"locus\" scales are zoomable by default. Zoom extent \u00b6 The zoom extent allows you to control how far the scale can be zoomed out or panned (translated). Zoom extent equals the scale domain by default, except for the \"locus\" scale, where it includes the whole genome. Example: { ... , \"scale\" : { \"domain\" : [ 10 , 20 ], \"zoom\" : { \"extent\" : [ 0 , 30 ] } } } Named scales \u00b6 By giving the scale a name, it can be accessed through the API . { ... , \"scale\" : { \"name\" : \"myScale\" } }","title":"Scales"},{"location":"grammar/scale/#scale","text":"Scales are functions that map abstract values (e.g., a type of a point mutation) in the data to visual values (e.g., colors that indicate the type). By default, GenomeSpy configures scales automatically, based on the data type (e.g., \"ordinal\" ), visual channel, and the data domain. The defaults may not always be optimal, and you can configure them by yourself.","title":"Scale"},{"location":"grammar/scale/#vega-lite-scales","text":"GenomeSpy implements the majority of the scale types of Vega-Lite . The aim is to replicate their behavior identically (unless stated otherwise) in GenomeSpy. Although that has not yet fully materialized, Vega-Lite's scale documentation generally applies to GenomeSpy as well. The supported scales are: \"linear\" , \"pow\" , \"sqrt\" , \"symlog\" , \"log\" , \"ordinal\" , \"band\" , \"point\" , \"quantize\" , and \"threshold\" . Disabled scale is supported on quantitative channels such as x and opacity . Currently, the following scales are not supported: \"time\" , \"utc\" , \"quantile\" , \"bin-linear\" , \"bin-ordinal\" . Also, the sort property that allows for sorting the domain values is yet to be implemented. Relation to Vega scales In fact, GenomeSpy uses Vega scales , which are based on d3-scale . However, GenomeSpy has GPU-based implementations for the actual scale transformations.","title":"Vega-Lite scales"},{"location":"grammar/scale/#genomespy-specific-scales","text":"GenomeSpy provides two additional scales that are designed for molecular sequence data.","title":"GenomeSpy-specific scales"},{"location":"grammar/scale/#index-scale","text":"The \"index\" scale allows mapping index-based values such as nucleotide or amino-acid locations to positional visual channels. It has traits from both the continuous \"linear\" and the discrete \"band\" scale. It is linear and zoomable but maps indices to the range like the band scale does \u2013 each index has its own band. Properties such as padding work just as in the band scale. The indices must be zero-based, i.e., the counting must start from zero. The numbering of the axis labels can be adjusted to give an impression of, for example, one-based indexing. The index scale is used by default when the field type is \"index\" .","title":"Index scale"},{"location":"grammar/scale/#point-indices","text":"When only the primary positional channel is defined, marks such as \"rect\" fill the whole band. { \"data\" : { \"values\" : [ 0 , 2 , 4 , 7 , 8 , 10 , 12 ] }, \"encoding\" : { \"x\" : { \"field\" : \"data\" , \"type\" : \"index\" } }, \"layer\" : [ { \"mark\" : \"rect\" , \"encoding\" : { \"color\" : { \"field\" : \"data\" , \"type\" : \"nominal\" } } }, { \"mark\" : \"text\" , \"encoding\" : { \"text\" : { \"field\" : \"data\" , \"type\" : \"quantitative\" } } } ] } Marks such as \"point\" that do not support the secondary positional channel are centered. { \"data\" : { \"values\" : [ 0 , 2 , 4 , 7 , 8 , 10 , 12 ] }, \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"data\" , \"type\" : \"index\" }, \"color\" : { \"field\" : \"data\" , \"type\" : \"nominal\" }, \"size\" : { \"value\" : 300 } } }","title":"Point indices"},{"location":"grammar/scale/#range-indices","text":"When the index scale is used with ranges, e.g., a \"rect\" mark that has both the x and x2 channels defined, the ranges must be half open . For example, if a segment should cover the indices 2, 3, and 4, a half-open range would be defined as: x = 2 (inclusive), x2 = 5 (exclusive). { \"data\" : { \"values\" : [ { \"from\" : 0 , \"to\" : 2 }, { \"from\" : 2 , \"to\" : 5 }, { \"from\" : 8 , \"to\" : 9 }, { \"from\" : 10 , \"to\" : 13 } ] }, \"encoding\" : { \"x\" : { \"field\" : \"from\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"to\" } }, \"layer\" : [ { \"mark\" : \"rect\" , \"encoding\" : { \"color\" : { \"field\" : \"from\" , \"type\" : \"nominal\" } } }, { \"mark\" : \"text\" , \"encoding\" : { \"text\" : { \"expr\" : \"'[' + datum.from + ', ' + datum.to + ')'\" , \"type\" : \"nominal\" } } } ] }","title":"Range indices"},{"location":"grammar/scale/#adjusting-the-indexing-of-axis-labels","text":"The index scale expects zero-based indexing. However, it may be desirable to display the axis labels using one-based indexing. Use the numberingOffset property adjust the label indices. { \"data\" : { \"values\" : [ 0 , 2 , 4 , 7 , 8 , 10 , 12 ] }, \"encoding\" : { \"x\" : { \"field\" : \"data\" , \"type\" : \"index\" , \"scale\" : { \"numberingOffset\" : 1 } } }, \"layer\" : [ { \"mark\" : \"rect\" , \"encoding\" : { \"color\" : { \"field\" : \"data\" , \"type\" : \"nominal\" } } }, { \"mark\" : \"text\" , \"encoding\" : { \"text\" : { \"field\" : \"data\" , \"type\" : \"quantitative\" } } } ] }","title":"Adjusting the indexing of axis labels"},{"location":"grammar/scale/#locus-scale","text":"The \"locus\" scale is similar to the \"index\" scale, but provides a genome-aware axis with concatenated chromosomes. To use the locus scale, a genome must be specified. The locus scale is used by default when the field type is \"locus\" . Note The locus scale does not map the discrete chromosomes onto the concatenated axis. It's done by the linearizeGenomicCoordinate transform.","title":"Locus scale"},{"location":"grammar/scale/#specifying-the-domain","text":"By default, the domain of the locus scale consists of the whole genome. However, You can specify a custom domain using either linearized or genomic coordinates. A genomic coordinate consists of a chromosome ( chrom ) and an optional position ( pos ). The left bound's position defaults to zero, whereas the right bound's position defaults to the size of the chromosome. Thus, the chromosomes are inclusive. For example, chromosomes 3, 4, and 5: [{ \"chrom\" : \"chr3\" }, { \"chrom\" : \"chr5\" }] Only the chromosome 3: [{ \"chrom\" : \"chr3\" }] A specific region inside the chromosome 3: [ { \"chrom\" : \"chr3\" , \"pos\" : 1000000 }, { \"chrom\" : \"chr3\" , \"pos\" : 2000000 } ] Somewhere inside the chromosome 1: [ 1000000 , 2000000 ]","title":"Specifying the domain"},{"location":"grammar/scale/#example","text":"{ \"genome\" : { \"name\" : \"hg38\" }, \"data\" : { \"values\" : [ { \"chrom\" : \"chr3\" , \"pos\" : 134567890 }, { \"chrom\" : \"chr4\" , \"pos\" : 123456789 }, { \"chrom\" : \"chr9\" , \"pos\" : 34567890 } ] }, \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"chrom\" : \"chrom\" , \"pos\" : \"pos\" , \"type\" : \"locus\" , \"scale\" : { \"domain\" : [{ \"chrom\" : \"chr3\" }, { \"chrom\" : \"chr9\" }] } }, \"size\" : { \"value\" : 200 } } }","title":"Example"},{"location":"grammar/scale/#zooming-and-panning","text":"To enable zooming and panning of continuous scales on positional channels, set the zoom scale property to true . Example: { \"x\" : { \"field\" : \"foo\" , \"type\" : \"quantitative\" , \"scale\" : { \"zoom\" : true } } } Both \"index\" and \"locus\" scales are zoomable by default.","title":"Zooming and panning"},{"location":"grammar/scale/#zoom-extent","text":"The zoom extent allows you to control how far the scale can be zoomed out or panned (translated). Zoom extent equals the scale domain by default, except for the \"locus\" scale, where it includes the whole genome. Example: { ... , \"scale\" : { \"domain\" : [ 10 , 20 ], \"zoom\" : { \"extent\" : [ 0 , 30 ] } } }","title":"Zoom extent"},{"location":"grammar/scale/#named-scales","text":"By giving the scale a name, it can be accessed through the API . { ... , \"scale\" : { \"name\" : \"myScale\" } }","title":"Named scales"},{"location":"grammar/tooltip/","text":"Tooltip \u00b6 TODO","title":"Tooltip"},{"location":"grammar/tooltip/#tooltip","text":"TODO","title":"Tooltip"},{"location":"grammar/composition/","text":"View composition \u00b6 GenomeSpy replicates the hierarchical composition model of Vega-Lite. However, only the concatenation and layer operators are currently supported. GenomeSpy also provides a sample faceting operator that allows interactive exploration and analysis of up to thousands of samples. TODO: Explain how data and encoding descend in the hierarchy Scale resolution \u00b6 TODO: Some explanation, meanwhile: check https://vega.github.io/vega-lite/docs/resolve.html { \"resolve\" : { // Scale resolution \"scale\" : { CHANNEL : ... } }, ... } Shared \u00b6 The example below shows an excerpt of segmented copy number data layered with the raw SNP logR values. The domain of the y channel is unioned by default. { \"layer\" : [ { \"data\" : { \"url\" : \"../data/cnv_chr19_raw.tsv\" }, \"title\" : \"Single probe\" , \"mark\" : { \"type\" : \"point\" , \"geometricZoomBound\" : 9.5 }, \"encoding\" : { \"x\" : { \"field\" : \"Position\" , \"type\" : \"index\" }, \"y\" : { \"field\" : \"logR\" , \"type\" : \"quantitative\" }, \"color\" : { \"value\" : \"#404068\" }, \"size\" : { \"value\" : 225 }, \"opacity\" : { \"value\" : 0.25 } } }, { \"data\" : { \"url\" : \"../data/cnv_chr19_segs.tsv\" }, \"title\" : \"Segment mean\" , \"mark\" : { \"type\" : \"rule\" , \"size\" : 3.0 , \"minLength\" : 3.0 }, \"encoding\" : { \"x\" : { \"field\" : \"startpos\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"endpos\" }, \"y\" : { \"field\" : \"segMean\" , \"type\" : \"quantitative\" }, \"color\" : { \"value\" : \"#ff4422\" } } } ] } Independent \u00b6 By specifying that the scales of the y channel should remain independent , both layers get their own scales and axes. Obviously, such a configuration makes no sense with these data. { \"resolve\" : { \"scale\" : { \"y\" : \"independent\" } }, \"layer\" : [ { \"data\" : { \"url\" : \"../data/cnv_chr19_raw.tsv\" }, \"title\" : \"Single probe\" , \"mark\" : { \"type\" : \"point\" , \"geometricZoomBound\" : 9.5 }, \"encoding\" : { \"x\" : { \"field\" : \"Position\" , \"type\" : \"index\" }, \"y\" : { \"field\" : \"logR\" , \"type\" : \"quantitative\" }, \"color\" : { \"value\" : \"#404068\" }, \"size\" : { \"value\" : 225 }, \"opacity\" : { \"value\" : 0.25 } } }, { \"data\" : { \"url\" : \"../data/cnv_chr19_segs.tsv\" }, \"title\" : \"Segment mean\" , \"mark\" : { \"type\" : \"rule\" , \"size\" : 3.0 , \"minLength\" : 3.0 }, \"encoding\" : { \"x\" : { \"field\" : \"startpos\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"endpos\" }, \"y\" : { \"field\" : \"segMean\" , \"type\" : \"quantitative\" }, \"color\" : { \"value\" : \"#ff4422\" } } } ] }","title":"View composition"},{"location":"grammar/composition/#view-composition","text":"GenomeSpy replicates the hierarchical composition model of Vega-Lite. However, only the concatenation and layer operators are currently supported. GenomeSpy also provides a sample faceting operator that allows interactive exploration and analysis of up to thousands of samples. TODO: Explain how data and encoding descend in the hierarchy","title":"View composition"},{"location":"grammar/composition/#scale-resolution","text":"TODO: Some explanation, meanwhile: check https://vega.github.io/vega-lite/docs/resolve.html { \"resolve\" : { // Scale resolution \"scale\" : { CHANNEL : ... } }, ... }","title":"Scale resolution"},{"location":"grammar/composition/#shared","text":"The example below shows an excerpt of segmented copy number data layered with the raw SNP logR values. The domain of the y channel is unioned by default. { \"layer\" : [ { \"data\" : { \"url\" : \"../data/cnv_chr19_raw.tsv\" }, \"title\" : \"Single probe\" , \"mark\" : { \"type\" : \"point\" , \"geometricZoomBound\" : 9.5 }, \"encoding\" : { \"x\" : { \"field\" : \"Position\" , \"type\" : \"index\" }, \"y\" : { \"field\" : \"logR\" , \"type\" : \"quantitative\" }, \"color\" : { \"value\" : \"#404068\" }, \"size\" : { \"value\" : 225 }, \"opacity\" : { \"value\" : 0.25 } } }, { \"data\" : { \"url\" : \"../data/cnv_chr19_segs.tsv\" }, \"title\" : \"Segment mean\" , \"mark\" : { \"type\" : \"rule\" , \"size\" : 3.0 , \"minLength\" : 3.0 }, \"encoding\" : { \"x\" : { \"field\" : \"startpos\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"endpos\" }, \"y\" : { \"field\" : \"segMean\" , \"type\" : \"quantitative\" }, \"color\" : { \"value\" : \"#ff4422\" } } } ] }","title":"Shared"},{"location":"grammar/composition/#independent","text":"By specifying that the scales of the y channel should remain independent , both layers get their own scales and axes. Obviously, such a configuration makes no sense with these data. { \"resolve\" : { \"scale\" : { \"y\" : \"independent\" } }, \"layer\" : [ { \"data\" : { \"url\" : \"../data/cnv_chr19_raw.tsv\" }, \"title\" : \"Single probe\" , \"mark\" : { \"type\" : \"point\" , \"geometricZoomBound\" : 9.5 }, \"encoding\" : { \"x\" : { \"field\" : \"Position\" , \"type\" : \"index\" }, \"y\" : { \"field\" : \"logR\" , \"type\" : \"quantitative\" }, \"color\" : { \"value\" : \"#404068\" }, \"size\" : { \"value\" : 225 }, \"opacity\" : { \"value\" : 0.25 } } }, { \"data\" : { \"url\" : \"../data/cnv_chr19_segs.tsv\" }, \"title\" : \"Segment mean\" , \"mark\" : { \"type\" : \"rule\" , \"size\" : 3.0 , \"minLength\" : 3.0 }, \"encoding\" : { \"x\" : { \"field\" : \"startpos\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"endpos\" }, \"y\" : { \"field\" : \"segMean\" , \"type\" : \"quantitative\" }, \"color\" : { \"value\" : \"#ff4422\" } } } ] }","title":"Independent"},{"location":"grammar/composition/concat/","text":"View Concatenation \u00b6 The vconcat and hconcat composition operators place views side-by-side either vertically or horizontally. The vconcat is practical for building genomic visualizations with multiple tracks. The spacing (in pixels) between concatenated views can be adjusted using the spacing property (Default: 10 ). Example \u00b6 Vertical \u00b6 { \"data\" : { \"url\" : \"sincos.csv\" }, \"spacing\" : 20 , \"vconcat\" : [ { \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"sin\" , \"type\" : \"quantitative\" } } }, { \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"cos\" , \"type\" : \"quantitative\" } } } ] } Horizontal \u00b6 { \"data\" : { \"url\" : \"sincos.csv\" }, \"hconcat\" : [ { \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"sin\" , \"type\" : \"quantitative\" } } }, { \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"cos\" , \"type\" : \"quantitative\" } } } ] } Child sizing \u00b6 The concatenation operators mimic the behavior of the CSS flexbox . The child views have an absolute minimum size ( px ) in pixels and an unitless grow value that specifies in what proportion the possible remaining space should be distributed. The remaining space depends on the parent view's size. In the following example, the left view has a width of 20 px, the center view has a grow of 1 , and the right view has a grow of 2 . If you resize the web browser, you can observe that the width of the left view stays constant while the remaining space is distributed in proportions of 1:2. { \"data\" : { \"values\" : [{}] }, \"spacing\" : 10 , \"hconcat\" : [ { \"width\" : { \"px\" : 20 }, \"mark\" : \"rect\" }, { \"width\" : { \"grow\" : 1 }, \"mark\" : \"rect\" }, { \"width\" : { \"grow\" : 2 }, \"mark\" : \"rect\" } ] } The size may have both absolute ( px ) and proportional ( grow ) components. When views are nested, both the absolute and proportional sizes are added up. Thus, the width of the above example is { \"px\": 40, \"grow\": 3 } . The spacing between the child views is added to the total absolute width. Views' size properties ( width and height ) accept both SizeDef objects and shorthands. The SizeDef objects contain either or both of px and grow properties. Numbers are interpreted as as absolute sizes, and \"container\" is the same as { grow: 1 } . Undefined sizes generally default to \"container\" . Concatenation operators can nested flexibly to build complex layouts as in the following example. { \"data\" : { \"values\" : [{}] }, \"hconcat\" : [ { \"mark\" : \"rect\" }, { \"vconcat\" : [{ \"mark\" : \"rect\" }, { \"mark\" : \"rect\" }] } ] } Resolve \u00b6 By default, all channels have independent scales and axes.","title":"Concat"},{"location":"grammar/composition/concat/#view-concatenation","text":"The vconcat and hconcat composition operators place views side-by-side either vertically or horizontally. The vconcat is practical for building genomic visualizations with multiple tracks. The spacing (in pixels) between concatenated views can be adjusted using the spacing property (Default: 10 ).","title":"View Concatenation"},{"location":"grammar/composition/concat/#example","text":"","title":"Example"},{"location":"grammar/composition/concat/#vertical","text":"{ \"data\" : { \"url\" : \"sincos.csv\" }, \"spacing\" : 20 , \"vconcat\" : [ { \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"sin\" , \"type\" : \"quantitative\" } } }, { \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"cos\" , \"type\" : \"quantitative\" } } } ] }","title":"Vertical"},{"location":"grammar/composition/concat/#horizontal","text":"{ \"data\" : { \"url\" : \"sincos.csv\" }, \"hconcat\" : [ { \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"sin\" , \"type\" : \"quantitative\" } } }, { \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"cos\" , \"type\" : \"quantitative\" } } } ] }","title":"Horizontal"},{"location":"grammar/composition/concat/#child-sizing","text":"The concatenation operators mimic the behavior of the CSS flexbox . The child views have an absolute minimum size ( px ) in pixels and an unitless grow value that specifies in what proportion the possible remaining space should be distributed. The remaining space depends on the parent view's size. In the following example, the left view has a width of 20 px, the center view has a grow of 1 , and the right view has a grow of 2 . If you resize the web browser, you can observe that the width of the left view stays constant while the remaining space is distributed in proportions of 1:2. { \"data\" : { \"values\" : [{}] }, \"spacing\" : 10 , \"hconcat\" : [ { \"width\" : { \"px\" : 20 }, \"mark\" : \"rect\" }, { \"width\" : { \"grow\" : 1 }, \"mark\" : \"rect\" }, { \"width\" : { \"grow\" : 2 }, \"mark\" : \"rect\" } ] } The size may have both absolute ( px ) and proportional ( grow ) components. When views are nested, both the absolute and proportional sizes are added up. Thus, the width of the above example is { \"px\": 40, \"grow\": 3 } . The spacing between the child views is added to the total absolute width. Views' size properties ( width and height ) accept both SizeDef objects and shorthands. The SizeDef objects contain either or both of px and grow properties. Numbers are interpreted as as absolute sizes, and \"container\" is the same as { grow: 1 } . Undefined sizes generally default to \"container\" . Concatenation operators can nested flexibly to build complex layouts as in the following example. { \"data\" : { \"values\" : [{}] }, \"hconcat\" : [ { \"mark\" : \"rect\" }, { \"vconcat\" : [{ \"mark\" : \"rect\" }, { \"mark\" : \"rect\" }] } ] }","title":"Child sizing"},{"location":"grammar/composition/concat/#resolve","text":"By default, all channels have independent scales and axes.","title":"Resolve"},{"location":"grammar/composition/layer/","text":"Layering Views \u00b6 The layer operator superimposes multiple views over each other. Example \u00b6 { \"data\" : { \"values\" : [ { \"a\" : \"A\" , \"b\" : 28 }, { \"a\" : \"B\" , \"b\" : 55 }, { \"a\" : \"C\" , \"b\" : 43 }, { \"a\" : \"D\" , \"b\" : 91 }, { \"a\" : \"E\" , \"b\" : 81 }, { \"a\" : \"F\" , \"b\" : 53 }, { \"a\" : \"G\" , \"b\" : 19 }, { \"a\" : \"H\" , \"b\" : 87 }, { \"a\" : \"I\" , \"b\" : 52 } ] }, \"encoding\" : { \"x\" : { \"field\" : \"a\" , \"type\" : \"nominal\" , \"scale\" : { \"padding\" : 0.1 }, \"axis\" : { \"labelAngle\" : 0 } }, \"y\" : { \"field\" : \"b\" , \"type\" : \"quantitative\" } }, \"layer\" : [ { \"name\" : \"Bar\" , \"mark\" : \"rect\" }, { \"name\" : \"Label\" , \"mark\" : { \"type\" : \"text\" , \"dy\" : -9 }, \"encoding\" : { \"text\" : { \"field\" : \"b\" , \"type\" : \"quantitative\" } } } ] } To specify multiple layers, use the layer property: { \"layer\" : [ ... // Single or layered view specifications ] } The provided array may contain both single view specifications and layered specifications. The encodings and data that are specified in a layer view propagate to its descendants. For example, in the above example, the \"Bar\" and \"Label\" views inherit the data and the encodings for the x and y channels from their parent, the layer view. Resolve \u00b6 By default, layers share their scales and axes, unioning the data domains. More examples \u00b6 Lollipop plot \u00b6 This example layers two marks to create a composite mark, a lollipop. Yet another layer is used for the baseline. { \"name\" : \"The Root\" , \"description\" : \"Lollipop plot example\" , \"resolve\" : { \"axis\" : { \"y\" : \"independent\" } }, \"layer\" : [ { \"name\" : \"Baseline\" , \"data\" : { \"values\" : [ 0 ] }, \"mark\" : \"rule\" , \"encoding\" : { \"y\" : { \"field\" : \"data\" , \"type\" : \"quantitative\" , \"axis\" : null }, \"color\" : { \"value\" : \"lightgray\" } } }, { \"name\" : \"Arrows\" , \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 6.284 , \"step\" : 0.39269908169 , \"as\" : \"x\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"sin(datum.x)\" , \"as\" : \"sin(x)\" } ], \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"sin(x)\" , \"type\" : \"quantitative\" , \"scale\" : { \"padding\" : 0.1 } }, \"color\" : { \"field\" : \"sin(x)\" , \"type\" : \"quantitative\" } }, \"layer\" : [ { \"name\" : \"Arrow shafts\" , \"mark\" : { \"type\" : \"rule\" , \"size\" : 3 } }, { \"name\" : \"Arrowheads\" , \"mark\" : { \"type\" : \"point\" , \"size\" : 500 , \"strokeWidth\" : 0 }, \"encoding\" : { \"shape\" : { \"field\" : \"sin(x)\" , \"type\" : \"nominal\" , \"scale\" : { \"type\" : \"threshold\" , \"domain\" : [ -0.01 , 0.01 ], \"range\" : [ \"triangle-down\" , \"diamond\" , \"triangle-up\" ] } } } } ] } ] }","title":"Layer"},{"location":"grammar/composition/layer/#layering-views","text":"The layer operator superimposes multiple views over each other.","title":"Layering Views"},{"location":"grammar/composition/layer/#example","text":"{ \"data\" : { \"values\" : [ { \"a\" : \"A\" , \"b\" : 28 }, { \"a\" : \"B\" , \"b\" : 55 }, { \"a\" : \"C\" , \"b\" : 43 }, { \"a\" : \"D\" , \"b\" : 91 }, { \"a\" : \"E\" , \"b\" : 81 }, { \"a\" : \"F\" , \"b\" : 53 }, { \"a\" : \"G\" , \"b\" : 19 }, { \"a\" : \"H\" , \"b\" : 87 }, { \"a\" : \"I\" , \"b\" : 52 } ] }, \"encoding\" : { \"x\" : { \"field\" : \"a\" , \"type\" : \"nominal\" , \"scale\" : { \"padding\" : 0.1 }, \"axis\" : { \"labelAngle\" : 0 } }, \"y\" : { \"field\" : \"b\" , \"type\" : \"quantitative\" } }, \"layer\" : [ { \"name\" : \"Bar\" , \"mark\" : \"rect\" }, { \"name\" : \"Label\" , \"mark\" : { \"type\" : \"text\" , \"dy\" : -9 }, \"encoding\" : { \"text\" : { \"field\" : \"b\" , \"type\" : \"quantitative\" } } } ] } To specify multiple layers, use the layer property: { \"layer\" : [ ... // Single or layered view specifications ] } The provided array may contain both single view specifications and layered specifications. The encodings and data that are specified in a layer view propagate to its descendants. For example, in the above example, the \"Bar\" and \"Label\" views inherit the data and the encodings for the x and y channels from their parent, the layer view.","title":"Example"},{"location":"grammar/composition/layer/#resolve","text":"By default, layers share their scales and axes, unioning the data domains.","title":"Resolve"},{"location":"grammar/composition/layer/#more-examples","text":"","title":"More examples"},{"location":"grammar/composition/layer/#lollipop-plot","text":"This example layers two marks to create a composite mark, a lollipop. Yet another layer is used for the baseline. { \"name\" : \"The Root\" , \"description\" : \"Lollipop plot example\" , \"resolve\" : { \"axis\" : { \"y\" : \"independent\" } }, \"layer\" : [ { \"name\" : \"Baseline\" , \"data\" : { \"values\" : [ 0 ] }, \"mark\" : \"rule\" , \"encoding\" : { \"y\" : { \"field\" : \"data\" , \"type\" : \"quantitative\" , \"axis\" : null }, \"color\" : { \"value\" : \"lightgray\" } } }, { \"name\" : \"Arrows\" , \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 6.284 , \"step\" : 0.39269908169 , \"as\" : \"x\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"sin(datum.x)\" , \"as\" : \"sin(x)\" } ], \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"sin(x)\" , \"type\" : \"quantitative\" , \"scale\" : { \"padding\" : 0.1 } }, \"color\" : { \"field\" : \"sin(x)\" , \"type\" : \"quantitative\" } }, \"layer\" : [ { \"name\" : \"Arrow shafts\" , \"mark\" : { \"type\" : \"rule\" , \"size\" : 3 } }, { \"name\" : \"Arrowheads\" , \"mark\" : { \"type\" : \"point\" , \"size\" : 500 , \"strokeWidth\" : 0 }, \"encoding\" : { \"shape\" : { \"field\" : \"sin(x)\" , \"type\" : \"nominal\" , \"scale\" : { \"type\" : \"threshold\" , \"domain\" : [ -0.01 , 0.01 ], \"range\" : [ \"triangle-down\" , \"diamond\" , \"triangle-up\" ] } } } } ] } ] }","title":"Lollipop plot"},{"location":"grammar/encoding/","text":"Encoding \u00b6 The encoding object specifies how variables of the data are mapped to different visual properties (channels) of the graphical marks. TODO // Specification of a Single View { \"data\" : ... , \"mark\" : ... , \"encoding\" : { // Encoding // Position Channels \"x\" : ... , \"y\" : ... , \"x2\" : ... , \"y2\" : ... , // Mark Properties Channels \"color\" : ... , \"opacity\" : ... , \"strokeWidth\" : ... , \"size\" : ... , \"shape\" : ... , }, ... } Position channels \u00b6 TODO Mark property channels \u00b6 TODO Fields \u00b6 TODO Expressions \u00b6 TODO Values \u00b6 TODO Genomic coordinates \u00b6 TODO","title":"Encoding"},{"location":"grammar/encoding/#encoding","text":"The encoding object specifies how variables of the data are mapped to different visual properties (channels) of the graphical marks. TODO // Specification of a Single View { \"data\" : ... , \"mark\" : ... , \"encoding\" : { // Encoding // Position Channels \"x\" : ... , \"y\" : ... , \"x2\" : ... , \"y2\" : ... , // Mark Properties Channels \"color\" : ... , \"opacity\" : ... , \"strokeWidth\" : ... , \"size\" : ... , \"shape\" : ... , }, ... }","title":"Encoding"},{"location":"grammar/encoding/#position-channels","text":"TODO","title":"Position channels"},{"location":"grammar/encoding/#mark-property-channels","text":"TODO","title":"Mark property channels"},{"location":"grammar/encoding/#fields","text":"TODO","title":"Fields"},{"location":"grammar/encoding/#expressions","text":"TODO","title":"Expressions"},{"location":"grammar/encoding/#values","text":"TODO","title":"Values"},{"location":"grammar/encoding/#genomic-coordinates","text":"TODO","title":"Genomic coordinates"},{"location":"grammar/encoding/axis/","text":"Axis \u00b6 TODO","title":"Axis"},{"location":"grammar/encoding/axis/#axis","text":"TODO","title":"Axis"},{"location":"grammar/mark/link/","text":"Link \u00b6 The \"link\" mark displays each data item as a curve that connects two points. The mark can be used to display structural variation and interactions, for example. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 30 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"round(random() * 800)\" , \"as\" : \"x\" }, { \"type\" : \"formula\" , \"expr\" : \"round(datum.x + pow(2, random() * 10))\" , \"as\" : \"x2\" } ], \"mark\" : \"link\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"x2\" } } } Still under development The parameterization is likely to be changed a bit to support more use cases. Channels \u00b6 In addition to the standard position channels and color and opacity channels, link mark supports the following channels: size Type: Number Stroke width of the starting point in pixels. size2 Type: Number Stroke width of the end point in pixels. Same as size if left undefined. color2 Type: Number Color of the end point. Same as color if left undefined. Properties \u00b6 segments Type: Number Number of segments in the b\u00e9zier curve. Affects the rendering quality and speed. Default value: 101 Examples \u00b6 { \"width\" : 300 , \"height\" : 300 , \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 12 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"datum.z / 12 * 3.141 * 2\" , \"as\" : \"theta\" }, { \"type\" : \"formula\" , \"expr\" : \"cos(datum.theta)\" , \"as\" : \"x\" }, { \"type\" : \"formula\" , \"expr\" : \"sin(datum.theta)\" , \"as\" : \"y\" } ], \"mark\" : { \"type\" : \"link\" , \"size\" : 10 , \"size2\" : 0 }, \"encoding\" : { \"x\" : { \"datum\" : 0 , \"type\" : \"quantitative\" }, \"x2\" : { \"field\" : \"x\" }, \"y\" : { \"datum\" : 0 , \"type\" : \"quantitative\" }, \"y2\" : { \"field\" : \"y\" }, \"color\" : { \"field\" : \"theta\" , \"type\" : \"quantitative\" , \"scale\" : { \"scheme\" : \"rainbow\" } }, \"color2\" : { \"value\" : \"white\" } } }","title":"Link"},{"location":"grammar/mark/link/#link","text":"The \"link\" mark displays each data item as a curve that connects two points. The mark can be used to display structural variation and interactions, for example. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 30 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"round(random() * 800)\" , \"as\" : \"x\" }, { \"type\" : \"formula\" , \"expr\" : \"round(datum.x + pow(2, random() * 10))\" , \"as\" : \"x2\" } ], \"mark\" : \"link\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"x2\" } } } Still under development The parameterization is likely to be changed a bit to support more use cases.","title":"Link"},{"location":"grammar/mark/link/#channels","text":"In addition to the standard position channels and color and opacity channels, link mark supports the following channels: size Type: Number Stroke width of the starting point in pixels. size2 Type: Number Stroke width of the end point in pixels. Same as size if left undefined. color2 Type: Number Color of the end point. Same as color if left undefined.","title":"Channels"},{"location":"grammar/mark/link/#properties","text":"segments Type: Number Number of segments in the b\u00e9zier curve. Affects the rendering quality and speed. Default value: 101","title":"Properties"},{"location":"grammar/mark/link/#examples","text":"{ \"width\" : 300 , \"height\" : 300 , \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 12 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"datum.z / 12 * 3.141 * 2\" , \"as\" : \"theta\" }, { \"type\" : \"formula\" , \"expr\" : \"cos(datum.theta)\" , \"as\" : \"x\" }, { \"type\" : \"formula\" , \"expr\" : \"sin(datum.theta)\" , \"as\" : \"y\" } ], \"mark\" : { \"type\" : \"link\" , \"size\" : 10 , \"size2\" : 0 }, \"encoding\" : { \"x\" : { \"datum\" : 0 , \"type\" : \"quantitative\" }, \"x2\" : { \"field\" : \"x\" }, \"y\" : { \"datum\" : 0 , \"type\" : \"quantitative\" }, \"y2\" : { \"field\" : \"y\" }, \"color\" : { \"field\" : \"theta\" , \"type\" : \"quantitative\" , \"scale\" : { \"scheme\" : \"rainbow\" } }, \"color2\" : { \"value\" : \"white\" } } }","title":"Examples"},{"location":"grammar/mark/point/","text":"Point \u00b6 Point mark displays each data item as a symbol. Points are often used to create a scatter plot. In the genomic context, they could represent, for example, point mutations at genomic loci. { \"data\" : { \"url\" : \"sincos.csv\" }, \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"sin\" , \"type\" : \"quantitative\" }, \"size\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" } } } Channels \u00b6 In addition to standard position channels and color , opacity , and strokeWidth channels, point mark has the following channels: size Type: Number The area of the point in pixels. In practice, the area is less because the shapes do not fill their rectangular container. Example: the diameter of a circle with the size of 100 is 10 (sqrt(100)) pixels. Default value: 100 shape Type: String One of \"circle\" , \"square\" , \"cross\" , \"diamond\" , \"triangle-up\" , \"triangle-down\" , \"triangle-right\" , or \"triangle-left\" . Default value: \"circle\" Properties \u00b6 fillGradientStrength Type: Number Gradient strength controls the amount of the gradient eye-candy effect. Valid values are between 0 and 1 . Default value: 0 geometricZoomBound Type: Number Enables geometric zooming . The value is the base two logarithmic zoom level where the maximum point size is reached. Default value: 0 sampleFacetPadding Type: Number Padding between sample facet's upper/lower edge and the maximum point size. This property controls how tightly points are squeezed when facet's height is smaller than the maximum point size. The unit is a proportion of facet's height. The value must be between 0 and 0.5 . This property has no effect when sample faceting is not used. Default value: 0.1 Examples \u00b6 Plenty of points \u00b6 The example below demonstrates how points can be varied by using shape , fill , size , strokeWidth , and angle channels. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 160 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"datum.z % 20\" , \"as\" : \"x\" }, { \"type\" : \"formula\" , \"expr\" : \"floor(datum.z / 20)\" , \"as\" : \"y\" } ], \"mark\" : { \"type\" : \"point\" , \"stroke\" : \"black\" }, \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"ordinal\" , \"axis\" : null }, \"y\" : { \"field\" : \"y\" , \"type\" : \"ordinal\" , \"axis\" : null }, \"shape\" : { \"field\" : \"x\" , \"type\" : \"nominal\" }, \"fill\" : { \"field\" : \"x\" , \"type\" : \"nominal\" }, \"size\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" , \"scale\" : { \"type\" : \"pow\" , \"exponent\" : 2 , \"range\" : [ 0 , 900 ] } }, \"strokeWidth\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" , \"scale\" : { \"range\" : [ 0 , 4 ] } }, \"angle\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" , \"scale\" : { \"range\" : [ 0 , 45 ] } } } } Zoom behavior \u00b6 Although points are infinitely small on the real number line, they have a specific diameter on the screen. Thus, closely located points tend to overlap each other. Decreasing the point size reduces the probability of overlap, but in a zoomed-in view, the plot may become overly sparse. To control overplotting, the point mark provides two zooming behaviors that adjust the point size and visibility based on the zoom level. Geometric zoom \u00b6 Geometric zoom scales the point size down if the current zoom level is lower than the specified level (bound). geometricZoomBound mark property enables geometric zooming. The value is the negative base two logarithm of the relative width of the visible domain. Example: 0 : (the default) full-size points are always shown, 1 : when a half of the domain is visible, 2 : when a quarter is visible, and so on. The example below displays 200 000 semi-randomly generated points. The points reach their full size when 1 / 2^10.5 of the domain is visible, which equals about 1500X zoom. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 200000 , \"as\" : \"x\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"random() * 0.682\" , \"as\" : \"u\" }, { \"type\" : \"formula\" , \"expr\" : \"((datum.u % 1e-8 > 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618 + sin(datum.x / 10000)\" , \"as\" : \"y\" } ], \"mark\" : { \"type\" : \"point\" , \"geometricZoomBound\" : 10.5 }, \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" , \"scale\" : { \"zoom\" : true } }, \"y\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"size\" : { \"value\" : 200 }, \"opacity\" : { \"value\" : 0.6 } } } Tip You can use geometric zoom to improve rendering performance. Smaller points are faster to render than large points. Semantic zoom \u00b6 The score-based semantic zoom adjusts the point visibility by coupling a score threshold to current zoom level. The semanticScore channel enables the semantic zoom and specifies the score field. The semanticZoomFraction property controls the fraction of data items to show in the fully zoomed-out view, i.e., it specifies the threshold score. The fraction is scaled as the viewport is zoomed. Thus, if the data is distributed roughly uniformly along the zoomed axis, roughly constant number of points are visible at all zoom levels. The score can be arbitrarily distributed , as the threshold is computed using p -quantiles. The example below has 200 000 semi-randomly generated points with an exponentially distributed score. As the view is zoomed in, new points appear. Their number in the viewport stays approximately constant until the lowest possible score has been reached. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 200000 , \"as\" : \"x\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"random() * 0.682\" , \"as\" : \"u\" }, { \"type\" : \"formula\" , \"expr\" : \"((datum.u % 1e-8 > 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618\" , \"as\" : \"y\" }, { \"type\" : \"formula\" , \"expr\" : \"-log(random())\" , \"as\" : \"score\" } ], \"mark\" : { \"type\" : \"point\" , \"semanticZoomFraction\" : 0.002 }, \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" , \"scale\" : { \"zoom\" : true } }, \"y\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"opacity\" : { \"field\" : \"score\" , \"type\" : \"quantitative\" , \"scale\" : { \"range\" : [ 0.1 , 1 ] } }, \"semanticScore\" : { \"field\" : \"score\" , \"type\" : \"quantitative\" }, \"size\" : { \"value\" : 100 } } } Tip The score-based semantic zoom is great for filtering point mutations and indels that are scored using CADD , for example.","title":"Point"},{"location":"grammar/mark/point/#point","text":"Point mark displays each data item as a symbol. Points are often used to create a scatter plot. In the genomic context, they could represent, for example, point mutations at genomic loci. { \"data\" : { \"url\" : \"sincos.csv\" }, \"mark\" : \"point\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"y\" : { \"field\" : \"sin\" , \"type\" : \"quantitative\" }, \"size\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" } } }","title":"Point"},{"location":"grammar/mark/point/#channels","text":"In addition to standard position channels and color , opacity , and strokeWidth channels, point mark has the following channels: size Type: Number The area of the point in pixels. In practice, the area is less because the shapes do not fill their rectangular container. Example: the diameter of a circle with the size of 100 is 10 (sqrt(100)) pixels. Default value: 100 shape Type: String One of \"circle\" , \"square\" , \"cross\" , \"diamond\" , \"triangle-up\" , \"triangle-down\" , \"triangle-right\" , or \"triangle-left\" . Default value: \"circle\"","title":"Channels"},{"location":"grammar/mark/point/#properties","text":"fillGradientStrength Type: Number Gradient strength controls the amount of the gradient eye-candy effect. Valid values are between 0 and 1 . Default value: 0 geometricZoomBound Type: Number Enables geometric zooming . The value is the base two logarithmic zoom level where the maximum point size is reached. Default value: 0 sampleFacetPadding Type: Number Padding between sample facet's upper/lower edge and the maximum point size. This property controls how tightly points are squeezed when facet's height is smaller than the maximum point size. The unit is a proportion of facet's height. The value must be between 0 and 0.5 . This property has no effect when sample faceting is not used. Default value: 0.1","title":"Properties"},{"location":"grammar/mark/point/#examples","text":"","title":"Examples"},{"location":"grammar/mark/point/#plenty-of-points","text":"The example below demonstrates how points can be varied by using shape , fill , size , strokeWidth , and angle channels. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 160 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"datum.z % 20\" , \"as\" : \"x\" }, { \"type\" : \"formula\" , \"expr\" : \"floor(datum.z / 20)\" , \"as\" : \"y\" } ], \"mark\" : { \"type\" : \"point\" , \"stroke\" : \"black\" }, \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"ordinal\" , \"axis\" : null }, \"y\" : { \"field\" : \"y\" , \"type\" : \"ordinal\" , \"axis\" : null }, \"shape\" : { \"field\" : \"x\" , \"type\" : \"nominal\" }, \"fill\" : { \"field\" : \"x\" , \"type\" : \"nominal\" }, \"size\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" , \"scale\" : { \"type\" : \"pow\" , \"exponent\" : 2 , \"range\" : [ 0 , 900 ] } }, \"strokeWidth\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" , \"scale\" : { \"range\" : [ 0 , 4 ] } }, \"angle\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" , \"scale\" : { \"range\" : [ 0 , 45 ] } } } }","title":"Plenty of points"},{"location":"grammar/mark/point/#zoom-behavior","text":"Although points are infinitely small on the real number line, they have a specific diameter on the screen. Thus, closely located points tend to overlap each other. Decreasing the point size reduces the probability of overlap, but in a zoomed-in view, the plot may become overly sparse. To control overplotting, the point mark provides two zooming behaviors that adjust the point size and visibility based on the zoom level.","title":"Zoom behavior"},{"location":"grammar/mark/point/#geometric-zoom","text":"Geometric zoom scales the point size down if the current zoom level is lower than the specified level (bound). geometricZoomBound mark property enables geometric zooming. The value is the negative base two logarithm of the relative width of the visible domain. Example: 0 : (the default) full-size points are always shown, 1 : when a half of the domain is visible, 2 : when a quarter is visible, and so on. The example below displays 200 000 semi-randomly generated points. The points reach their full size when 1 / 2^10.5 of the domain is visible, which equals about 1500X zoom. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 200000 , \"as\" : \"x\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"random() * 0.682\" , \"as\" : \"u\" }, { \"type\" : \"formula\" , \"expr\" : \"((datum.u % 1e-8 > 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618 + sin(datum.x / 10000)\" , \"as\" : \"y\" } ], \"mark\" : { \"type\" : \"point\" , \"geometricZoomBound\" : 10.5 }, \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" , \"scale\" : { \"zoom\" : true } }, \"y\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"size\" : { \"value\" : 200 }, \"opacity\" : { \"value\" : 0.6 } } } Tip You can use geometric zoom to improve rendering performance. Smaller points are faster to render than large points.","title":"Geometric zoom"},{"location":"grammar/mark/point/#semantic-zoom","text":"The score-based semantic zoom adjusts the point visibility by coupling a score threshold to current zoom level. The semanticScore channel enables the semantic zoom and specifies the score field. The semanticZoomFraction property controls the fraction of data items to show in the fully zoomed-out view, i.e., it specifies the threshold score. The fraction is scaled as the viewport is zoomed. Thus, if the data is distributed roughly uniformly along the zoomed axis, roughly constant number of points are visible at all zoom levels. The score can be arbitrarily distributed , as the threshold is computed using p -quantiles. The example below has 200 000 semi-randomly generated points with an exponentially distributed score. As the view is zoomed in, new points appear. Their number in the viewport stays approximately constant until the lowest possible score has been reached. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 200000 , \"as\" : \"x\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"random() * 0.682\" , \"as\" : \"u\" }, { \"type\" : \"formula\" , \"expr\" : \"((datum.u % 1e-8 > 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618\" , \"as\" : \"y\" }, { \"type\" : \"formula\" , \"expr\" : \"-log(random())\" , \"as\" : \"score\" } ], \"mark\" : { \"type\" : \"point\" , \"semanticZoomFraction\" : 0.002 }, \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" , \"scale\" : { \"zoom\" : true } }, \"y\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"opacity\" : { \"field\" : \"score\" , \"type\" : \"quantitative\" , \"scale\" : { \"range\" : [ 0.1 , 1 ] } }, \"semanticScore\" : { \"field\" : \"score\" , \"type\" : \"quantitative\" }, \"size\" : { \"value\" : 100 } } } Tip The score-based semantic zoom is great for filtering point mutations and indels that are scored using CADD , for example.","title":"Semantic zoom"},{"location":"grammar/mark/rect/","text":"Rect \u00b6 Rect mark displays each data item as a rectangle. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 20 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"as\" : \"x\" , \"expr\" : \"random()\" }, { \"type\" : \"formula\" , \"as\" : \"x2\" , \"expr\" : \"datum.x + random() * 0.3\" }, { \"type\" : \"formula\" , \"as\" : \"y\" , \"expr\" : \"random()\" }, { \"type\" : \"formula\" , \"as\" : \"y2\" , \"expr\" : \"datum.y + random() * 0.4\" } ], \"mark\" : { \"type\" : \"rect\" , \"strokeWidth\" : 2 , \"stroke\" : \"#404040\" , \"cornerRadius\" : 5 }, \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"x2\" : { \"field\" : \"x2\" }, \"y\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"y2\" : { \"field\" : \"y2\" }, \"color\" : { \"field\" : \"z\" , \"type\" : \"quantitative\" } } } Channels \u00b6 Rect mark supports the standard position channels and color and opacity channels. Properties \u00b6 minHeight Type: Number The minimum height of a rectangle in pixels. The property clamps rectangles' heights. Default value: 0 minWidth Type: Number The minimum width of a rectangle in pixels. The property clamps rectangles' widths when the viewport is zoomed out. This property also reduces flickering of very narrow rectangles, thus, the value should generally be at least one. Default value: 1 minOpacity Type: Number Clamps the minimum size-dependent opacity. The property does not affect the opacity channel. Valid values are between 0 and 1 . When a rectangle would be smaller than what is specified in minHeight and minWidth , it is faded out proportionally. Example: a rectangle would be rendered as one pixel wide, but minWidth clamps it to five pixels. The rectangle is actually rendered as five pixels wide, but its opacity is multiplied by 0.2. With this setting, you can limit the factor to, for example, 0.5 to keep the rectangles more clearly visible. Default value: 0 xOffset Type: Number Offsets of the x and x2 coordinates in pixels. The offset is applied after the viewport scaling and translation. Default value: 0 yOffset Type: Number Offsets of the y and y2 coordinates in pixels. The offset is applied after the viewport scaling and translation. Default value: 0 Examples \u00b6 Heatmap \u00b6 When used with \"band\" or \"index\" scales, the rectangles fill the whole bands when only the primary positional channel is defined. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 800 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"as\" : \"y\" , \"expr\" : \"floor(datum.z / 40)\" }, { \"type\" : \"formula\" , \"as\" : \"x\" , \"expr\" : \"datum.z % 40\" }, { \"type\" : \"formula\" , \"as\" : \"z\" , \"expr\" : \"sin(datum.x / 8) + cos(datum.y / 10 - 0.5 + sin(datum.x / 20) * 2)\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"index\" }, \"y\" : { \"field\" : \"y\" , \"type\" : \"index\" }, \"color\" : { \"field\" : \"z\" , \"type\" : \"quantitative\" , \"scale\" : { \"scheme\" : \"magma\" } } } } Bars \u00b6 { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 60 , \"as\" : \"x\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"sin((datum.x - 30) / 4) + (datum.x - 30) / 30\" , \"as\" : \"y\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"index\" , \"scale\" : { \"padding\" : 0.1 } }, \"y\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"y2\" : { \"datum\" : 0 }, \"color\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" , \"scale\" : { \"type\" : \"threshold\" , \"domain\" : [ 0 ], \"range\" : [ \"#ed553b\" , \"#20639b\" ] } } } }","title":"Rect"},{"location":"grammar/mark/rect/#rect","text":"Rect mark displays each data item as a rectangle. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 20 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"as\" : \"x\" , \"expr\" : \"random()\" }, { \"type\" : \"formula\" , \"as\" : \"x2\" , \"expr\" : \"datum.x + random() * 0.3\" }, { \"type\" : \"formula\" , \"as\" : \"y\" , \"expr\" : \"random()\" }, { \"type\" : \"formula\" , \"as\" : \"y2\" , \"expr\" : \"datum.y + random() * 0.4\" } ], \"mark\" : { \"type\" : \"rect\" , \"strokeWidth\" : 2 , \"stroke\" : \"#404040\" , \"cornerRadius\" : 5 }, \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"x2\" : { \"field\" : \"x2\" }, \"y\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"y2\" : { \"field\" : \"y2\" }, \"color\" : { \"field\" : \"z\" , \"type\" : \"quantitative\" } } }","title":"Rect"},{"location":"grammar/mark/rect/#channels","text":"Rect mark supports the standard position channels and color and opacity channels.","title":"Channels"},{"location":"grammar/mark/rect/#properties","text":"minHeight Type: Number The minimum height of a rectangle in pixels. The property clamps rectangles' heights. Default value: 0 minWidth Type: Number The minimum width of a rectangle in pixels. The property clamps rectangles' widths when the viewport is zoomed out. This property also reduces flickering of very narrow rectangles, thus, the value should generally be at least one. Default value: 1 minOpacity Type: Number Clamps the minimum size-dependent opacity. The property does not affect the opacity channel. Valid values are between 0 and 1 . When a rectangle would be smaller than what is specified in minHeight and minWidth , it is faded out proportionally. Example: a rectangle would be rendered as one pixel wide, but minWidth clamps it to five pixels. The rectangle is actually rendered as five pixels wide, but its opacity is multiplied by 0.2. With this setting, you can limit the factor to, for example, 0.5 to keep the rectangles more clearly visible. Default value: 0 xOffset Type: Number Offsets of the x and x2 coordinates in pixels. The offset is applied after the viewport scaling and translation. Default value: 0 yOffset Type: Number Offsets of the y and y2 coordinates in pixels. The offset is applied after the viewport scaling and translation. Default value: 0","title":"Properties"},{"location":"grammar/mark/rect/#examples","text":"","title":"Examples"},{"location":"grammar/mark/rect/#heatmap","text":"When used with \"band\" or \"index\" scales, the rectangles fill the whole bands when only the primary positional channel is defined. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 800 , \"as\" : \"z\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"as\" : \"y\" , \"expr\" : \"floor(datum.z / 40)\" }, { \"type\" : \"formula\" , \"as\" : \"x\" , \"expr\" : \"datum.z % 40\" }, { \"type\" : \"formula\" , \"as\" : \"z\" , \"expr\" : \"sin(datum.x / 8) + cos(datum.y / 10 - 0.5 + sin(datum.x / 20) * 2)\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"index\" }, \"y\" : { \"field\" : \"y\" , \"type\" : \"index\" }, \"color\" : { \"field\" : \"z\" , \"type\" : \"quantitative\" , \"scale\" : { \"scheme\" : \"magma\" } } } }","title":"Heatmap"},{"location":"grammar/mark/rect/#bars","text":"{ \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 60 , \"as\" : \"x\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"sin((datum.x - 30) / 4) + (datum.x - 30) / 30\" , \"as\" : \"y\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"index\" , \"scale\" : { \"padding\" : 0.1 } }, \"y\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"y2\" : { \"datum\" : 0 }, \"color\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" , \"scale\" : { \"type\" : \"threshold\" , \"domain\" : [ 0 ], \"range\" : [ \"#ed553b\" , \"#20639b\" ] } } } }","title":"Bars"},{"location":"grammar/mark/rule/","text":"Rule \u00b6 Rule mark displays each data item as a line segment. Rules can span the whole width or height of the view. Alternatively, they may have specific endpoints. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 15 , \"as\" : \"y\" } }, \"mark\" : { \"type\" : \"rule\" , \"strokeDash\" : [ 6 , 3 ] }, \"encoding\" : { \"x\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"color\" : { \"field\" : \"y\" , \"type\" : \"nominal\" } } } Channels \u00b6 TODO, but in principle, the same as in the rect mark. Properties \u00b6 TODO, but in principle, the same as in the rect mark plus the following: size Type: Number The stroke width of the lines in pixels. Default value: 1 minLength Type: Number The minimum length of the rule in pixels. Use this property to ensure that very short rules remain visible even when the user zooms out. Default value: 0 strokeDash Type: Number[] An array of of alternating stroke and gap lengths or null for solid strokes. Default value: null strokeDashOffset Type: Number An offset for the stroke pattern. Default value: 0 strokeCap Type: String The style of stroke ends. Available choices: \"butt\" , \"round \", and \"square\" . Default value: \"butt\" Examples \u00b6 Ranged rules \u00b6 { \"data\" : { \"values\" : [ { \"y\" : \"A\" , \"x\" : 2 , \"x2\" : 7 }, { \"y\" : \"B\" , \"x\" : 0 , \"x2\" : 3 }, { \"y\" : \"B\" , \"x\" : 5 , \"x2\" : 6 }, { \"y\" : \"C\" , \"x\" : 4 , \"x2\" : 8 }, { \"y\" : \"D\" , \"x\" : 1 , \"x2\" : 5 } ] }, \"mark\" : { \"type\" : \"rule\" , \"size\" : 10 , \"strokeCap\" : \"round\" }, \"encoding\" : { \"y\" : { \"field\" : \"y\" , \"type\" : \"nominal\" }, \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"x2\" : { \"field\" : \"x2\" } } }","title":"Rule"},{"location":"grammar/mark/rule/#rule","text":"Rule mark displays each data item as a line segment. Rules can span the whole width or height of the view. Alternatively, they may have specific endpoints. { \"data\" : { \"sequence\" : { \"start\" : 0 , \"stop\" : 15 , \"as\" : \"y\" } }, \"mark\" : { \"type\" : \"rule\" , \"strokeDash\" : [ 6 , 3 ] }, \"encoding\" : { \"x\" : { \"field\" : \"y\" , \"type\" : \"quantitative\" }, \"color\" : { \"field\" : \"y\" , \"type\" : \"nominal\" } } }","title":"Rule"},{"location":"grammar/mark/rule/#channels","text":"TODO, but in principle, the same as in the rect mark.","title":"Channels"},{"location":"grammar/mark/rule/#properties","text":"TODO, but in principle, the same as in the rect mark plus the following: size Type: Number The stroke width of the lines in pixels. Default value: 1 minLength Type: Number The minimum length of the rule in pixels. Use this property to ensure that very short rules remain visible even when the user zooms out. Default value: 0 strokeDash Type: Number[] An array of of alternating stroke and gap lengths or null for solid strokes. Default value: null strokeDashOffset Type: Number An offset for the stroke pattern. Default value: 0 strokeCap Type: String The style of stroke ends. Available choices: \"butt\" , \"round \", and \"square\" . Default value: \"butt\"","title":"Properties"},{"location":"grammar/mark/rule/#examples","text":"","title":"Examples"},{"location":"grammar/mark/rule/#ranged-rules","text":"{ \"data\" : { \"values\" : [ { \"y\" : \"A\" , \"x\" : 2 , \"x2\" : 7 }, { \"y\" : \"B\" , \"x\" : 0 , \"x2\" : 3 }, { \"y\" : \"B\" , \"x\" : 5 , \"x2\" : 6 }, { \"y\" : \"C\" , \"x\" : 4 , \"x2\" : 8 }, { \"y\" : \"D\" , \"x\" : 1 , \"x2\" : 5 } ] }, \"mark\" : { \"type\" : \"rule\" , \"size\" : 10 , \"strokeCap\" : \"round\" }, \"encoding\" : { \"y\" : { \"field\" : \"y\" , \"type\" : \"nominal\" }, \"x\" : { \"field\" : \"x\" , \"type\" : \"quantitative\" }, \"x2\" : { \"field\" : \"x2\" } } }","title":"Ranged rules"},{"location":"grammar/mark/text/","text":"Text \u00b6 Text mark displays each data item as text. { \"data\" : { \"values\" : [ { \"x\" : 1 , \"text\" : \"Hello\" }, { \"x\" : 2 , \"text\" : \"world!\" } ] }, \"mark\" : \"text\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"ordinal\" }, \"color\" : { \"field\" : \"x\" , \"type\" : \"nominal\" }, \"text\" : { \"field\" : \"text\" , \"type\" : \"nominal\" }, \"size\" : { \"value\" : 100 } } } Channels \u00b6 In addition to standard position channels and color and opacity channels, point mark has the following channels: text Type: String The text to display. The format of numeric data can be customized by setting a format specifier to channel definition's format property. Default value: \"\" size Type: Number The font size in pixels. Default value: 11 angle Type: Number The rotation angle in degrees. Default value: 0 Properties \u00b6 font Type: String The font typeface. GenomeSpy uses SDF versions of Google Fonts . Check their availability at the A-Frame Fonts repository. The system fonts are not supported. Default value: \"Lato\" fontWeight Type: String | Number The font weight. The following strings and numbers are valid values: \"thin\" ( 100 ), \"light\" ( 300 ), \"regular\" ( 400 ), \"normal\" ( 400 ), \"medium\" ( 500 ), \"bold\" ( 700 ), \"black\" ( 900 ) Default value: \"regular\" fontStyle Type: String The font style. Valid values: \"normal\" and \"italic\" . Default value: \"normal\" align Type: String The horizontal alignment of the text. One of \"left\" , \"center\" , or \"right\" . Default value: \"left\" baseline Type: String The vertical alignment of the text. One of \"top\" , \"middle\" , \"bottom\" . Default value: \"bottom\" dX Type: Number Offset of the x coordinate in pixels. The offset is applied after the viewport scaling and translation. Default value: 0 dY Type: Number Offset of the x coordinate in pixels. The offset is applied after the viewport scaling and translation. Default value: 0 Examples \u00b6 Ranged text \u00b6 The x2 and y2 channels allow for positioning the text inside a segment. The text is either squeezed (default) or hidden if it does not fit in the segment. The squeeze property controls the behavior. The example below has two layers: gray rectangles at the bottom and ranged text on the top. Try to zoom and pan to see how they behave! { \"data\" : { \"values\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" ] }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"round(random() * 100)\" , \"as\" : \"a\" }, { \"type\" : \"formula\" , \"expr\" : \"datum.a + round(random() * 60)\" , \"as\" : \"b\" } ], \"encoding\" : { \"x\" : { \"field\" : \"a\" , \"type\" : \"quantitative\" , \"scale\" : { \"zoom\" : true } }, \"x2\" : { \"field\" : \"b\" }, \"y\" : { \"field\" : \"data\" , \"type\" : \"nominal\" , \"scale\" : { \"padding\" : 0.3 } } }, \"layer\" : [ { \"mark\" : \"rect\" , \"encoding\" : { \"color\" : { \"value\" : \"#eaeaea\" } } }, { \"mark\" : { \"type\" : \"text\" , \"align\" : \"center\" , \"baseline\" : \"middle\" , \"paddingX\" : 5 }, \"encoding\" : { \"text\" : { \"expr\" : \"'Hello ' + floor(datum.a)\" , \"type\" : \"ordinal\" }, \"size\" : { \"value\" : 12 } } } ] }","title":"Text"},{"location":"grammar/mark/text/#text","text":"Text mark displays each data item as text. { \"data\" : { \"values\" : [ { \"x\" : 1 , \"text\" : \"Hello\" }, { \"x\" : 2 , \"text\" : \"world!\" } ] }, \"mark\" : \"text\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"ordinal\" }, \"color\" : { \"field\" : \"x\" , \"type\" : \"nominal\" }, \"text\" : { \"field\" : \"text\" , \"type\" : \"nominal\" }, \"size\" : { \"value\" : 100 } } }","title":"Text"},{"location":"grammar/mark/text/#channels","text":"In addition to standard position channels and color and opacity channels, point mark has the following channels: text Type: String The text to display. The format of numeric data can be customized by setting a format specifier to channel definition's format property. Default value: \"\" size Type: Number The font size in pixels. Default value: 11 angle Type: Number The rotation angle in degrees. Default value: 0","title":"Channels"},{"location":"grammar/mark/text/#properties","text":"font Type: String The font typeface. GenomeSpy uses SDF versions of Google Fonts . Check their availability at the A-Frame Fonts repository. The system fonts are not supported. Default value: \"Lato\" fontWeight Type: String | Number The font weight. The following strings and numbers are valid values: \"thin\" ( 100 ), \"light\" ( 300 ), \"regular\" ( 400 ), \"normal\" ( 400 ), \"medium\" ( 500 ), \"bold\" ( 700 ), \"black\" ( 900 ) Default value: \"regular\" fontStyle Type: String The font style. Valid values: \"normal\" and \"italic\" . Default value: \"normal\" align Type: String The horizontal alignment of the text. One of \"left\" , \"center\" , or \"right\" . Default value: \"left\" baseline Type: String The vertical alignment of the text. One of \"top\" , \"middle\" , \"bottom\" . Default value: \"bottom\" dX Type: Number Offset of the x coordinate in pixels. The offset is applied after the viewport scaling and translation. Default value: 0 dY Type: Number Offset of the x coordinate in pixels. The offset is applied after the viewport scaling and translation. Default value: 0","title":"Properties"},{"location":"grammar/mark/text/#examples","text":"","title":"Examples"},{"location":"grammar/mark/text/#ranged-text","text":"The x2 and y2 channels allow for positioning the text inside a segment. The text is either squeezed (default) or hidden if it does not fit in the segment. The squeeze property controls the behavior. The example below has two layers: gray rectangles at the bottom and ranged text on the top. Try to zoom and pan to see how they behave! { \"data\" : { \"values\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" ] }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"round(random() * 100)\" , \"as\" : \"a\" }, { \"type\" : \"formula\" , \"expr\" : \"datum.a + round(random() * 60)\" , \"as\" : \"b\" } ], \"encoding\" : { \"x\" : { \"field\" : \"a\" , \"type\" : \"quantitative\" , \"scale\" : { \"zoom\" : true } }, \"x2\" : { \"field\" : \"b\" }, \"y\" : { \"field\" : \"data\" , \"type\" : \"nominal\" , \"scale\" : { \"padding\" : 0.3 } } }, \"layer\" : [ { \"mark\" : \"rect\" , \"encoding\" : { \"color\" : { \"value\" : \"#eaeaea\" } } }, { \"mark\" : { \"type\" : \"text\" , \"align\" : \"center\" , \"baseline\" : \"middle\" , \"paddingX\" : 5 }, \"encoding\" : { \"text\" : { \"expr\" : \"'Hello ' + floor(datum.a)\" , \"type\" : \"ordinal\" }, \"size\" : { \"value\" : 12 } } } ] }","title":"Ranged text"},{"location":"grammar/transform/","text":"Data transformation \u00b6 With transforms, you can build a pipeline that modifies the data before the objects are mapped to marks. For example, they may filter or derive data, adding or removing fields or data objects. Departure from Vega-Lite The notation of transforms is different from Vega-Lite to enable more straghtforward addition of new operations. Each transform has to be specified using an explicit type property like in the lower-level Vega visualization grammar. Thus, the transform type is not inferred from the presence of transform-specific properties. Example \u00b6 The following example uses the \"filter\" transform to retain only the rows that match the predicate expression . { ... , \"data\" : { ... }, \"transform\" : [ { \"type\" : \"filter\" , \"expr\" : \"datum.end - datum.start < 5000\" } ], ... }","title":"Data transformation"},{"location":"grammar/transform/#data-transformation","text":"With transforms, you can build a pipeline that modifies the data before the objects are mapped to marks. For example, they may filter or derive data, adding or removing fields or data objects. Departure from Vega-Lite The notation of transforms is different from Vega-Lite to enable more straghtforward addition of new operations. Each transform has to be specified using an explicit type property like in the lower-level Vega visualization grammar. Thus, the transform type is not inferred from the presence of transform-specific properties.","title":"Data transformation"},{"location":"grammar/transform/#example","text":"The following example uses the \"filter\" transform to retain only the rows that match the predicate expression . { ... , \"data\" : { ... }, \"transform\" : [ { \"type\" : \"filter\" , \"expr\" : \"datum.end - datum.start < 5000\" } ], ... }","title":"Example"},{"location":"grammar/transform/aggregate/","text":"Aggregate \u00b6 The \"aggregate\" transform is currently minimal \u2013 it adds a new count field that contains the number of data items in a group. More aggregate operations will be added later. Parameters \u00b6 groupby Which fields to use for grouping. Missing groupby results in a single group that includes all the data items. Example \u00b6 Given the following data: x y first 123 first 456 second 789 ... and configuration: { \"type\" : \"aggregate\" , \"groupby\" : [ \"x\" ] } A new list of data objects is created: x count first 2 second 1","title":"Aggregate"},{"location":"grammar/transform/aggregate/#aggregate","text":"The \"aggregate\" transform is currently minimal \u2013 it adds a new count field that contains the number of data items in a group. More aggregate operations will be added later.","title":"Aggregate"},{"location":"grammar/transform/aggregate/#parameters","text":"groupby Which fields to use for grouping. Missing groupby results in a single group that includes all the data items.","title":"Parameters"},{"location":"grammar/transform/aggregate/#example","text":"Given the following data: x y first 123 first 456 second 789 ... and configuration: { \"type\" : \"aggregate\" , \"groupby\" : [ \"x\" ] } A new list of data objects is created: x count first 2 second 1","title":"Example"},{"location":"grammar/transform/collect/","text":"Collect \u00b6 The \"collect\" transform collects (buffers) the data items from the data flow into an internal array and optionally sorts them. Parameters \u00b6 groupby Arranges the data into consecutive batches based on the groups. This is mainly intended for internal use so that faceted data can be handled as batches. sort The sort order.","title":"Collect"},{"location":"grammar/transform/collect/#collect","text":"The \"collect\" transform collects (buffers) the data items from the data flow into an internal array and optionally sorts them.","title":"Collect"},{"location":"grammar/transform/collect/#parameters","text":"groupby Arranges the data into consecutive batches based on the groups. This is mainly intended for internal use so that faceted data can be handled as batches. sort The sort order.","title":"Parameters"},{"location":"grammar/transform/coverage/","text":"Coverage \u00b6 The \"coverage\" transform computes coverage for overlapping segments. The result is a new list of non-overlapping segments with the coverage values. The segments must be sorted by their start coordinates before passing them to the coverage transform. Parameters \u00b6 as The output field for the computed coverage. asChrom The output field for the chromosome. Default: Same as chrom asEnd The output field for the end coordinate. Default: Same as end asStart The output field for the start coordinate. Default: Same as start chrom An optional chromosome field that is passed through. TODO: groupby end Required The field representing the end coordinate of the segment (exclusive). start Required The field representing the start coordinate of the segment (inclusive). weight A field representing an optional weight for the segment. Can be used with copy ratios, for example. Example \u00b6 Given the following data: start end 0 4 1 3 ... and configuration: { \"type\" : \"coverage\" , \"start\" : \"startpos\" , \"end\" : \"endpos\" } A new list of segments is produced: start end coverage 0 1 1 1 3 2 3 4 1 Interactive example \u00b6 The following example demonstrates both \"coverage\" and \"pileup\" transforms. { \"data\" : { \"sequence\" : { \"start\" : 1 , \"stop\" : 100 , \"as\" : \"start\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"datum.start + ceil(random() * 20)\" , \"as\" : \"end\" } ], \"resolve\" : { \"scale\" : { \"x\" : \"shared\" } }, \"vconcat\" : [ { \"transform\" : [ { \"type\" : \"coverage\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"coverage\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"start\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"end\" }, \"y\" : { \"field\" : \"coverage\" , \"type\" : \"quantitative\" } } }, { \"transform\" : [ { \"type\" : \"pileup\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"lane\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"start\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"end\" }, \"y\" : { \"field\" : \"lane\" , \"type\" : \"index\" , \"scale\" : { \"padding\" : 0.2 , \"reverse\" : true , \"zoom\" : false } } } } ] }","title":"Coverage"},{"location":"grammar/transform/coverage/#coverage","text":"The \"coverage\" transform computes coverage for overlapping segments. The result is a new list of non-overlapping segments with the coverage values. The segments must be sorted by their start coordinates before passing them to the coverage transform.","title":"Coverage"},{"location":"grammar/transform/coverage/#parameters","text":"as The output field for the computed coverage. asChrom The output field for the chromosome. Default: Same as chrom asEnd The output field for the end coordinate. Default: Same as end asStart The output field for the start coordinate. Default: Same as start chrom An optional chromosome field that is passed through. TODO: groupby end Required The field representing the end coordinate of the segment (exclusive). start Required The field representing the start coordinate of the segment (inclusive). weight A field representing an optional weight for the segment. Can be used with copy ratios, for example.","title":"Parameters"},{"location":"grammar/transform/coverage/#example","text":"Given the following data: start end 0 4 1 3 ... and configuration: { \"type\" : \"coverage\" , \"start\" : \"startpos\" , \"end\" : \"endpos\" } A new list of segments is produced: start end coverage 0 1 1 1 3 2 3 4 1","title":"Example"},{"location":"grammar/transform/coverage/#interactive-example","text":"The following example demonstrates both \"coverage\" and \"pileup\" transforms. { \"data\" : { \"sequence\" : { \"start\" : 1 , \"stop\" : 100 , \"as\" : \"start\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"datum.start + ceil(random() * 20)\" , \"as\" : \"end\" } ], \"resolve\" : { \"scale\" : { \"x\" : \"shared\" } }, \"vconcat\" : [ { \"transform\" : [ { \"type\" : \"coverage\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"coverage\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"start\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"end\" }, \"y\" : { \"field\" : \"coverage\" , \"type\" : \"quantitative\" } } }, { \"transform\" : [ { \"type\" : \"pileup\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"lane\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"start\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"end\" }, \"y\" : { \"field\" : \"lane\" , \"type\" : \"index\" , \"scale\" : { \"padding\" : 0.2 , \"reverse\" : true , \"zoom\" : false } } } } ] }","title":"Interactive example"},{"location":"grammar/transform/filter-scored-labels/","text":"Filter Scored Lables \u00b6 The \"filterScoredLables\" transform fits prioritized labels into the available space, and dynamically reflows the data when the scale domain is adjusted (i.e., zoomed). TODO: Proper documentation. Parameters \u00b6 channel Default: \"x\" lane An optional field representing element's lane, e.g., if transcripts are shown using a piled up layout. padding Padding (in pixels) around the element. Default: 0 pos Required The field representing element's position on the domain. score Required The field representing the score used for prioritization. width Required The field representing element's width in pixels Example \u00b6 TODO","title":"FilterScoredLabels"},{"location":"grammar/transform/filter-scored-labels/#filter-scored-lables","text":"The \"filterScoredLables\" transform fits prioritized labels into the available space, and dynamically reflows the data when the scale domain is adjusted (i.e., zoomed). TODO: Proper documentation.","title":"Filter Scored Lables"},{"location":"grammar/transform/filter-scored-labels/#parameters","text":"channel Default: \"x\" lane An optional field representing element's lane, e.g., if transcripts are shown using a piled up layout. padding Padding (in pixels) around the element. Default: 0 pos Required The field representing element's position on the domain. score Required The field representing the score used for prioritization. width Required The field representing element's width in pixels","title":"Parameters"},{"location":"grammar/transform/filter-scored-labels/#example","text":"TODO","title":"Example"},{"location":"grammar/transform/filter/","text":"Filter \u00b6 The \"filter\" transform removes data objects based on a predicate expression . Parameters \u00b6 expr Required An expression string. The data object is removed if the expression evaluates to false. Example \u00b6 { \"type\" : \"filter\" , \"expr\" : \"datum.p <= 0.05\" } The example above retains all rows for which the field p is less than or equal to 0.05.","title":"Filter"},{"location":"grammar/transform/filter/#filter","text":"The \"filter\" transform removes data objects based on a predicate expression .","title":"Filter"},{"location":"grammar/transform/filter/#parameters","text":"expr Required An expression string. The data object is removed if the expression evaluates to false.","title":"Parameters"},{"location":"grammar/transform/filter/#example","text":"{ \"type\" : \"filter\" , \"expr\" : \"datum.p <= 0.05\" } The example above retains all rows for which the field p is less than or equal to 0.05.","title":"Example"},{"location":"grammar/transform/flatten-compressed-exons/","text":"Flatten Compressed Exons \u00b6 The \"flattenCompressedExons\" transform flattens \"delta encoded\" exons. The transform inputs the start coordinate of the gene body and a comma-delimited string of alternating intron and exon lengths. A new data object is created for each exon. This transform is mainly intended to be used with an optimized gene annotation track . Read more at an observable notebook . Parameters \u00b6 as Field names for the flattened exons. Default: [\"exonStart\", \"exonEnd\"] exons The field containing the exons. Default: \"exons\" start Start coordinate of the gene body. Default: \"start\" Example \u00b6 TODO","title":"FlattenCompressedExons"},{"location":"grammar/transform/flatten-compressed-exons/#flatten-compressed-exons","text":"The \"flattenCompressedExons\" transform flattens \"delta encoded\" exons. The transform inputs the start coordinate of the gene body and a comma-delimited string of alternating intron and exon lengths. A new data object is created for each exon. This transform is mainly intended to be used with an optimized gene annotation track . Read more at an observable notebook .","title":"Flatten Compressed Exons"},{"location":"grammar/transform/flatten-compressed-exons/#parameters","text":"as Field names for the flattened exons. Default: [\"exonStart\", \"exonEnd\"] exons The field containing the exons. Default: \"exons\" start Start coordinate of the gene body. Default: \"start\"","title":"Parameters"},{"location":"grammar/transform/flatten-compressed-exons/#example","text":"TODO","title":"Example"},{"location":"grammar/transform/flatten-delimited/","text":"Flatten Delimited \u00b6 The \"flattenDelimited\" transform flattens (or normalizes) a field or a set of fields that contain delimited values. In other words, each delimited value is written into a new data object that contains a single value from the delimited field. All other fields are copied as such. Parameters \u00b6 as The output field name(s) for the flattened field. Default: the input fields. field Required The field(s) to split and flatten separator Required Separator(s) used on the field(s) TODO: Rename to delimiter Example \u00b6 Given the following data: patient tissue value A Ova,Asc 4,2 B Adn,Asc,Ute 6,3,4 ... and configuration: { \"type\" : \"flattenDelimited\" , \"field\" : [ \"tissue\" , \"value\" ], \"separator\" : [ \",\" , \",\" ] } TODO: Rename separator to delimiter Flattened data is produced: patient tissue value A Ova 4 A Asc 2 B Adn 6 B Asc 3 B Ute 4","title":"FlattenDelimited"},{"location":"grammar/transform/flatten-delimited/#flatten-delimited","text":"The \"flattenDelimited\" transform flattens (or normalizes) a field or a set of fields that contain delimited values. In other words, each delimited value is written into a new data object that contains a single value from the delimited field. All other fields are copied as such.","title":"Flatten Delimited"},{"location":"grammar/transform/flatten-delimited/#parameters","text":"as The output field name(s) for the flattened field. Default: the input fields. field Required The field(s) to split and flatten separator Required Separator(s) used on the field(s) TODO: Rename to delimiter","title":"Parameters"},{"location":"grammar/transform/flatten-delimited/#example","text":"Given the following data: patient tissue value A Ova,Asc 4,2 B Adn,Asc,Ute 6,3,4 ... and configuration: { \"type\" : \"flattenDelimited\" , \"field\" : [ \"tissue\" , \"value\" ], \"separator\" : [ \",\" , \",\" ] } TODO: Rename separator to delimiter Flattened data is produced: patient tissue value A Ova 4 A Asc 2 B Adn 6 B Asc 3 B Ute 4","title":"Example"},{"location":"grammar/transform/flatten-sequence/","text":"Flatten Sequence \u00b6 The \"flattenSequence\" transform flattens strings such as FASTA sequences into data objecsts with position and character fields. Parameters \u00b6 as Name of the fields where the zero-based index number and flattened sequence letter are written to. Default: [\"pos\", \"sequence\"] field The field to flatten. Default: \"sequence\" Example \u00b6 Given the following data: identifier sequence X AC Y ACTG ... and parameters: { \"type\" : \"flattenSequence\" , \"field\" : \"sequence\" , \"as\" : [ \"base\" , \"pos\" ] } The sequences are flattened into: identifier sequence base pos X AC A 0 X AC C 1 Y ACTG A 0 Y ACTG C 1 Y ACTG T 2 Y ACTG G 3","title":"FlattenSequence"},{"location":"grammar/transform/flatten-sequence/#flatten-sequence","text":"The \"flattenSequence\" transform flattens strings such as FASTA sequences into data objecsts with position and character fields.","title":"Flatten Sequence"},{"location":"grammar/transform/flatten-sequence/#parameters","text":"as Name of the fields where the zero-based index number and flattened sequence letter are written to. Default: [\"pos\", \"sequence\"] field The field to flatten. Default: \"sequence\"","title":"Parameters"},{"location":"grammar/transform/flatten-sequence/#example","text":"Given the following data: identifier sequence X AC Y ACTG ... and parameters: { \"type\" : \"flattenSequence\" , \"field\" : \"sequence\" , \"as\" : [ \"base\" , \"pos\" ] } The sequences are flattened into: identifier sequence base pos X AC A 0 X AC C 1 Y ACTG A 0 Y ACTG C 1 Y ACTG T 2 Y ACTG G 3","title":"Example"},{"location":"grammar/transform/formula/","text":"Formula \u00b6 The \"formula\" transform uses an expression to calculate and add a new field to the data objects. Parameters \u00b6 as Required The (new) field where the computed value is written to expr Required An expression string Example \u00b6 Given the following data: x y 1 2 3 4 ... and configuration: { \"type\" : \"formula\" , \"expr\" : \"datum.x + datum.y\" , \"as\" : \"z\" } A new field is added: x y z 1 2 3 3 4 7","title":"Formula"},{"location":"grammar/transform/formula/#formula","text":"The \"formula\" transform uses an expression to calculate and add a new field to the data objects.","title":"Formula"},{"location":"grammar/transform/formula/#parameters","text":"as Required The (new) field where the computed value is written to expr Required An expression string","title":"Parameters"},{"location":"grammar/transform/formula/#example","text":"Given the following data: x y 1 2 3 4 ... and configuration: { \"type\" : \"formula\" , \"expr\" : \"datum.x + datum.y\" , \"as\" : \"z\" } A new field is added: x y z 1 2 3 3 4 7","title":"Example"},{"location":"grammar/transform/linearize-genomic-coordinate/","text":"Linearize Genomic Coordinate \u00b6 TODO Parameters \u00b6 as Required The output field or fields for linearized coordinates. channel Get the genome assembly from the scale of the channel. Default: \"x\" chrom Required The chromosome/contig field offset An offset or offsets that allow for adjusting the numbering base. The offset is subtracted from the positions. GenomeSpy uses internally zero-based indexing with half-open intervals. UCSC-based formats (BED, etc.) generally use this scheme. However, for example, VCF files use one-based indexing and must be adjusted by setting the offset to 1 . Default: 0 pos Required The field or fields that contain intra-chromosomal positions Example \u00b6 { \"type\" : \"linearizeGenomicCoordinate\" , \"chrom\" : \"chrom\" , \"pos\" : \"start\" , \"as\" : \"_start\" }","title":"LinearizeGenomicCoordinate"},{"location":"grammar/transform/linearize-genomic-coordinate/#linearize-genomic-coordinate","text":"TODO","title":"Linearize Genomic Coordinate"},{"location":"grammar/transform/linearize-genomic-coordinate/#parameters","text":"as Required The output field or fields for linearized coordinates. channel Get the genome assembly from the scale of the channel. Default: \"x\" chrom Required The chromosome/contig field offset An offset or offsets that allow for adjusting the numbering base. The offset is subtracted from the positions. GenomeSpy uses internally zero-based indexing with half-open intervals. UCSC-based formats (BED, etc.) generally use this scheme. However, for example, VCF files use one-based indexing and must be adjusted by setting the offset to 1 . Default: 0 pos Required The field or fields that contain intra-chromosomal positions","title":"Parameters"},{"location":"grammar/transform/linearize-genomic-coordinate/#example","text":"{ \"type\" : \"linearizeGenomicCoordinate\" , \"chrom\" : \"chrom\" , \"pos\" : \"start\" , \"as\" : \"_start\" }","title":"Example"},{"location":"grammar/transform/measure-text/","text":"Measure Text \u00b6 The \"measureText\" transforms measures the length of a string in pixels. The measurement can be used in downstream layout computations. Parameters \u00b6 as Required TODO field Required TODO fontSize Required TODO Example \u00b6 { \"type\" : \"measureText\" , \"fontSize\" : 11 , \"field\" : \"symbol\" , \"as\" : \"_textWidth\" }","title":"MeasureText"},{"location":"grammar/transform/measure-text/#measure-text","text":"The \"measureText\" transforms measures the length of a string in pixels. The measurement can be used in downstream layout computations.","title":"Measure Text"},{"location":"grammar/transform/measure-text/#parameters","text":"as Required TODO field Required TODO fontSize Required TODO","title":"Parameters"},{"location":"grammar/transform/measure-text/#example","text":"{ \"type\" : \"measureText\" , \"fontSize\" : 11 , \"field\" : \"symbol\" , \"as\" : \"_textWidth\" }","title":"Example"},{"location":"grammar/transform/pileup/","text":"Pileup \u00b6 The \"pileup\" transform computes a piled up layout for overlapping segments. The computed lane can be used to position the segments in a visualization. The segments must be sorted by their start coordinates before passing them to the pileup transform. Parameters \u00b6 as The output field name for the computed lane. Default: \"lane\" . end Required The field representing the end coordinate of the segment (exclusive). preference An optional field indicating the preferred lane. Use together with the preferredOrder property. preferredOrder The order of the lane preferences. The first element contains the value that should place the segment on the first lane and so forth. If the preferred lane is occupied, the first available lane is taken. spacing The spacing between adjacent segments on the same lane in coordinate units. Default: 1 . start Required The field representing the start coordinate of the segment (inclusive). Example \u00b6 Given the following data: start end 0 4 1 3 2 6 4 8 ... and configuration: { \"type\" : \"pileup\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"lane\" } A new field is added: start end lane 0 4 0 1 3 1 2 6 2 4 8 1 Interactive example \u00b6 The following example demonstrates both \"coverage\" and \"pileup\" transforms. { \"data\" : { \"sequence\" : { \"start\" : 1 , \"stop\" : 100 , \"as\" : \"start\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"datum.start + ceil(random() * 20)\" , \"as\" : \"end\" } ], \"resolve\" : { \"scale\" : { \"x\" : \"shared\" } }, \"vconcat\" : [ { \"transform\" : [ { \"type\" : \"coverage\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"coverage\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"start\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"end\" }, \"y\" : { \"field\" : \"coverage\" , \"type\" : \"quantitative\" } } }, { \"transform\" : [ { \"type\" : \"pileup\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"lane\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"start\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"end\" }, \"y\" : { \"field\" : \"lane\" , \"type\" : \"index\" , \"scale\" : { \"padding\" : 0.2 , \"reverse\" : true , \"zoom\" : false } } } } ] }","title":"Pileup"},{"location":"grammar/transform/pileup/#pileup","text":"The \"pileup\" transform computes a piled up layout for overlapping segments. The computed lane can be used to position the segments in a visualization. The segments must be sorted by their start coordinates before passing them to the pileup transform.","title":"Pileup"},{"location":"grammar/transform/pileup/#parameters","text":"as The output field name for the computed lane. Default: \"lane\" . end Required The field representing the end coordinate of the segment (exclusive). preference An optional field indicating the preferred lane. Use together with the preferredOrder property. preferredOrder The order of the lane preferences. The first element contains the value that should place the segment on the first lane and so forth. If the preferred lane is occupied, the first available lane is taken. spacing The spacing between adjacent segments on the same lane in coordinate units. Default: 1 . start Required The field representing the start coordinate of the segment (inclusive).","title":"Parameters"},{"location":"grammar/transform/pileup/#example","text":"Given the following data: start end 0 4 1 3 2 6 4 8 ... and configuration: { \"type\" : \"pileup\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"lane\" } A new field is added: start end lane 0 4 0 1 3 1 2 6 2 4 8 1","title":"Example"},{"location":"grammar/transform/pileup/#interactive-example","text":"The following example demonstrates both \"coverage\" and \"pileup\" transforms. { \"data\" : { \"sequence\" : { \"start\" : 1 , \"stop\" : 100 , \"as\" : \"start\" } }, \"transform\" : [ { \"type\" : \"formula\" , \"expr\" : \"datum.start + ceil(random() * 20)\" , \"as\" : \"end\" } ], \"resolve\" : { \"scale\" : { \"x\" : \"shared\" } }, \"vconcat\" : [ { \"transform\" : [ { \"type\" : \"coverage\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"coverage\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"start\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"end\" }, \"y\" : { \"field\" : \"coverage\" , \"type\" : \"quantitative\" } } }, { \"transform\" : [ { \"type\" : \"pileup\" , \"start\" : \"start\" , \"end\" : \"end\" , \"as\" : \"lane\" } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"start\" , \"type\" : \"index\" }, \"x2\" : { \"field\" : \"end\" }, \"y\" : { \"field\" : \"lane\" , \"type\" : \"index\" , \"scale\" : { \"padding\" : 0.2 , \"reverse\" : true , \"zoom\" : false } } } } ] }","title":"Interactive example"},{"location":"grammar/transform/project/","text":"Project \u00b6 The \"project\" transform retains the specified fields of the data objects, optionally renaming them. All other fields are removed. Parameters \u00b6 as New names for the projected fields. If omitted, the names of the source fields are used. fields Required The fields to be projected. Example \u00b6","title":"Project"},{"location":"grammar/transform/project/#project","text":"The \"project\" transform retains the specified fields of the data objects, optionally renaming them. All other fields are removed.","title":"Project"},{"location":"grammar/transform/project/#parameters","text":"as New names for the projected fields. If omitted, the names of the source fields are used. fields Required The fields to be projected.","title":"Parameters"},{"location":"grammar/transform/project/#example","text":"","title":"Example"},{"location":"grammar/transform/regex-extract/","text":"Regex Extract \u00b6 The \"regexExtract\" transform extracts groups from a string field and adds them to the data objects as new fields. Parameters \u00b6 as Required The new field or an array of fields where the extracted values are written. field Required The source field regex Required A valid JavaScript regular expression with at least one group. For example: \"^Sample(\\\\d+)$\" . Read more at: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions skipInvalidInput Do not complain about invalid input. Just skip it and leave the new fields undefined on the affected datum. Default: false Example \u00b6 Given the following data: Gene Genome Location AKT1 14:104770341-104792643 ... and configuration: { \"type\" : \"regexExtract\" , \"field\" : \"Genome Location\" , \"regex\" : \"^(X|Y|\\\\d+):(\\\\d+)-(\\\\d+)$\" , \"as\" : [ \"Chrom\" , \"Start\" , \"End\" ] } Three new fields are added to the data: Gene Genome Location Chrom Start End AKT1 14:104770341-104792643 14 104770341 104792643","title":"RegexExtract"},{"location":"grammar/transform/regex-extract/#regex-extract","text":"The \"regexExtract\" transform extracts groups from a string field and adds them to the data objects as new fields.","title":"Regex Extract"},{"location":"grammar/transform/regex-extract/#parameters","text":"as Required The new field or an array of fields where the extracted values are written. field Required The source field regex Required A valid JavaScript regular expression with at least one group. For example: \"^Sample(\\\\d+)$\" . Read more at: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions skipInvalidInput Do not complain about invalid input. Just skip it and leave the new fields undefined on the affected datum. Default: false","title":"Parameters"},{"location":"grammar/transform/regex-extract/#example","text":"Given the following data: Gene Genome Location AKT1 14:104770341-104792643 ... and configuration: { \"type\" : \"regexExtract\" , \"field\" : \"Genome Location\" , \"regex\" : \"^(X|Y|\\\\d+):(\\\\d+)-(\\\\d+)$\" , \"as\" : [ \"Chrom\" , \"Start\" , \"End\" ] } Three new fields are added to the data: Gene Genome Location Chrom Start End AKT1 14:104770341-104792643 14 104770341 104792643","title":"Example"},{"location":"grammar/transform/regex-fold/","text":"Regex Fold \u00b6 The \"regexFold\" transform gathers columns into key-value pairs using a regular expression. Parameters \u00b6 asKey Default: \"sample\" asValue Required A new column name for the extracted values. columnRegex Required A regular expression that matches to column names. The regex must have one capturing group that is used for extracting the key (e.g., a sample id) from the column name. skipRegex An optional regex that matches to fields that should not be included in the new folded data objects. Example \u00b6 Given the following data: SNP foo.AF bar.AF baz.AF rs99924582 0.3 0.24 0.94 rs22238423 0.92 0.21 0.42 ... and configuration: { \"type\" : \"regexFold\" , \"columnRegex\" : [ \"^(.*)\\\\.AF$\" ], \"asValue\" : [ \"VAF\" ], \"asKey\" : \"sample\" } The matched columns are folded into new data objects. All others are left intact: SNP sample VAF rs99924582 foo 0.3 rs99924582 bar 0.24 rs99924582 baz 0.94 rs22238423 foo 0.92 rs22238423 bar 0.21 rs22238423 baz 0.42","title":"RegexFold"},{"location":"grammar/transform/regex-fold/#regex-fold","text":"The \"regexFold\" transform gathers columns into key-value pairs using a regular expression.","title":"Regex Fold"},{"location":"grammar/transform/regex-fold/#parameters","text":"asKey Default: \"sample\" asValue Required A new column name for the extracted values. columnRegex Required A regular expression that matches to column names. The regex must have one capturing group that is used for extracting the key (e.g., a sample id) from the column name. skipRegex An optional regex that matches to fields that should not be included in the new folded data objects.","title":"Parameters"},{"location":"grammar/transform/regex-fold/#example","text":"Given the following data: SNP foo.AF bar.AF baz.AF rs99924582 0.3 0.24 0.94 rs22238423 0.92 0.21 0.42 ... and configuration: { \"type\" : \"regexFold\" , \"columnRegex\" : [ \"^(.*)\\\\.AF$\" ], \"asValue\" : [ \"VAF\" ], \"asKey\" : \"sample\" } The matched columns are folded into new data objects. All others are left intact: SNP sample VAF rs99924582 foo 0.3 rs99924582 bar 0.24 rs99924582 baz 0.94 rs22238423 foo 0.92 rs22238423 bar 0.21 rs22238423 baz 0.42","title":"Example"},{"location":"grammar/transform/sample/","text":"Sample \u00b6 The \"sample\" transform takes a random sample of the data objects. Parameters \u00b6 size The maximum sample size. Default: 500 Example \u00b6 { ... \"transform\" : [ { \"type\" : \"sample\" , \"size\" : 100 } ], ... }","title":"Sample"},{"location":"grammar/transform/sample/#sample","text":"The \"sample\" transform takes a random sample of the data objects.","title":"Sample"},{"location":"grammar/transform/sample/#parameters","text":"size The maximum sample size. Default: 500","title":"Parameters"},{"location":"grammar/transform/sample/#example","text":"{ ... \"transform\" : [ { \"type\" : \"sample\" , \"size\" : 100 } ], ... }","title":"Example"},{"location":"grammar/transform/stack/","text":"Stack \u00b6 The \"stack\" transform computes a stacked layout. Stacked bar plots and sequence logos are some of its applications. Parameters \u00b6 as Required Fields to write the stacked values. Default: [\"y0\", \"y1\"] baseField The field that contains the base or amino acid. Used for information content calculation when the offset is \"information\" . The data items that have null in the baseField are considered gaps and they are taken into account when scaling the the locus' information content. cardinality Cardinality, e.g., the number if distinct bases or amino acids. Used for information content calculation when the offset is \"information\" . Default: 4 ; field The field to stack. If no field is defined, a constant value of one is assumed. groupby Required The fields to be used for forming groups for different stacks. offset How to offset the values in a stack. \"zero\" (default) starts stacking at 0. \"center\" centers the values around zero. \"normalize\" computes intra-stack percentages and normalizes the values to the range of [0, 1] . \"information\" computes a layout for a sequence logo. The total height of the stack reflects the group's information content. sort The sort order of data in each stack. Examples \u00b6 Stacked bar plot \u00b6 { \"data\" : { \"values\" : [ { \"x\" : 1 , \"q\" : \"A\" , \"z\" : 7 }, { \"x\" : 1 , \"q\" : \"B\" , \"z\" : 3 }, { \"x\" : 1 , \"q\" : \"C\" , \"z\" : 10 }, { \"x\" : 2 , \"q\" : \"A\" , \"z\" : 8 }, { \"x\" : 2 , \"q\" : \"B\" , \"z\" : 5 }, { \"x\" : 3 , \"q\" : \"B\" , \"z\" : 10 } ] }, \"transform\" : [ { \"type\" : \"stack\" , \"field\" : \"z\" , \"groupby\" : [ \"x\" ] } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"nominal\" , \"band\" : 0.8 }, \"y\" : { \"field\" : \"y0\" , \"type\" : \"quantitative\" }, \"y2\" : { \"field\" : \"y1\" }, \"color\" : { \"field\" : \"q\" , \"type\" : \"nominal\" } } } Sequence logo \u00b6 { \"data\" : { \"values\" : [ { \"pos\" : 1 , \"base\" : \"A\" , \"count\" : 2 }, { \"pos\" : 1 , \"base\" : \"C\" , \"count\" : 3 }, { \"pos\" : 1 , \"base\" : \"T\" , \"count\" : 5 }, { \"pos\" : 2 , \"base\" : \"A\" , \"count\" : 7 }, { \"pos\" : 2 , \"base\" : \"C\" , \"count\" : 3 }, { \"pos\" : 3 , \"base\" : \"A\" , \"count\" : 10 }, { \"pos\" : 4 , \"base\" : \"T\" , \"count\" : 9 }, { \"pos\" : 4 , \"base\" : \"G\" , \"count\" : 1 }, { \"pos\" : 5 , \"base\" : \"G\" , \"count\" : 8 }, { \"pos\" : 6 , \"base\" : \"G\" , \"count\" : 7 } ] }, \"transform\" : [ { \"type\" : \"stack\" , \"field\" : \"count\" , \"groupby\" : [ \"pos\" ], \"offset\" : \"information\" , \"as\" : [ \"_y0\" , \"_y1\" ], \"baseField\" : \"base\" , \"sort\" : { \"field\" : \"count\" , \"order\" : \"ascending\" } } ], \"encoding\" : { \"x\" : { \"field\" : \"pos\" , \"type\" : \"index\" }, \"y\" : { \"field\" : \"_y0\" , \"type\" : \"quantitative\" , \"scale\" : { \"domain\" : [ 0 , 2 ] }, \"title\" : \"Information\" }, \"y2\" : { \"field\" : \"_y1\" }, \"text\" : { \"field\" : \"base\" , \"type\" : \"nominal\" }, \"color\" : { \"field\" : \"base\" , \"type\" : \"nominal\" , \"scale\" : { \"type\" : \"ordinal\" , \"domain\" : [ \"A\" , \"C\" , \"T\" , \"G\" ], \"range\" : [ \"#7BD56C\" , \"#FF9B9B\" , \"#86BBF1\" , \"#FFC56C\" ] } } }, \"mark\" : { \"type\" : \"text\" , \"font\" : \"Source Sans Pro\" , \"fontWeight\" : 700 , \"size\" : 100 , \"squeeze\" : true , \"fitToBand\" : true , \"paddingX\" : 0 , \"paddingY\" : 0 , \"logoLetters\" : true } }","title":"Stack"},{"location":"grammar/transform/stack/#stack","text":"The \"stack\" transform computes a stacked layout. Stacked bar plots and sequence logos are some of its applications.","title":"Stack"},{"location":"grammar/transform/stack/#parameters","text":"as Required Fields to write the stacked values. Default: [\"y0\", \"y1\"] baseField The field that contains the base or amino acid. Used for information content calculation when the offset is \"information\" . The data items that have null in the baseField are considered gaps and they are taken into account when scaling the the locus' information content. cardinality Cardinality, e.g., the number if distinct bases or amino acids. Used for information content calculation when the offset is \"information\" . Default: 4 ; field The field to stack. If no field is defined, a constant value of one is assumed. groupby Required The fields to be used for forming groups for different stacks. offset How to offset the values in a stack. \"zero\" (default) starts stacking at 0. \"center\" centers the values around zero. \"normalize\" computes intra-stack percentages and normalizes the values to the range of [0, 1] . \"information\" computes a layout for a sequence logo. The total height of the stack reflects the group's information content. sort The sort order of data in each stack.","title":"Parameters"},{"location":"grammar/transform/stack/#examples","text":"","title":"Examples"},{"location":"grammar/transform/stack/#stacked-bar-plot","text":"{ \"data\" : { \"values\" : [ { \"x\" : 1 , \"q\" : \"A\" , \"z\" : 7 }, { \"x\" : 1 , \"q\" : \"B\" , \"z\" : 3 }, { \"x\" : 1 , \"q\" : \"C\" , \"z\" : 10 }, { \"x\" : 2 , \"q\" : \"A\" , \"z\" : 8 }, { \"x\" : 2 , \"q\" : \"B\" , \"z\" : 5 }, { \"x\" : 3 , \"q\" : \"B\" , \"z\" : 10 } ] }, \"transform\" : [ { \"type\" : \"stack\" , \"field\" : \"z\" , \"groupby\" : [ \"x\" ] } ], \"mark\" : \"rect\" , \"encoding\" : { \"x\" : { \"field\" : \"x\" , \"type\" : \"nominal\" , \"band\" : 0.8 }, \"y\" : { \"field\" : \"y0\" , \"type\" : \"quantitative\" }, \"y2\" : { \"field\" : \"y1\" }, \"color\" : { \"field\" : \"q\" , \"type\" : \"nominal\" } } }","title":"Stacked bar plot"},{"location":"grammar/transform/stack/#sequence-logo","text":"{ \"data\" : { \"values\" : [ { \"pos\" : 1 , \"base\" : \"A\" , \"count\" : 2 }, { \"pos\" : 1 , \"base\" : \"C\" , \"count\" : 3 }, { \"pos\" : 1 , \"base\" : \"T\" , \"count\" : 5 }, { \"pos\" : 2 , \"base\" : \"A\" , \"count\" : 7 }, { \"pos\" : 2 , \"base\" : \"C\" , \"count\" : 3 }, { \"pos\" : 3 , \"base\" : \"A\" , \"count\" : 10 }, { \"pos\" : 4 , \"base\" : \"T\" , \"count\" : 9 }, { \"pos\" : 4 , \"base\" : \"G\" , \"count\" : 1 }, { \"pos\" : 5 , \"base\" : \"G\" , \"count\" : 8 }, { \"pos\" : 6 , \"base\" : \"G\" , \"count\" : 7 } ] }, \"transform\" : [ { \"type\" : \"stack\" , \"field\" : \"count\" , \"groupby\" : [ \"pos\" ], \"offset\" : \"information\" , \"as\" : [ \"_y0\" , \"_y1\" ], \"baseField\" : \"base\" , \"sort\" : { \"field\" : \"count\" , \"order\" : \"ascending\" } } ], \"encoding\" : { \"x\" : { \"field\" : \"pos\" , \"type\" : \"index\" }, \"y\" : { \"field\" : \"_y0\" , \"type\" : \"quantitative\" , \"scale\" : { \"domain\" : [ 0 , 2 ] }, \"title\" : \"Information\" }, \"y2\" : { \"field\" : \"_y1\" }, \"text\" : { \"field\" : \"base\" , \"type\" : \"nominal\" }, \"color\" : { \"field\" : \"base\" , \"type\" : \"nominal\" , \"scale\" : { \"type\" : \"ordinal\" , \"domain\" : [ \"A\" , \"C\" , \"T\" , \"G\" ], \"range\" : [ \"#7BD56C\" , \"#FF9B9B\" , \"#86BBF1\" , \"#FFC56C\" ] } } }, \"mark\" : { \"type\" : \"text\" , \"font\" : \"Source Sans Pro\" , \"fontWeight\" : 700 , \"size\" : 100 , \"squeeze\" : true , \"fitToBand\" : true , \"paddingX\" : 0 , \"paddingY\" : 0 , \"logoLetters\" : true } }","title":"Sequence logo"}]}