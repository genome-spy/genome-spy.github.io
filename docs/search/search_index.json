{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>GenomeSpy is a toolkit for interactive visualization of genomic and other data. It enables tailored visualizations by providing a declarative grammar, which allows for mapping data to visual channels (position, color, etc.) and composing complex visualization from primitive graphical marks (points, rectangles, etc.). The grammar is heavily inspired by Vega-Lite, providing partial compatibility and extending it with features essential in genome visualization.</p> <p>The visualizations are rendered using a carefully crafted WebGL-based engine, enabling fluid interaction and smooth animation for datasets comprising several million data points. The high interactive performance is achieved using GPU shader programs for all scale transformations and rendering of marks. However, shaders are an implementation detail hidden from the end users.</p> <p>The toolkit comprises two JavaScript packages:</p> <ol> <li>The core library implements the visualization grammar    and rendering engine and can be embedded in web pages or applications.</li> <li>The app extends the core library with support    for interactive analysis of large sample collections. It broadens the grammar    by introducing a facet operator that repeats a visualization for multiple    samples. The app also provides interactions for filtering, sorting, and    grouping these samples.</li> </ol> <p>Check the Getting Started page to get started with GenomeSpy and make your own tailored visualizations.</p>"},{"location":"#an-interactive-example","title":"An interactive example","text":"<p>The example below is interactive. You can zoom in using the mouse wheel.</p> <pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 200000, \"as\": \"x\" }\n},\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"random() * 0.682\", \"as\": \"u\" },\n{\n\"type\": \"formula\",\n\"expr\": \"((datum.u % 1e-8 &gt; 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618 + sin(datum.x / 10000)\",\n\"as\": \"y\"\n}\n],\n\"mark\": {\n\"type\": \"point\",\n\"geometricZoomBound\": 10.5\n},\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n\"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n\"size\": { \"value\": 200 },\n\"opacity\": { \"value\": 0.6 }\n}\n}\n</code></pre>"},{"location":"#about","title":"About","text":"<p>GenomeSpy is developed by Kari Lavikka in The Systems Biology of Drug Resistance in Cancer group at the University of Helsinki.</p> <p>This project has received funding from the European Union's Horizon 2020 Research and Innovation Programme under Grant agreement No. 667403 (HERCULES) and No. 965193 (DECIDER)</p>"},{"location":"api/","title":"JavaScript API","text":"<p>The public JavaScript API is currently quite minimal.</p>"},{"location":"api/#embedding","title":"Embedding","text":"<p>See the getting started page.</p>"},{"location":"api/#the-api","title":"The API","text":"<p>The <code>embed</code> function returns a promise that resolves into an object that provides the current public API. The API is documented in the interface definition.</p> <p>For practical examples on using the API, check the embed-examples package.</p>"},{"location":"api/#embed-options","title":"Embed options","text":"<p>The <code>embed</code> function accepts an optional options object.</p>"},{"location":"api/#named-data-provider","title":"Named data provider","text":"<p>See the API definition.</p>"},{"location":"api/#custom-tooltip-handlers","title":"Custom tooltip handlers","text":"<p>GenomeSpy provides two built-in tooltip handlers.</p> <p>The <code>default</code> handler displays the underlying datum's properties in a table. Property names starting with an underscore are omitted. The values are formatted nicely.</p> <p>The <code>refseqgene</code> handler fetches a summary description for a gene symbol using the Entrez API. For an example, check the RefSeq gene track in this notebook.</p> <p>Handlers are functions that receive the hovered mark's underlying datum and return a promise that resolves into a string, HTMLElement, or lit-html TemplateResult.</p> <p>The function signature:</p> <pre><code>export type TooltipHandler = (\ndatum: Record&lt;string, any&gt;,\nmark: Mark,\n/** Optional parameters from the view specification */\nparams?: Record&lt;string, any&gt;\n) =&gt; Promise&lt;string | TemplateResult | HTMLElement&gt;;\n</code></pre> <p>Use the <code>tooltipHandlers</code> option to register custom handlers or override the default. See the example below.</p>"},{"location":"api/#examples","title":"Examples","text":"<p>Overriding the <code>default</code> handler:</p> <pre><code>import { html } from \"lit-html\";\n\nconst options = {\ntooltipHandlers: {\ndefault: async (datum, mark, props) =&gt;\nhtml`\n        The datum has\n        &lt;strong&gt;${Object.keys(datum).length}&lt;/strong&gt; attributes!\n      `,\n},\n};\n\nembed(container, spec, options);\n</code></pre> <p>To use a specific (custom) handler in a view specification:</p> <pre><code>{\n\"mark\": {\n\"type\": \"point\",\n\"tooltip\": {\n\"handler\": \"myhandler\",\n\"params\": {\n\"custom\": \"param\"\n}\n}\n},\n...\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>There are three ways to get quickly started with GenomeSpy visualizations: the Playground app, Observable notebooks, and embedding GenomeSpy on HTML pages. More advanced users can use GenomeSpy as a visualization library in web applications.</p>"},{"location":"getting-started/#playground","title":"Playground","text":"<p>The easiest way to try out GenomeSpy is the Playground  app, which allows you to experiment with different visualization specifications directly in your web browser. You can load data from publicly accessible web servers or from your computer. The app is still rudimentary and does not support saving or sharing visualizations.</p>"},{"location":"getting-started/#observable-notebooks","title":"Observable notebooks","text":"<p>You can embed GenomeSpy into an Observable notebook. Please check the GenomeSpy collection for usage examples.</p>"},{"location":"getting-started/#local-or-remote-web-server","title":"Local or remote web server","text":"<p>For more serious work, you should use the GenomeSpy JavaScript library to create a web page for the visualization:</p> <ol> <li>Create an HTML document (web page) by using the example below</li> <li>Place the visualization spec and your data files into the same directory    as the HTML document</li> <li>Copy them onto a web server or start a local web server in the directory</li> </ol>"},{"location":"getting-started/#local-web-server","title":"Local web server","text":"<p>Python comes with an HTTP server module that can be started from command line:</p> <pre><code>python3 -m http.server --bind 127.0.0.1\n</code></pre> <p>By default, it serves files from the current working directory. See Python's documentation for details.</p>"},{"location":"getting-started/#html-template","title":"HTML template","text":"<p>The templates below load GenomeSpy from a content delivery network. Because the specification schema and the JavaScript API are not yet 100% stable, it is recommended to use a specific version.</p> <p>Check the latest version!</p> <p>The versions in the examples below may be slightly out of date. The current version is:</p> <p></p>"},{"location":"getting-started/#load-the-spec-from-a-file","title":"Load the spec from a file","text":"<p>This template loads the spec from the <code>spec.json</code> file.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;GenomeSpy&lt;/title&gt;\n    &lt;link\n      rel=\"stylesheet\"\n      type=\"text/css\"\n      href=\"https://unpkg.com/@genome-spy/core@0.28.x/dist/style.css\"\n    /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script\n      type=\"text/javascript\"\n      src=\"https://unpkg.com/@genome-spy/core@0.28.x/dist/index.js\"\n    &gt;&lt;/script&gt;\n\n    &lt;script&gt;\ngenomeSpyEmbed.embed(document.body, \"spec.json\", {});\n&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting-started/#embed-the-spec-in-the-html-document","title":"Embed the spec in the HTML document","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;GenomeSpy&lt;/title&gt;\n    &lt;link\n      rel=\"stylesheet\"\n      type=\"text/css\"\n      href=\"https://unpkg.com/@genome-spy/core@0.28.x/dist/style.css\"\n    /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script\n      type=\"text/javascript\"\n      src=\"https://unpkg.com/@genome-spy/core@0.28.x/dist/index.js\"\n    &gt;&lt;/script&gt;\n\n    &lt;script&gt;\nconst spec = {\ndata: {\nsequence: { start: 0, stop: 6.284, step: 0.39269908169, as: \"x\" },\n},\ntransform: [{ type: \"formula\", expr: \"sin(datum.x)\", as: \"sin\" }],\nmark: \"point\",\nencoding: {\nx: { field: \"x\", type: \"quantitative\" },\ny: { field: \"sin\", type: \"quantitative\" },\n},\n};\n\ngenomeSpyEmbed.embed(document.body, spec, {});\n&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting-started/#genomespyapp-website-examples","title":"Genomespy.app website examples","text":"<p>The examples on the genomespy.app main page are stored in the website-examples GitHub repository. You can clone the repository and launch the examples locally for further experimentation.</p>"},{"location":"getting-started/#using-genomespy-as-a-visualization-library-in-web-applications","title":"Using GenomeSpy as a visualization library in web applications","text":"<p>TODO</p> <p>Meanwhile, check the embed-examples package.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2018-2023 Kari Lavikka</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"license/#contains-code-from","title":"Contains Code From","text":""},{"location":"license/#vega-and-vega-lite","title":"Vega and Vega-Lite","text":"<p>Copyright (c) 2015, University of Washington Interactive Data Lab. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the University of Washington Interactive Data Lab   nor the names of its contributors may be used to endorse or promote products   derived from this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"genomic-data/genomic-coordinates/","title":"Genomic Coordinates","text":"<p>To allow easy visualization of coordinate-based genomic data, GenomeSpy can concatenate the discrete chromosomes onto a single continuous linear axis. Concatenation needs the sizes and preferred order for the contigs or chromosomes. These are usually provided with a genome assembly.</p> <p>To activate support for genomic coordinates, add the <code>genome</code> property with the name of the assembly to the top level view specification:</p> <pre><code>{\n\"genome\": {\n\"name\": \"hg38\"\n},\n...\n}\n</code></pre> <p>Only a single genome assembly</p> <p>Currently, a visualization may have only a single globally configured genome assembly. Different assemblies for different scales (for <code>x</code> and <code>y</code> axes, for example) will be supported in the future.</p>"},{"location":"genomic-data/genomic-coordinates/#supported-genomes","title":"Supported genomes","text":"<p>By default, GenomeSpy loads genomes from the genomespy.app website. The following assemblies are provided: <code>\"hg38\"</code>, <code>\"hg19\"</code>, <code>\"hg18\"</code>, <code>\"mm10\"</code>, <code>\"mm9\"</code>, and <code>\"dm6\"</code>.</p>"},{"location":"genomic-data/genomic-coordinates/#custom-genomes","title":"Custom genomes","text":"<p>At minimum, a custom genome needs a list of contigs and their sizes, which can be loaded from a <code>\"chrom.sizes\"</code> file or provided inline. Cytoband and Gene annotation tracks require additional files.</p>"},{"location":"genomic-data/genomic-coordinates/#as-files","title":"As files","text":"<p>The <code>baseUrl</code> property specifies the location of genomes:</p> <pre><code>{\n\"genome\": {\n\"name\": \"hg99\",\n\"baseUrl\": \"https://your.site/genomes/\"\n},\n...\n}\n</code></pre> <p>The directory must have the following structure:</p> <pre><code>hg99/hg99.chrom.sizes\nhg99/cytoBand.hg99.txt (optional)\nhg99/refSeq_genes_scored_compressed.hg99.txt (optional)\n</code></pre>"},{"location":"genomic-data/genomic-coordinates/#inline","title":"Inline","text":"<p>Example:</p> <pre><code>{\n\"genome\": {\n\"contigs\": [\n\"name\": \"chr3R\", \"size\": \"32079331\",\n\"name\": \"chr3L\", \"size\": \"28110227\",\n\"name\": \"chr2R\", \"size\": \"25286936\",\n\"name\": \"chrX\",  \"size\": \"23542271\",\n\"name\": \"chr2L\", \"size\": \"23513712\",\n\"name\": \"chrY\",  \"size\": \"3667352\",\n\"name\": \"chr4\",  \"size\": \"1348131\",\n]\n},\n...\n}\n</code></pre> <p>Cytobands and genome annotations cannot be provided inline.</p>"},{"location":"genomic-data/genomic-coordinates/#encoding-genomic-coordinates","title":"Encoding genomic coordinates","text":"<p>When a genome assembly has been specified, you can encode the genomic coordinates conveniently by specifying the chromosome (<code>chrom</code>) and position (<code>pos</code>) fields as follows:</p> <pre><code>{\n...,\n\"encoding\": {\n\"x\": {\n\"chrom\": \"Chr\",\n\"pos\": \"Pos\",\n\"offset\": -1.0,\n\"type\": \"locus\"\n},\n...\n}\n}\n</code></pre> <p>The example above specifies that the chromosome is read from the <code>\"Chr\"</code> field and the intra-chromosomal position from the <code>\"Pos\"</code> field. The <code>\"locus\"</code> data type pairs the channel with a <code>\"locus\"</code> scale, which provides a chromosome-aware axis. However, you can also use the <code>field</code> property with the locus data type if the coordinate has already been linearized. The <code>offset</code> property is explained below.</p> <p>What happens under the hood</p> <p>When the <code>chrom</code> and <code>pos</code> properties are used used in channel definitions, GenomeSpy inserts an implicit linearizeGenomicCoordinate transformation into the data flow. The transformation introduces a new field with the linearized coordinate for the (chromosome, position) pair. The channel definition is modified to use the new field.</p> <p>In some cases you may want to insert an explicit transformation to the data flow to have better control on its behavior.</p>"},{"location":"genomic-data/genomic-coordinates/#coordinate-counting","title":"Coordinate counting","text":"<p>The <code>offset</code> property allows for aligning and adjusting for different coordinate notations: zero or one based, closed or half-open. The offset is added to the final coordinate.</p> <p>GenomeSpy's <code>\"locus\"</code> scale expects half-open, zero-based coordinates.</p> <p>Read more about coordinates at the UCSC Genome Browser Blog.</p>"},{"location":"genomic-data/genomic-coordinates/#examples","title":"Examples","text":""},{"location":"genomic-data/genomic-coordinates/#point-features","title":"Point features","text":"<pre><code>{\n\"genome\": { \"name\": \"hg38\" },\n\"data\": {\n\"values\": [\n{ \"chrom\": \"chr3\", \"pos\": 134567890 },\n{ \"chrom\": \"chr4\", \"pos\": 123456789 },\n{ \"chrom\": \"chr9\", \"pos\": 34567890 }\n]\n},\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": {\n\"chrom\": \"chrom\",\n\"pos\": \"pos\",\n\"type\": \"locus\"\n}\n}\n}\n</code></pre>"},{"location":"genomic-data/genomic-coordinates/#segment-features","title":"Segment features","text":"<pre><code>{\n\"genome\": { \"name\": \"hg38\" },\n\"data\": {\n\"values\": [\n{ \"chrom\": \"chr3\", \"startpos\": 100000000, \"endpos\": 140000000 },\n{ \"chrom\": \"chr4\", \"startpos\": 70000000, \"endpos\": 170000000 },\n{ \"chrom\": \"chr9\", \"startpos\": 50000000, \"endpos\": 70000000 }\n]\n},\n\"mark\": \"rect\",\n\"encoding\": {\n\"x\": {\n\"chrom\": \"chrom\",\n\"pos\": \"startpos\",\n\"type\": \"locus\"\n},\n\"x2\": {\n\"chrom\": \"chrom\",\n\"pos\": \"endpos\"\n}\n}\n}\n</code></pre>"},{"location":"genomic-data/tracks/","title":"Provided Genome Tracks","text":"<p>Outdated information</p> <p>This functionality is currently broken. The annotations must be imported from external view specifications.</p> <p>GenomeSpy provides two tracks, that are intended to be used with genomic data. To add any of these tracks to your view specification, use the import directive.</p>"},{"location":"genomic-data/tracks/#cytoband-track","title":"Cytoband track","text":"<p>Name: <code>cytobands</code></p> <p>Cytoband track displays the cytobands if the genome configuration provides them.</p>"},{"location":"genomic-data/tracks/#gene-annotations","title":"Gene annotations","text":"<p>Name: <code>geneAnnotation</code></p> <p>Gene track displays RefSeq gene annotations. As it is impractical to show all 20 000 gene symbols at the same time, gene track uses score-based prioritization to display only the most popular genes of the currently visible region. For profound discussion on the popularity metric, read more in \"The most popular genes in the human genome\" in Nature.</p> <p>To save some precious screen estate, the isoforms of the genes in the provided annotation are unioned. Thus, each gene is displayed as a single \"virtual isoform\" (there are a few exceptions, though).</p> <p>Hovering the gene symbols with the mouse pointer fetches gene summary information from RefSeq and displays it in a tooltip.</p> <p>How the scoring is actually done</p> <ul> <li>Follow https://docs.higlass.io/data_preparation.html#gene-annotation-tracks</li> <li>Use <code>utils/compressGeneAnnotations.py</code>   to compress the <code>geneAnnotations.bed</code> file.</li> <li>Save the file as <code>refSeq_genes_scored_compressed.GENOME_NAME.txt</code> and   place it in the genome directory.</li> </ul>"},{"location":"genomic-data/tracks/#example","title":"Example","text":"<p>This example displays cytobands and gene annotations using the <code>hg38</code> genome assembly. It also imports a COSMIC Cancer Gene Census track from genomespy.app website.</p> <pre><code>{\n\"genome\": { \"name\": \"hg38\" },\n\"vconcat\": [\n{ \"import\": { \"name\": \"cytobands\" } },\n{ \"import\": { \"name\": \"geneAnnotation\" } },\n{\n\"import\": {\n\"url\": \"https://genomespy.app/tracks/cosmic/census_hg38.json\"\n}\n}\n]\n}\n</code></pre>"},{"location":"genomic-data/examples/ascat/","title":"Visualizing ASCAT profiles","text":"<p>This example visualizes an ASCAT profile and an allele-specific copy number segmentation along with the raw LogR and BAF data.</p> <p>The example has been moved to Observable.</p>"},{"location":"genomic-data/examples/seg-file/","title":"Visualizing a SEG file","text":"<p>Outdated information</p> <p>This example is currently broken because of recent changes made to the sample handling and importing.</p> <p>These examples visualize segmented data with two different visual encodings.</p> <p>The example data consists of segmentations for two samples. Each segment has a chromosome, intra-chromosomal start and end coordinates, and two quantitative values:</p> 'ID chrom loc.start loc.end num.mark seg.mean GenomeWideSNP_416532 1 51598 76187 14 -0.7116 GenomeWideSNP_416532 1 76204 16022502 8510 -0.029 GenomeWideSNP_416532 1 16026084 16026512 6 -2.0424 GenomeWideSNP_416532 1 16026788 17063449 424 -0.1024 ... ... ... ... ... ... <p>Data source: https://software.broadinstitute.org/software/igv/SEG</p>"},{"location":"genomic-data/examples/seg-file/#a-simple-example","title":"A simple example","text":"<p>The following example uses a conventional heatmap (<code>rect</code> mark) to display the segments. The color scale has been configured to match the Integrative Genomics Viewer.</p> <pre><code>{\n\"genome\": { \"name\": \"hg18\" },\n\n\"concat\": [\n{ \"import\": { \"name\": \"cytobands\" } },\n\n{\n\"data\": {\n\"url\": \"example.seg\",\n\"format\": { \"type\": \"tsv\" }\n},\n\n\"mark\": \"rect\",\n\n\"encoding\": {\n\"x\": { \"chrom\": \"chrom\", \"pos\": \"loc\\\\.start\", \"type\": \"quantitative\" },\n\"x2\": { \"chrom\": \"chrom\", \"pos\": \"loc\\\\.end\" },\n\"y\": { \"field\": \"\\\\'ID\", \"type\": \"nominal\" },\n\"color\": {\n\"field\": \"seg\\\\.mean\",\n\"type\": \"quantitative\",\n\"scale\": {\n\"domain\": [-1.5, 1.5],\n\"range\": [\"blue\", \"white\", \"red\"]\n}\n}\n}\n},\n\n{ \"import\": { \"name\": \"genomeAxis\" } }\n]\n}\n</code></pre>"},{"location":"genomic-data/examples/seg-file/#an-advanced-example-emphasizing-focal-segments","title":"An advanced example: emphasizing focal segments","text":"<p>The data contains focal segments that are short and barely visible. Although zooming reveals them, finding them all requires a lot of effort. The following example uses an alternative visual encoding for the data, emphasizing the focal segments.</p> <p>The quantitative value is encoded as position (height) instead of color. Focal segments are extracted from the data using the <code>filter</code> transform and displayed using <code>point</code> mark.</p> <pre><code>{\n\"genome\": {\n\"name\": \"hg18\"\n},\n\n\"concat\": [\n{\n\"import\": { \"name\": \"cytobands\" }\n},\n\n{\n\"name\": \"layers\",\n\"data\": {\n\"url\": \"example.seg\",\n\"format\": { \"type\": \"tsv\" }\n},\n\"encoding\": {\n\"sample\": { \"field\": \"\\\\'ID\", \"type\": \"nominal\" },\n\"color\": {\n\"field\": \"seg\\\\.mean\",\n\"type\": \"quantitative\",\n\"scale\": {\n\"type\": \"threshold\",\n\"domain\": [0],\n\"range\": [\"#2277ff\", \"#dd4422\"]\n}\n},\n\"y\": {\n\"field\": \"seg\\\\.mean\",\n\"type\": \"quantitative\"\n}\n},\n\"layer\": [\n{\n\"mark\": {\n\"type\": \"rect\",\n\"minWidth\": 1,\n\"minOpacity\": 0.2\n},\n\"encoding\": {\n\"x\": {\n\"chrom\": \"chrom\",\n\"pos\": \"loc\\\\.start\",\n\"type\": \"quantitative\"\n},\n\"x2\": { \"chrom\": \"chrom\", \"pos\": \"loc\\\\.end\" }\n}\n},\n{\n\"transform\": [\n{\n\"type\": \"filter\",\n\"expr\": \"datum['loc.end'] - datum['loc.start'] &lt; 8000\"\n},\n{\n\"type\": \"formula\",\n\"expr\": \"(datum['loc.start'] + datum['loc.end']) / 2\",\n\"as\": \"centre\"\n}\n],\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": {\n\"chrom\": \"chrom\",\n\"pos\": \"centre\",\n\"type\": \"quantitative\"\n},\n\"y\": {\n\"field\": \"seg\\\\.mean\",\n\"type\": \"quantitative\"\n},\n\"size\": {\n\"value\": 40\n}\n}\n}\n]\n},\n{\n\"import\": { \"name\": \"genomeAxis\" }\n}\n]\n}\n</code></pre>"},{"location":"grammar/","title":"Visualization Grammar","text":"<p>Genome browser applications typically couple the visual representations to specific file formats and provide few customization options. GenomeSpy has a more abstract approach to visualization, providing combinatorial building blocks such as marks, transformations, and scales. As a result, users can author tailored visualizations that display the underlying data more effectively.</p> <p>The concept was first introduced in The Grammar of Graphics and developed further in ggplot2 and Vega-Lite.</p> <p>A dialect of Vega-Lite</p> <p>The visualization grammar of GenomeSpy is a dialect of Vega-Lite, providing partial compatibility. However, the goals of GenomeSpy and Vega-Lite are different \u2013 GenomeSpy is more domain-specific and primarily intended for the visualization and analysis of large datasets containing genomic coordinates. Nevertheless, GenomeSpy tries to follow Vega-Lite's grammar where practical, and thus, this documentation has several references to its documentation.</p>"},{"location":"grammar/#a-single-view-specification","title":"A single view specification","text":"<p>Each view specification must have at least the <code>data</code> to be visualized, the <code>mark</code> that will represent the data items, and an <code>encoding</code> that specifies how the fields of data are mapped to the visual channels of the mark. In addition, an optional <code>transform</code> steps allow for modifying the data before they are encoded into mark instances.</p> <pre><code>{\n\"data\": { \"url\": \"sincos.csv\" },\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"abs(datum.sin)\", \"as\": \"abs(sin)\" }\n],\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"y\": { \"field\": \"abs(sin)\", \"type\": \"quantitative\" },\n\"size\": { \"field\": \"x\", \"type\": \"quantitative\" }\n}\n}\n</code></pre>"},{"location":"grammar/#properties","title":"Properties","text":"<code>data</code> Specifies a data source. If omitted, the data source is inherited from the parent view. <code>transform</code> An array of transformations applied to the data before visual encoding. <code>mark</code> The graphical mark presenting the data objects. <code>encoding</code> Specifies how data is encoded using the visual channels. <code>name</code> An internal name that can be used for referring the view. For referencing purposes, the name should be unique within the whole view hierarchy. <code>width</code> Width of the view. Check child sizing for details. <code>height</code> Height of the view. Check child sizing for details. <code>padding</code> Padding applied to the view. Accepts either a number reprenting pixels or a PaddingConfig. Example: <code>padding: { top: 10, right: 20, bottom: 10, left: 20 }</code> <code>title</code> View title. Accepts a string or a title specification object. N.B.: Currently, GenomeSpy doesn't do bound calculation, and you need to manually specify proper <code>padding</code> for the view to ensure that the title is visible. <code>description</code> A description of the view. Can be used for documentation. The description of the top-level view is shown in the toolbar of the GenomeSpy app. <code>baseUrl</code> The base URL for relative URL data sources. The base URLs are inherited in the view hierarchy unless overridden with this property. By default, the top-level view's base URL equals to the visualization specification's base URL. <code>opacity</code> TODO <code>visible</code> The default visibility of the view. An invisible view is removed from the layout and not rendered. For context, see toggleable view visibility."},{"location":"grammar/#view-composition-for-more-complex-visualizations","title":"View composition for more complex visualizations","text":"<p>View composition allows for building more complex visualizations from multiple single-view specifications. For example, the <code>layer</code> operator allows creation of custom glyphs and the concatenation operators enables stacked layouts resembling genome browsers with multiple tracks.</p>"},{"location":"grammar/data/","title":"Data Input","text":"<p>GenomeSpy inputs tabular data as <code>\"csv\"</code>, <code>\"tsv\"</code>, and <code>\"json\"</code> files. Currently, the only supported bioinformatic file format is non-indexed <code>\"fasta\"</code>. Other formats such as BED or BigWig are not directly supported. They must be first converted into one of the above tabular formats.</p> <p>GenomeSpy can load data from external files or use inline data. You can also use generators to generate data on the fly and modify them using transforms.</p> <p>The <code>data</code> property of the view specification describes a data source. The following example loads a tab-delimited file. By default, the format is inferred from the file extension. However, in bioinformatics, CSV files are often actually tab-delimited and the <code>\"tsv\"</code> format must be specified explicitly:</p> <pre><code>{\n\"data\": {\n\"url\": \"fileWithTabs.csv\",\n\"format\": { \"type\": \"tsv\" }\n},\n...\n}\n</code></pre> <p>With the exception of the unsupported geographical formats, the data property of GenomeSpy is identical to Vega-Lite's data property.</p> <p>Type inference</p> <p>GenomeSpy uses vega-loader to parse tabular data and infer its data types. Vega-loader is sometimes overly eager to interpret strings as a dates. In such cases, the field types need to be specified explicitly. On the other hand, explicit type specification also gives a significant performance boost to parsing performance.</p>"},{"location":"grammar/data/#named-data-sources","title":"Named Data Sources","text":"<p>Data can be added or updated at runtime using the API. Data sources are referenced by a name, which is passed to the <code>updateNamedData</code> method:</p> <pre><code>{\n\"name\": \"dynamicData\"\n}\n</code></pre> <pre><code>const api = await embed(\"#container\", spec);\napi.updateNamedData(\"dynamicData\", [\n{ x: 1, y: 2 },\n{ x: 2, y: 3 },\n]);\n</code></pre> <p>For practical examples, check the embed-examples package.</p>"},{"location":"grammar/data/#bioinformatic-formats","title":"Bioinformatic Formats","text":""},{"location":"grammar/data/#fasta","title":"FASTA","text":"<p>The type of FASTA format is <code>\"fasta\"</code> as shown in the example below:</p> <pre><code>{\n\"data\": {\n\"url\": \"16SRNA_Deino_87seq_copy.aln\",\n\"format\": {\n\"type\": \"fasta\"\n}\n},\n...\n}\n</code></pre> <p>The FASTA loader produces data objects with two fields: <code>\"identifier\"</code> and <code>\"sequence\"</code>. With the <code>\"flattenSequence\"</code> transform you can split the sequences into individual bases (one object per base) for easier visualization.</p>"},{"location":"grammar/expressions/","title":"Expressions","text":"<p>Expressions allow for defining predicates or computing new variables based on existing data. The expression language is based on JavaScript, but provides only a limited set of features, guaranteeing secure execution.</p> <p>Expressions can be used with the <code>\"filter\"</code> and <code>\"formula\"</code> transforms.</p>"},{"location":"grammar/expressions/#usage","title":"Usage","text":"<p>All basic arithmetic operators are supported:</p> <pre><code>(1 + 2) * 3 / 4\n</code></pre> <p>The current data object is provided as the <code>datum</code> object. Its properties (fields) can be accessed by using the dot or bracket notation:</p> <pre><code>datum.foo + 2\n</code></pre> <p>If the name of the property contains special characters such as \"<code>.</code>\", \"<code>!</code>\", or \"<code> </code>\" (a space) the bracket notation must be used:</p> <pre><code>datum['A very *special* name!'] &gt; 100\n</code></pre>"},{"location":"grammar/expressions/#conditional-operators","title":"Conditional operators","text":"<p>Ternary operator:</p> <pre><code>datum.foo &lt; 5 ? 'small' : 'large'\n</code></pre> <p>And an equivalent <code>if</code> construct:</p> <pre><code>if(datum.foo &lt; 5, 'small', 'large')\n</code></pre>"},{"location":"grammar/expressions/#provided-constants-and-functions","title":"Provided constants and functions","text":"<p>Common mathematical functions are supported:</p> <pre><code>(datum.u % 1e-8 &gt; 5e-9 ? 1 : -1) *\n(sqrt(-log(max(1e-9, datum.u))) - 0.618) *\n1.618\n</code></pre> <p>The full list of built-in constants and functions are documented in vega-expression.</p>"},{"location":"grammar/import/","title":"Importing Views","text":"<p>GenomeSpy facilitates reusing views by allowing them to be imported from external specification files. The files can be placed flexibly \u2013 it may be practical to split large specifications into multiple files and place them in the same directory. On the other hand, if you have created, for example, an annotation track that you would like the share with the research community, you can upload the specification file and the associated data to a publicly accessible web server.</p>"},{"location":"grammar/import/#importing-from-a-url","title":"Importing from a URL","text":"<p>Views can be imported from relative and absolute URLs. Relative URLs are imported with respect to the current <code>baseUrl</code>.</p> <p>The imported specification may contain a single, concatenated, or layered view. The <code>baseUrl</code> of the imported specification is updated to match the directory of the imported specification. Thus, you can publish a view (or a track as known in genome browsers) by placing its specification and data available in the same directory on a web server.</p> Example<pre><code>{\n...,\n\"vconcat\": [\n...,\n{ \"import\": { \"url\": \"includes/annotations.json\" } },\n{ \"import\": { \"url\": \"https://genomespy.app/tracks/cosmic/census_hg38.json\" } }\n]\n}\n</code></pre>"},{"location":"grammar/import/#importing-named-tracks","title":"Importing named tracks","text":"<p>Currently unsupported</p> <p>Named imports are currently not supported. Will be back at some point.</p>"},{"location":"grammar/scale/","title":"Scale","text":"<p>Scales are functions that map abstract data values (e.g., a type of a point mutation) to visual values (e.g., colors that indicate the type).</p> <p>By default, GenomeSpy configures scales automatically based on the data type (e.g., <code>\"ordinal\"</code>), the visual channel, and the data domain. As the defaults may not always be optimal, the scales can be configured explicitly.</p> Specifying a scale for a channel<pre><code>{\n\"encoding\": {\n\"y\": {\n\"field\": \"impact\",\n\"type\": \"quantitative\",\n\"scale\": {\n\"type\": \"linear\",\n\"domain\": [0, 1]\n}\n}\n},\n...\n}\n</code></pre>"},{"location":"grammar/scale/#vega-lite-scales","title":"Vega-Lite scales","text":"<p>GenomeSpy implements most of the scale types of Vega-Lite. The aim is to replicate their behavior identically (unless stated otherwise) in GenomeSpy. Although that has yet to fully materialize, Vega-Lite's scale documentation generally applies to GenomeSpy as well.</p> <p>The supported scales are: <code>\"linear\"</code>, <code>\"pow\"</code>, <code>\"sqrt\"</code>, <code>\"symlog\"</code>, <code>\"log\"</code>, <code>\"ordinal\"</code>, <code>\"band\"</code>, <code>\"point\"</code>, <code>\"quantize\"</code>, and <code>\"threshold\"</code>. Disabled scale is supported on quantitative channels such as <code>x</code> and <code>opacity</code>.</p> <p>Currently, the following scales are not supported: <code>\"time\"</code>, <code>\"utc\"</code>, <code>\"quantile\"</code>, <code>\"bin-linear\"</code>, <code>\"bin-ordinal\"</code>.</p> <p>Relation to Vega scales</p> <p>In fact, GenomeSpy uses Vega scales, which are based on d3-scale. However, GenomeSpy has GPU-based implementations for the actual scale transformations, ensuring high rendering performance.</p>"},{"location":"grammar/scale/#genomespy-specific-scales","title":"GenomeSpy-specific scales","text":"<p>GenomeSpy provides two additional scales that are designed for molecular sequence data.</p>"},{"location":"grammar/scale/#index-scale","title":"Index scale","text":"<p>The <code>\"index\"</code> scale allows mapping index-based values such as nucleotide or amino-acid locations to positional visual channels. It has traits from both the continuous <code>\"linear\"</code> and the discrete <code>\"band\"</code> scale. It is linear and zoomable but maps indices to the range like the band scale does \u2013 each index has its own band. Properties such as <code>padding</code> work just as in the band scale.</p> <p>The indices must be zero-based, i.e., the counting must start from zero. The numbering of the axis labels can be adjusted to give an impression of, for example, one-based indexing.</p> <p>The index scale is used by default when the field type is <code>\"index\"</code>.</p>"},{"location":"grammar/scale/#point-indices","title":"Point indices","text":"<p>When only the primary positional channel is defined, marks such as <code>\"rect\"</code> fill the whole band.</p> <pre><code>{\n\"data\": {\n\"values\": [0, 2, 4, 7, 8, 10, 12]\n},\n\"encoding\": {\n\"x\": { \"field\": \"data\", \"type\": \"index\" }\n},\n\"layer\": [\n{\n\"mark\": \"rect\",\n\"encoding\": {\n\"color\": { \"field\": \"data\", \"type\": \"nominal\" }\n}\n},\n{\n\"mark\": \"text\",\n\"encoding\": {\n\"text\": {\n\"field\": \"data\",\n\"type\": \"quantitative\"\n}\n}\n}\n]\n}\n</code></pre> <p>Marks such as <code>\"point\"</code> that do not support the secondary positional channel are centered.</p> <pre><code>{\n\"data\": {\n\"values\": [0, 2, 4, 7, 8, 10, 12]\n},\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": { \"field\": \"data\", \"type\": \"index\" },\n\"color\": { \"field\": \"data\", \"type\": \"nominal\" },\n\"size\": { \"value\": 300 }\n}\n}\n</code></pre>"},{"location":"grammar/scale/#range-indices","title":"Range indices","text":"<p>When the index scale is used with ranges, e.g., a <code>\"rect\"</code> mark that has both the <code>x</code> and <code>x2</code> channels defined, the ranges must be half open. For example, if a segment should cover the indices 2, 3, and 4, a half-open range would be defined as: x = 2 (inclusive), x2 = 5 (exclusive).</p> <pre><code>{\n\"data\": {\n\"values\": [\n{ \"from\": 0, \"to\": 2 },\n{ \"from\": 2, \"to\": 5 },\n{ \"from\": 8, \"to\": 9 },\n{ \"from\": 10, \"to\": 13 }\n]\n},\n\"encoding\": {\n\"x\": { \"field\": \"from\", \"type\": \"index\" },\n\"x2\": { \"field\": \"to\" }\n},\n\"layer\": [\n{\n\"mark\": \"rect\",\n\"encoding\": {\n\"color\": { \"field\": \"from\", \"type\": \"nominal\" }\n}\n},\n{\n\"mark\": \"text\",\n\"encoding\": {\n\"text\": {\n\"expr\": \"'[' + datum.from + ', ' + datum.to + ')'\",\n\"type\": \"nominal\"\n}\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/scale/#adjusting-the-indexing-of-axis-labels","title":"Adjusting the indexing of axis labels","text":"<p>The index scale expects zero-based indexing. However, it may be desirable to display the axis labels using one-based indexing. Use the <code>numberingOffset</code> property adjust the label indices.</p> <pre><code>{\n\"data\": {\n\"values\": [0, 2, 4, 7, 8, 10, 12]\n},\n\"encoding\": {\n\"x\": {\n\"field\": \"data\",\n\"type\": \"index\",\n\"scale\": {\n\"numberingOffset\": 1\n}\n}\n},\n\"layer\": [\n{\n\"mark\": \"rect\",\n\"encoding\": {\n\"color\": { \"field\": \"data\", \"type\": \"nominal\" }\n}\n},\n{\n\"mark\": \"text\",\n\"encoding\": {\n\"text\": {\n\"field\": \"data\",\n\"type\": \"quantitative\"\n}\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/scale/#locus-scale","title":"Locus scale","text":"<p>The <code>\"locus\"</code> scale is similar to the <code>\"index\"</code> scale, but provides a genome-aware axis with concatenated chromosomes. To use the locus scale, a genome must be specified.</p> <p>The locus scale is used by default when the field type is <code>\"locus\"</code>.</p> <p>Note</p> <p>The locus scale does not map the discrete chromosomes onto the concatenated axis. It's done by the linearizeGenomicCoordinate transform.</p>"},{"location":"grammar/scale/#specifying-the-domain","title":"Specifying the domain","text":"<p>By default, the domain of the locus scale consists of the whole genome. However, You can specify a custom domain using either linearized or genomic coordinates. A genomic coordinate consists of a chromosome (<code>chrom</code>) and an optional position (<code>pos</code>). The left bound's position defaults to zero, whereas the right bound's position defaults to the size of the chromosome. Thus, the chromosomes are inclusive.</p> <p>For example, chromosomes 3, 4, and 5:</p> <pre><code>[{ \"chrom\": \"chr3\" }, { \"chrom\": \"chr5\" }]\n</code></pre> <p>Only the chromosome 3:</p> <pre><code>[{ \"chrom\": \"chr3\" }]\n</code></pre> <p>A specific region inside the chromosome 3:</p> <pre><code>[\n{ \"chrom\": \"chr3\", \"pos\": 1000000 },\n{ \"chrom\": \"chr3\", \"pos\": 2000000 }\n]\n</code></pre> <p>Somewhere inside the chromosome 1:</p> <pre><code>[1000000, 2000000]\n</code></pre>"},{"location":"grammar/scale/#example","title":"Example","text":"<pre><code>{\n\"genome\": { \"name\": \"hg38\" },\n\"data\": {\n\"values\": [\n{ \"chrom\": \"chr3\", \"pos\": 134567890 },\n{ \"chrom\": \"chr4\", \"pos\": 123456789 },\n{ \"chrom\": \"chr9\", \"pos\": 34567890 }\n]\n},\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": {\n\"chrom\": \"chrom\",\n\"pos\": \"pos\",\n\"type\": \"locus\",\n\"scale\": {\n\"domain\": [{ \"chrom\": \"chr3\" }, { \"chrom\": \"chr9\" }]\n}\n},\n\"size\": { \"value\": 200 }\n}\n}\n</code></pre>"},{"location":"grammar/scale/#zooming-and-panning","title":"Zooming and panning","text":"<p>To enable zooming and panning of continuous scales on positional channels, set the <code>zoom</code> scale property to <code>true</code>. Example:</p> <pre><code>{\n\"x\": {\n\"field\": \"foo\",\n\"type\": \"quantitative\",\n\"scale\": {\n\"zoom\": true\n}\n}\n}\n</code></pre> <p>Both <code>\"index\"</code> and <code>\"locus\"</code> scales are zoomable by default.</p>"},{"location":"grammar/scale/#zoom-extent","title":"Zoom extent","text":"<p>The zoom <code>extent</code> allows you to control how far the scale can be zoomed out or panned (translated). Zoom extent equals the scale domain by default, except for the <code>\"locus\"</code> scale, where it includes the whole genome. Example:</p> <pre><code>{\n...,\n\"scale\": {\n\"domain\": [10, 20],\n\"zoom\": {\n\"extent\": [0, 30]\n}\n}\n}\n</code></pre>"},{"location":"grammar/scale/#named-scales","title":"Named scales","text":"<p>By giving the scale a name, it can be accessed through the API.</p> <pre><code>{\n...,\n\"scale\": {\n\"name\": \"myScale\"\n}\n}\n</code></pre>"},{"location":"grammar/tooltip/","title":"Tooltip","text":"<p>TODO</p>"},{"location":"grammar/composition/","title":"View Composition","text":"<p>GenomeSpy replicates the hierarchical composition model of Vega-Lite, and currently provides the concatenation and <code>layer</code> composition operators in the core library. In addition, the GenomeSpy app provides a facet operator for visualizing sample collections using a track-based layout.</p> <p>The hierarchical model allows for nesting composition operators. For instance, you could have a visualization with two views side by side, and those views could contain multiple layered views. The views in the hierarchy inherit (transformed) <code>data</code> and <code>encoding</code> from their parents, and in some cases, the views may also share scales and axes with their siblings and parents. The data and encoding inherited from ancestors can always be overridden by the descendants.</p>"},{"location":"grammar/composition/#scale-and-axis-resolution","title":"Scale and axis resolution","text":"<p>Each visual channel of a view has a scale, which is either <code>\"independent\"</code> or <code>\"shared\"</code> with other views. For example, sharing the scale on the positional <code>x</code> channel links the zooming interactions of the participanting views through the shared scale domain. The axes of positional channels can be configured similarly.</p> <p>The <code>resolve</code> property configures the scale and axis resolutions for the view's children.</p> An example of a resolution configuration<pre><code>{\n\"resolve\": {\n\"scale\": {\n\"x\": \"shared\",\n\"y\": \"independent\",\n\"color\": \"independent\"\n},\n\"axis\": {\n\"x\": \"shared\",\n\"y\": \"independent\"\n}\n},\n...\n}\n</code></pre>"},{"location":"grammar/composition/#shared","title":"Shared","text":"<p>The example below shows an excerpt of segmented copy number data layered on raw SNP logR values. The scale of the <code>y</code> channel is shared by default and the domain is unioned. As the <code>x</code> channel's scale is also shared, the zooming interaction affects both views.</p> <pre><code>{\n\"layer\": [\n{\n\"data\": { \"url\": \"../data/cnv_chr19_raw.tsv\" },\n\"title\": \"Single probe\",\n\n\"mark\": {\n\"type\": \"point\",\n\"geometricZoomBound\": 9.5\n},\n\n\"encoding\": {\n\"x\": { \"field\": \"Position\", \"type\": \"index\" },\n\"y\": { \"field\": \"logR\", \"type\": \"quantitative\" },\n\"size\": { \"value\": 225 },\n\"opacity\": { \"value\": 0.15 }\n}\n},\n{\n\"data\": {\n\"url\": \"../data/cnv_chr19_segs.tsv\"\n},\n\"title\": \"Segment mean\",\n\"mark\": {\n\"type\": \"rule\",\n\"size\": 3.0,\n\"minLength\": 3.0,\n\"color\": \"black\"\n},\n\"encoding\": {\n\"x\": { \"field\": \"startpos\", \"type\": \"index\" },\n\"x2\": { \"field\": \"endpos\" },\n\"y\": { \"field\": \"segMean\", \"type\": \"quantitative\" }\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/composition/#independent","title":"Independent","text":"<p>By specifying that the scales of the <code>y</code> channel should remain <code>\"independent\"</code>, both layers get their own scales and axes. Obviously, such a configuration makes no sense with these data.</p> <pre><code>{\n\"resolve\": {\n\"scale\": { \"y\": \"independent\" },\n\"axis\": { \"y\": \"independent\" }\n},\n\"layer\": [\n{\n\"data\": { \"url\": \"../data/cnv_chr19_raw.tsv\" },\n\"title\": \"Single probe\",\n\n\"mark\": {\n\"type\": \"point\",\n\"geometricZoomBound\": 9.5\n},\n\n\"encoding\": {\n\"x\": { \"field\": \"Position\", \"type\": \"index\" },\n\"y\": { \"field\": \"logR\", \"type\": \"quantitative\" },\n\"size\": { \"value\": 225 },\n\"opacity\": { \"value\": 0.15 }\n}\n},\n{\n\"data\": {\n\"url\": \"../data/cnv_chr19_segs.tsv\"\n},\n\"title\": \"Segment mean\",\n\"mark\": {\n\"type\": \"rule\",\n\"size\": 3.0,\n\"minLength\": 3.0,\n\"color\": \"black\"\n},\n\"encoding\": {\n\"x\": { \"field\": \"startpos\", \"type\": \"index\" },\n\"x2\": { \"field\": \"endpos\" },\n\"y\": { \"field\": \"segMean\", \"type\": \"quantitative\" }\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/composition/concat/","title":"View Concatenation","text":"<p>The <code>vconcat</code> and <code>hconcat</code> composition operators place views side-by-side either vertically or horizontally. The <code>vconcat</code> is practical for building genomic visualizations with multiple tracks.</p> <p>The spacing (in pixels) between concatenated views can be adjusted using the <code>spacing</code> property (Default: <code>10</code>).</p>"},{"location":"grammar/composition/concat/#example","title":"Example","text":""},{"location":"grammar/composition/concat/#vertical","title":"Vertical","text":"<pre><code>{\n\"data\": { \"url\": \"sincos.csv\" },\n\n\"spacing\": 20,\n\n\"vconcat\": [\n{\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"y\": { \"field\": \"sin\", \"type\": \"quantitative\" }\n}\n},\n{\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"y\": { \"field\": \"cos\", \"type\": \"quantitative\" }\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#horizontal","title":"Horizontal","text":"<pre><code>{\n\"data\": { \"url\": \"sincos.csv\" },\n\n\"hconcat\": [\n{\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"y\": { \"field\": \"sin\", \"type\": \"quantitative\" }\n}\n},\n{\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"y\": { \"field\": \"cos\", \"type\": \"quantitative\" }\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#child-sizing","title":"Child sizing","text":"<p>The concatenation operators mimic the behavior of the CSS flexbox. The child views have an absolute minimum size (<code>px</code>) in pixels and an unitless <code>grow</code> value that specifies in what proportion the possible remaining space should be distributed. The remaining space depends on the parent view's size.</p> <p>In the following example, the left view has a width of <code>20</code> px, the center view has a grow of <code>1</code>, and the right view has a grow of <code>2</code>. If you resize the web browser, you can observe that the width of the left view stays constant while the remaining space is distributed in proportions of 1:2.</p> <pre><code>{\n\"data\": { \"values\": [{}] },\n\n\"spacing\": 10,\n\n\"hconcat\": [\n{\n\"width\": { \"px\": 20 },\n\"mark\": \"rect\"\n},\n{\n\"width\": { \"grow\": 1 },\n\"mark\": \"rect\"\n},\n{\n\"width\": { \"grow\": 2 },\n\"mark\": \"rect\"\n}\n]\n}\n</code></pre> <p>The size may have both absolute (<code>px</code>) and proportional (<code>grow</code>) components. When views are nested, both the absolute and proportional sizes are added up. Thus, the width of the above example is <code>{ \"px\": 40, \"grow\": 3 }</code>. The spacing between the child views is added to the total absolute width.</p> <p>Views' size properties (<code>width</code> and <code>height</code>) accept both SizeDef objects and shorthands. The SizeDef objects contain either or both of <code>px</code> and <code>grow</code> properties. Numbers are interpreted as as absolute sizes, and <code>\"container\"</code> is the same as <code>{ grow: 1 }</code>. Undefined sizes generally default to <code>\"container\"</code>.</p> <p>Concatenation operators can nested flexibly to build complex layouts as in the following example.</p> <pre><code>{\n\"data\": { \"values\": [{}] },\n\n\"hconcat\": [\n{ \"mark\": \"rect\" },\n{\n\"vconcat\": [{ \"mark\": \"rect\" }, { \"mark\": \"rect\" }]\n}\n]\n}\n</code></pre>"},{"location":"grammar/composition/concat/#resolve","title":"Resolve","text":"<p>By default, all channels have independent scales and axes.</p>"},{"location":"grammar/composition/layer/","title":"Layering Views","text":"<p>The <code>layer</code> operator superimposes multiple views over each other.</p>"},{"location":"grammar/composition/layer/#example","title":"Example","text":"<pre><code>{\n\"data\": {\n\"values\": [\n{ \"a\": \"A\", \"b\": 28 },\n{ \"a\": \"B\", \"b\": 55 },\n{ \"a\": \"C\", \"b\": 43 },\n{ \"a\": \"D\", \"b\": 91 },\n{ \"a\": \"E\", \"b\": 81 },\n{ \"a\": \"F\", \"b\": 53 },\n{ \"a\": \"G\", \"b\": 19 },\n{ \"a\": \"H\", \"b\": 87 },\n{ \"a\": \"I\", \"b\": 52 }\n]\n},\n\"encoding\": {\n\"x\": {\n\"field\": \"a\",\n\"type\": \"nominal\",\n\"scale\": { \"padding\": 0.1 },\n\"axis\": { \"labelAngle\": 0 }\n},\n\"y\": { \"field\": \"b\", \"type\": \"quantitative\" }\n},\n\"layer\": [\n{\n\"name\": \"Bar\",\n\"mark\": \"rect\"\n},\n{\n\"name\": \"Label\",\n\"mark\": { \"type\": \"text\", \"dy\": -9 },\n\"encoding\": {\n\"text\": { \"field\": \"b\", \"type\": \"quantitative\" }\n}\n}\n]\n}\n</code></pre> <p>To specify multiple layers, use the <code>layer</code> property:</p> <pre><code>{\n\"layer\": [\n...  // Single or layered view specifications\n]\n}\n</code></pre> <p>The provided array may contain both single view specifications and layered specifications. The encodings and data that are specified in a layer view propagate to its descendants. For example, in the above example, the \"Bar\" and \"Label\" views inherit the data and the encodings for the <code>x</code> and <code>y</code> channels from their parent, the layer view.</p>"},{"location":"grammar/composition/layer/#resolve","title":"Resolve","text":"<p>By default, layers share their scales and axes, unioning the data domains.</p>"},{"location":"grammar/composition/layer/#more-examples","title":"More examples","text":""},{"location":"grammar/composition/layer/#lollipop-plot","title":"Lollipop plot","text":"<p>This example layers two marks to create a composite mark, a lollipop. Yet another layer is used for the baseline.</p> <pre><code>{\n\"name\": \"The Root\",\n\"description\": \"Lollipop plot example\",\n\n\"resolve\": { \"axis\": { \"y\": \"independent\" } },\n\n\"layer\": [\n{\n\"name\": \"Baseline\",\n\"data\": { \"values\": [0] },\n\"mark\": \"rule\",\n\"encoding\": {\n\"y\": { \"field\": \"data\", \"type\": \"quantitative\", \"axis\": null },\n\"color\": { \"value\": \"lightgray\" }\n}\n},\n{\n\"name\": \"Arrows\",\n\n\"data\": {\n\"sequence\": {\n\"start\": 0,\n\"stop\": 6.284,\n\"step\": 0.39269908169,\n\"as\": \"x\"\n}\n},\n\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"sin(datum.x)\", \"as\": \"sin(x)\" }\n],\n\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"y\": {\n\"field\": \"sin(x)\",\n\"type\": \"quantitative\",\n\"scale\": { \"padding\": 0.1 }\n},\n\"color\": { \"field\": \"sin(x)\", \"type\": \"quantitative\" }\n},\n\n\"layer\": [\n{\n\"name\": \"Arrow shafts\",\n\n\"mark\": {\n\"type\": \"rule\",\n\"size\": 3\n}\n},\n{\n\"name\": \"Arrowheads\",\n\n\"mark\": {\n\"type\": \"point\",\n\"size\": 500,\n\"strokeWidth\": 0\n},\n\n\"encoding\": {\n\"shape\": {\n\"field\": \"sin(x)\",\n\"type\": \"nominal\",\n\"scale\": {\n\"type\": \"threshold\",\n\"domain\": [-0.01, 0.01],\n\"range\": [\"triangle-down\", \"diamond\", \"triangle-up\"]\n}\n}\n}\n}\n]\n}\n]\n}\n</code></pre>"},{"location":"grammar/encoding/","title":"Encoding","text":"<p>The encoding object specifies how variables of the data are mapped to different visual properties (channels) of the graphical marks.</p> <p>TODO</p> <pre><code>// Specification of a Single View\n{\n\"data\": ... ,\n\"mark\": ... ,\n\"encoding\": {     // Encoding\n// Position Channels\n\"x\": ...,\n\"y\": ...,\n\"x2\": ...,\n\"y2\": ...,\n\n// Mark Properties Channels\n\"color\": ...,\n\"opacity\": ...,\n\"strokeWidth\": ...,\n\"size\": ...,\n\"shape\": ...,\n},\n...\n}\n</code></pre>"},{"location":"grammar/encoding/#position-channels","title":"Position channels","text":"<p>TODO</p>"},{"location":"grammar/encoding/#mark-property-channels","title":"Mark property channels","text":"<p>TODO</p>"},{"location":"grammar/encoding/#fields","title":"Fields","text":"<p>TODO</p>"},{"location":"grammar/encoding/#expressions","title":"Expressions","text":"<p>TODO</p>"},{"location":"grammar/encoding/#values","title":"Values","text":"<p>TODO</p>"},{"location":"grammar/encoding/#genomic-coordinates","title":"Genomic coordinates","text":"<p>TODO</p>"},{"location":"grammar/encoding/axis/","title":"Axis","text":"<p>TODO</p>"},{"location":"grammar/mark/link/","title":"Link","text":"<p>The <code>\"link\"</code> mark displays each data item as a curve that connects two points. The mark can be used to display structural variation and interactions, for example.</p> <pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 30, \"as\": \"z\" }\n},\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"round(random() * 800)\", \"as\": \"x\" },\n{\n\"type\": \"formula\",\n\"expr\": \"round(datum.x + pow(2, random() * 10))\",\n\"as\": \"x2\"\n}\n],\n\"mark\": \"link\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"index\" },\n\"x2\": { \"field\": \"x2\" }\n}\n}\n</code></pre> <p>Still under development</p> <p>The parameterization is likely to be changed a bit to support more use cases.</p>"},{"location":"grammar/mark/link/#channels","title":"Channels","text":"<p>In addition to the standard position channels and <code>color</code> and <code>opacity</code> channels, link mark supports the following channels:</p> <code>size</code> <p>Type: Number</p> <p>Stroke width of the starting point in pixels.</p> <code>size2</code> <p>Type: Number</p> <p>Stroke width of the end point in pixels. Same as <code>size</code> if left undefined.</p> <code>color2</code> <p>Type: Number</p> <p>Color of the end point. Same as <code>color</code> if left undefined.</p>"},{"location":"grammar/mark/link/#properties","title":"Properties","text":"<code>segments</code> <p>Type: Number</p> <p>Number of segments in the b\u00e9zier curve. Affects the rendering quality and speed.</p> <p>Default value: <code>101</code></p>"},{"location":"grammar/mark/link/#examples","title":"Examples","text":"<pre><code>{\n\"width\": 300,\n\"height\": 300,\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 12, \"as\": \"z\" }\n},\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"datum.z / 12 * 3.141 * 2\", \"as\": \"theta\" },\n{ \"type\": \"formula\", \"expr\": \"cos(datum.theta)\", \"as\": \"x\" },\n{ \"type\": \"formula\", \"expr\": \"sin(datum.theta)\", \"as\": \"y\" }\n],\n\"mark\": {\n\"type\": \"link\",\n\"size\": 10,\n\"size2\": 0\n},\n\"encoding\": {\n\"x\": { \"datum\": 0, \"type\": \"quantitative\" },\n\"x2\": { \"field\": \"x\" },\n\"y\": { \"datum\": 0, \"type\": \"quantitative\" },\n\"y2\": { \"field\": \"y\" },\n\"color\": {\n\"field\": \"theta\",\n\"type\": \"quantitative\",\n\"scale\": { \"scheme\": \"rainbow\" }\n},\n\"color2\": { \"value\": \"white\" }\n}\n}\n</code></pre>"},{"location":"grammar/mark/point/","title":"Point","text":"<p>Point mark displays each data item as a symbol. Points are often used to create a scatter plot. In the genomic context, they could represent, for example, point mutations at genomic loci.</p> <pre><code>{\n\"data\": { \"url\": \"sincos.csv\" },\n\"mark\": \"point\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"y\": { \"field\": \"sin\", \"type\": \"quantitative\" },\n\"size\": { \"field\": \"x\", \"type\": \"quantitative\" }\n}\n}\n</code></pre>"},{"location":"grammar/mark/point/#channels","title":"Channels","text":"<p>In addition to standard position channels and <code>color</code>, <code>opacity</code>, and <code>strokeWidth</code> channels, point mark has the following channels:</p> <code>size</code> <p>Type: Number</p> <p>The area of the point in pixels. In practice, the area is less because the shapes do not fill their rectangular container. Example: the diameter of a circle with the size of <code>100</code> is 10 (sqrt(100)) pixels.</p> <p>Default value: <code>100</code></p> <code>shape</code> <p>Type: String</p> <p>One of <code>\"circle\"</code>, <code>\"square\"</code>, <code>\"cross\"</code>, <code>\"diamond\"</code>, <code>\"triangle-up\"</code>, <code>\"triangle-down\"</code>, <code>\"triangle-right\"</code>, or <code>\"triangle-left\"</code>.</p> <p>Default value: <code>\"circle\"</code></p>"},{"location":"grammar/mark/point/#properties","title":"Properties","text":"<code>fillGradientStrength</code> <p>Type: Number</p> <p>Gradient strength controls the amount of the gradient eye-candy effect. Valid values are between <code>0</code> and <code>1</code>.</p> <p>Default value: <code>0</code></p> <code>geometricZoomBound</code> <p>Type: Number</p> <p>Enables geometric zooming. The value is the base two logarithmic zoom level where the maximum point size is reached.</p> <p>Default value: <code>0</code></p> <code>sampleFacetPadding</code> <p>Type: Number</p> <p>Padding between sample facet's upper/lower edge and the maximum point size. This property controls how tightly points are squeezed when facet's height is smaller than the maximum point size. The unit is a proportion of facet's height. The value must be between <code>0</code> and <code>0.5</code>. This property has no effect when sample faceting is not used.</p> <p>Default value: <code>0.1</code></p>"},{"location":"grammar/mark/point/#examples","title":"Examples","text":""},{"location":"grammar/mark/point/#plenty-of-points","title":"Plenty of points","text":"<p>The example below demonstrates how points can be varied by using <code>shape</code>, <code>fill</code>, <code>size</code>, <code>strokeWidth</code>, and <code>angle</code> channels.</p> <pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 160, \"as\": \"z\" }\n},\n\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"datum.z % 20\", \"as\": \"x\" },\n{ \"type\": \"formula\", \"expr\": \"floor(datum.z / 20)\", \"as\": \"y\" }\n],\n\n\"mark\": {\n\"type\": \"point\",\n\"stroke\": \"black\"\n},\n\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"ordinal\", \"axis\": null },\n\"y\": { \"field\": \"y\", \"type\": \"ordinal\", \"axis\": null },\n\"shape\": { \"field\": \"x\", \"type\": \"nominal\" },\n\"fill\": { \"field\": \"x\", \"type\": \"nominal\" },\n\"size\": {\n\"field\": \"x\",\n\"type\": \"quantitative\",\n\"scale\": { \"type\": \"pow\", \"exponent\": 2, \"range\": [0, 900] }\n},\n\"strokeWidth\": {\n\"field\": \"y\",\n\"type\": \"quantitative\",\n\"scale\": { \"range\": [0, 4] }\n},\n\"angle\": {\n\"field\": \"y\",\n\"type\": \"quantitative\",\n\"scale\": { \"range\": [0, 45] }\n}\n}\n}\n</code></pre>"},{"location":"grammar/mark/point/#zoom-behavior","title":"Zoom behavior","text":"<p>Although points are infinitely small on the real number line, they have a specific diameter on the screen. Thus, closely located points tend to overlap each other. Decreasing the point size reduces the probability of overlap, but in a zoomed-in view, the plot may become overly sparse.</p> <p>To control overplotting, the point mark provides two zooming behaviors that adjust the point size and visibility based on the zoom level.</p>"},{"location":"grammar/mark/point/#geometric-zoom","title":"Geometric zoom","text":"<p>Geometric zoom scales the point size down if the current zoom level is lower than the specified level (bound). <code>geometricZoomBound</code> mark property enables geometric zooming. The value is the negative base two logarithm of the relative width of the visible domain. Example: <code>0</code>: (the default) full-size points are always shown, <code>1</code>: when a half of the domain is visible, <code>2</code>: when a quarter is visible, and so on.</p> <p>The example below displays 200 000 semi-randomly generated points. The points reach their full size when 1 / 2^10.5 of the domain is visible, which equals about 1500X zoom.</p> <pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 200000, \"as\": \"x\" }\n},\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"random() * 0.682\", \"as\": \"u\" },\n{\n\"type\": \"formula\",\n\"expr\": \"((datum.u % 1e-8 &gt; 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618 + sin(datum.x / 10000)\",\n\"as\": \"y\"\n}\n],\n\"mark\": {\n\"type\": \"point\",\n\"geometricZoomBound\": 10.5\n},\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n\"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n\"size\": { \"value\": 200 },\n\"opacity\": { \"value\": 0.6 }\n}\n}\n</code></pre> <p>Tip</p> <p>You can use geometric zoom to improve rendering performance. Smaller points are faster to render than large points.</p>"},{"location":"grammar/mark/point/#semantic-zoom","title":"Semantic zoom","text":"<p>The score-based semantic zoom adjusts the point visibility by coupling a score threshold to current zoom level. The <code>semanticScore</code> channel enables the semantic zoom and specifies the score field. The <code>semanticZoomFraction</code> property controls the fraction of data items to show in the fully zoomed-out view, i.e., it specifies the threshold score. The fraction is scaled as the viewport is zoomed. Thus, if the data is distributed roughly uniformly along the zoomed axis, roughly constant number of points are visible at all zoom levels. The score can be arbitrarily distributed, as the threshold is computed using p-quantiles.</p> <p>The example below has 200 000 semi-randomly generated points with an exponentially distributed score. As the view is zoomed in, new points appear. Their number in the viewport stays approximately constant until the lowest possible score has been reached.</p> <pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 200000, \"as\": \"x\" }\n},\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"random() * 0.682\", \"as\": \"u\" },\n{\n\"type\": \"formula\",\n\"expr\": \"((datum.u % 1e-8 &gt; 5e-9 ? 1 : -1) * (sqrt(-log(max(1e-9, datum.u))) - 0.618)) * 1.618\",\n\"as\": \"y\"\n},\n{\n\"type\": \"formula\",\n\"expr\": \"-log(random())\",\n\"as\": \"score\"\n}\n],\n\"mark\": {\n\"type\": \"point\",\n\"semanticZoomFraction\": 0.002\n},\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n\"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n\"opacity\": {\n\"field\": \"score\",\n\"type\": \"quantitative\",\n\"scale\": { \"range\": [0.1, 1] }\n},\n\"semanticScore\": { \"field\": \"score\", \"type\": \"quantitative\" },\n\"size\": { \"value\": 100 }\n}\n}\n</code></pre> <p>Tip</p> <p>The score-based semantic zoom is great for filtering point mutations and indels that are scored using CADD, for example.</p>"},{"location":"grammar/mark/rect/","title":"Rect","text":"<p>Rect mark displays each data item as a rectangle.</p> <pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 20, \"as\": \"z\" }\n},\n\"transform\": [\n{ \"type\": \"formula\", \"as\": \"x\", \"expr\": \"random()\" },\n{ \"type\": \"formula\", \"as\": \"x2\", \"expr\": \"datum.x + random() * 0.3\" },\n{ \"type\": \"formula\", \"as\": \"y\", \"expr\": \"random()\" },\n{ \"type\": \"formula\", \"as\": \"y2\", \"expr\": \"datum.y + random() * 0.4\" }\n],\n\"mark\": {\n\"type\": \"rect\",\n\"strokeWidth\": 2,\n\"stroke\": \"#404040\",\n\"cornerRadius\": 5\n},\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"x2\": { \"field\": \"x2\" },\n\"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n\"y2\": { \"field\": \"y2\" },\n\"color\": { \"field\": \"z\", \"type\": \"quantitative\" }\n}\n}\n</code></pre>"},{"location":"grammar/mark/rect/#channels","title":"Channels","text":"<p>Rect mark supports the standard position channels and <code>color</code> and <code>opacity</code> channels.</p>"},{"location":"grammar/mark/rect/#properties","title":"Properties","text":"<code>minHeight</code> <p>Type: Number</p> <p>The minimum height of a rectangle in pixels. The property clamps rectangles' heights.</p> <p>Default value: <code>0</code></p> <code>minWidth</code> <p>Type: Number</p> <p>The minimum width of a rectangle in pixels. The property clamps rectangles' widths when the viewport is zoomed out.</p> <p>This property also reduces flickering of very narrow rectangles, thus, the value should generally be at least one.</p> <p>Default value: <code>1</code></p> <code>minOpacity</code> <p>Type: Number</p> <p>Clamps the minimum size-dependent opacity. The property does not affect the <code>opacity</code> channel. Valid values are between <code>0</code> and <code>1</code>.</p> <p>When a rectangle would be smaller than what is specified in <code>minHeight</code> and <code>minWidth</code>, it is faded out proportionally. Example: a rectangle would be rendered as one pixel wide, but <code>minWidth</code> clamps it to five pixels. The rectangle is actually rendered as five pixels wide, but its opacity is multiplied by 0.2. With this setting, you can limit the factor to, for example, 0.5 to keep the rectangles more clearly visible.</p> <p>Default value: <code>0</code></p> <code>xOffset</code> <p>Type: Number</p> <p>Offsets of the <code>x</code> and <code>x2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p> <code>yOffset</code> <p>Type: Number</p> <p>Offsets of the <code>y</code> and <code>y2</code> coordinates in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p>"},{"location":"grammar/mark/rect/#examples","title":"Examples","text":""},{"location":"grammar/mark/rect/#heatmap","title":"Heatmap","text":"<p>When used with <code>\"band\"</code> or <code>\"index\"</code> scales, the rectangles fill the whole bands when only the primary positional channel is defined.</p> <pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 800, \"as\": \"z\" }\n},\n\"transform\": [\n{ \"type\": \"formula\", \"as\": \"y\", \"expr\": \"floor(datum.z / 40)\" },\n{ \"type\": \"formula\", \"as\": \"x\", \"expr\": \"datum.z % 40\" },\n{\n\"type\": \"formula\",\n\"as\": \"z\",\n\"expr\": \"sin(datum.x / 8) + cos(datum.y / 10 - 0.5 + sin(datum.x / 20) * 2)\"\n}\n],\n\"mark\": \"rect\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"index\" },\n\"y\": { \"field\": \"y\", \"type\": \"index\" },\n\"color\": {\n\"field\": \"z\",\n\"type\": \"quantitative\",\n\"scale\": {\n\"scheme\": \"magma\"\n}\n}\n}\n}\n</code></pre>"},{"location":"grammar/mark/rect/#bars","title":"Bars","text":"<pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 60, \"as\": \"x\" }\n},\n\"transform\": [\n{\n\"type\": \"formula\",\n\"expr\": \"sin((datum.x - 30) / 4) + (datum.x - 30) / 30\",\n\"as\": \"y\"\n}\n],\n\"mark\": \"rect\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"index\", \"scale\": { \"padding\": 0.1 } },\n\"y\": { \"field\": \"y\", \"type\": \"quantitative\" },\n\"y2\": { \"datum\": 0 },\n\"color\": {\n\"field\": \"y\",\n\"type\": \"quantitative\",\n\"scale\": {\n\"type\": \"threshold\",\n\"domain\": [0],\n\"range\": [\"#ed553b\", \"#20639b\"]\n}\n}\n}\n}\n</code></pre>"},{"location":"grammar/mark/rule/","title":"Rule","text":"<p>Rule mark displays each data item as a line segment. Rules can span the whole width or height of the view. Alternatively, they may have specific endpoints.</p> <pre><code>{\n\"data\": {\n\"sequence\": { \"start\": 0, \"stop\": 15, \"as\": \"y\" }\n},\n\"mark\": {\n\"type\": \"rule\",\n\"strokeDash\": [6, 3]\n},\n\"encoding\": {\n\"x\": { \"field\": \"y\", \"type\": \"quantitative\" },\n\"color\": { \"field\": \"y\", \"type\": \"nominal\" }\n}\n}\n</code></pre>"},{"location":"grammar/mark/rule/#channels","title":"Channels","text":"<p>TODO, but in principle, the same as in the rect mark.</p>"},{"location":"grammar/mark/rule/#properties","title":"Properties","text":"<p>TODO, but in principle, the same as in the rect mark plus the following:</p> <code>size</code> <p>Type: Number</p> <p>The stroke width of the lines in pixels.</p> <p>Default value: <code>1</code></p> <code>minLength</code> <p>Type: Number</p> <p>The minimum length of the rule in pixels. Use this property to ensure that very short rules remain visible even when the user zooms out.</p> <p>Default value: <code>0</code></p> <code>strokeDash</code> <p>Type: Number[]</p> <p>An array of of alternating stroke and gap lengths or <code>null</code> for solid strokes.</p> <p>Default value: <code>null</code></p> <code>strokeDashOffset</code> <p>Type: Number</p> <p>An offset for the stroke pattern.</p> <p>Default value: <code>0</code></p> <code>strokeCap</code> <p>Type: String</p> <p>The style of stroke ends. Available choices: <code>\"butt\"</code>, <code>\"round</code>\", and <code>\"square\"</code>.</p> <p>Default value: <code>\"butt\"</code></p>"},{"location":"grammar/mark/rule/#examples","title":"Examples","text":""},{"location":"grammar/mark/rule/#ranged-rules","title":"Ranged rules","text":"<pre><code>{\n\"data\": {\n\"values\": [\n{ \"y\": \"A\", \"x\": 2, \"x2\": 7 },\n{ \"y\": \"B\", \"x\": 0, \"x2\": 3 },\n{ \"y\": \"B\", \"x\": 5, \"x2\": 6 },\n{ \"y\": \"C\", \"x\": 4, \"x2\": 8 },\n{ \"y\": \"D\", \"x\": 1, \"x2\": 5 }\n]\n},\n\"mark\": {\n\"type\": \"rule\",\n\"size\": 10,\n\"strokeCap\": \"round\"\n},\n\"encoding\": {\n\"y\": { \"field\": \"y\", \"type\": \"nominal\" },\n\"x\": { \"field\": \"x\", \"type\": \"quantitative\" },\n\"x2\": { \"field\": \"x2\" }\n}\n}\n</code></pre>"},{"location":"grammar/mark/text/","title":"Text","text":"<p>Text mark displays each data item as text.</p> <pre><code>{\n\"data\": {\n\"values\": [\n{ \"x\": 1, \"text\": \"Hello\" },\n{ \"x\": 2, \"text\": \"world!\" }\n]\n},\n\"mark\": \"text\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"ordinal\" },\n\"color\": { \"field\": \"x\", \"type\": \"nominal\" },\n\"text\": { \"field\": \"text\", \"type\": \"nominal\" },\n\"size\": { \"value\": 100 }\n}\n}\n</code></pre>"},{"location":"grammar/mark/text/#channels","title":"Channels","text":"<p>In addition to standard position channels and <code>color</code> and <code>opacity</code> channels, point mark has the following channels:</p> <code>text</code> <p>Type: String</p> <p>The text to display. The format of numeric data can be customized by setting a format specifier to channel definition's <code>format</code> property.</p> <p>Default value: <code>\"\"</code></p> <code>size</code> <p>Type: Number</p> <p>The font size in pixels.</p> <p>Default value: <code>11</code></p> <code>angle</code> <p>Type: Number</p> <p>The rotation angle in degrees.</p> <p>Default value: <code>0</code></p>"},{"location":"grammar/mark/text/#properties","title":"Properties","text":"<code>font</code> <p>Type: String</p> <p>The font typeface. GenomeSpy uses SDF versions of Google Fonts. Check their availability at the A-Frame Fonts repository. The system fonts are not supported.</p> <p>Default value: <code>\"Lato\"</code></p> <code>fontWeight</code> <p>Type: String | Number</p> <p>The font weight. The following strings and numbers are valid values: <code>\"thin\"</code> (<code>100</code>), <code>\"light\"</code> (<code>300</code>), <code>\"regular\"</code> (<code>400</code>), <code>\"normal\"</code> (<code>400</code>), <code>\"medium\"</code> (<code>500</code>), <code>\"bold\"</code> (<code>700</code>), <code>\"black\"</code> (<code>900</code>)</p> <p>Default value: <code>\"regular\"</code></p> <code>fontStyle</code> <p>Type: String</p> <p>The font style. Valid values: <code>\"normal\"</code> and <code>\"italic\"</code>.</p> <p>Default value: <code>\"normal\"</code></p> <code>align</code> <p>Type: String</p> <p>The horizontal alignment of the text. One of <code>\"left\"</code>, <code>\"center\"</code>, or <code>\"right\"</code>.</p> <p>Default value: <code>\"left\"</code></p> <code>baseline</code> <p>Type: String</p> <p>The vertical alignment of the text. One of <code>\"top\"</code>, <code>\"middle\"</code>, <code>\"bottom\"</code>.</p> <p>Default value: <code>\"bottom\"</code></p> <code>dX</code> <p>Type: Number</p> <p>Offset of the x coordinate in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p> <code>dY</code> <p>Type: Number</p> <p>Offset of the x coordinate in pixels. The offset is applied after the viewport scaling and translation.</p> <p>Default value: <code>0</code></p>"},{"location":"grammar/mark/text/#examples","title":"Examples","text":""},{"location":"grammar/mark/text/#ranged-text","title":"Ranged text","text":"<p>The <code>x2</code> and <code>y2</code> channels allow for positioning the text inside a segment. The text is either squeezed (default) or hidden if it does not fit in the segment. The <code>squeeze</code> property controls the behavior.</p> <p>The example below has two layers: gray rectangles at the bottom and ranged text on the top. Try to zoom and pan to see how they behave!</p> <pre><code>{\n\"data\": {\n\"values\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]\n},\n\"transform\": [\n{ \"type\": \"formula\", \"expr\": \"round(random() * 100)\", \"as\": \"a\" },\n{ \"type\": \"formula\", \"expr\": \"datum.a + round(random() * 60)\", \"as\": \"b\" }\n],\n\"encoding\": {\n\"x\": { \"field\": \"a\", \"type\": \"quantitative\", \"scale\": { \"zoom\": true } },\n\"x2\": { \"field\": \"b\" },\n\"y\": {\n\"field\": \"data\",\n\"type\": \"nominal\",\n\"scale\": {\n\"padding\": 0.3\n}\n}\n},\n\"layer\": [\n{\n\"mark\": \"rect\",\n\"encoding\": { \"color\": { \"value\": \"#eaeaea\" } }\n},\n{\n\"mark\": {\n\"type\": \"text\",\n\"align\": \"center\",\n\"baseline\": \"middle\",\n\"paddingX\": 5\n},\n\"encoding\": {\n\"text\": {\n\"expr\": \"'Hello ' + floor(datum.a)\",\n\"type\": \"ordinal\"\n},\n\"size\": { \"value\": 12 }\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/transform/","title":"Data transformation","text":"<p>With transforms, you can build a pipeline that modifies the data before the data objects are mapped to mark instances. In an abstract sense, a transformation inputs a list of data items and outputs a list of new items that may be filtered, modified, or generated from the original items.</p> <p>Departure from Vega-Lite</p> <p>The notation of transforms is different from Vega-Lite to enable more straghtforward addition of new operations. Each transform has to be specified using an explicit <code>type</code> property like in the lower-level Vega visualization grammar. Thus, the transform type is not inferred from the presence of transform-specific properties.</p>"},{"location":"grammar/transform/#example","title":"Example","text":"<p>The following example uses the <code>\"filter\"</code> transform to retain only the rows that match the predicate expression.</p> <pre><code>{\n...,\n\"data\": { ... },\n\"transform\": [\n{\n\"type\": \"filter\",\n\"expr\": \"datum.end - datum.start &lt; 5000\"\n}\n],\n...\n}\n</code></pre>"},{"location":"grammar/transform/aggregate/","title":"Aggregate","text":"<p>The <code>\"aggregate\"</code> transform is currently minimal \u2013 it adds a new <code>count</code> field that contains the number of data items in a group. More aggregate operations will be added later.</p>"},{"location":"grammar/transform/aggregate/#parameters","title":"Parameters","text":"<code>groupby</code> Which fields to use for grouping. Missing <code>groupby</code> results in a single group that includes all the data items."},{"location":"grammar/transform/aggregate/#example","title":"Example","text":"<p>Given the following data:</p> x y first 123 first 456 second 789 <p>... and configuration:</p> <pre><code>{\n\"type\": \"aggregate\",\n\"groupby\": [\"x\"]\n}\n</code></pre> <p>A new list of data objects is created:</p> x count first 2 second 1"},{"location":"grammar/transform/collect/","title":"Collect","text":"<p>The <code>\"collect\"</code> transform collects (buffers) the data items from the data flow into an internal array and optionally sorts them.</p>"},{"location":"grammar/transform/collect/#parameters","title":"Parameters","text":"<code>groupby</code> Arranges the data into consecutive batches based on the groups. This is mainly intended for internal use so that faceted data can be handled as batches. <code>sort</code> The sort order."},{"location":"grammar/transform/coverage/","title":"Coverage","text":"<p>The <code>\"coverage\"</code> transform computes coverage for overlapping segments. The result is a new list of non-overlapping segments with the coverage values. The segments must be sorted by their start coordinates before passing them to the coverage transform.</p>"},{"location":"grammar/transform/coverage/#parameters","title":"Parameters","text":"<code>as</code> The output field for the computed coverage. <code>asChrom</code> <p>The output field for the chromosome.</p> <p>Default: Same as <code>chrom</code></p> <code>asEnd</code> <p>The output field for the end coordinate.</p> <p>Default: Same as <code>end</code></p> <code>asStart</code> <p>The output field for the start coordinate.</p> <p>Default: Same as <code>start</code></p> <code>chrom</code> An optional chromosome field that is passed through. TODO: groupby <code>end</code> Required The field representing the end coordinate of the segment (exclusive). <code>start</code> Required The field representing the start coordinate of the segment (inclusive). <code>weight</code> A field representing an optional weight for the segment. Can be used with copy ratios, for example."},{"location":"grammar/transform/coverage/#example","title":"Example","text":"<p>Given the following data:</p> start end 0 4 1 3 <p>... and configuration:</p> <pre><code>{\n\"type\": \"coverage\",\n\"start\": \"startpos\",\n\"end\": \"endpos\"\n}\n</code></pre> <p>A new list of segments is produced:</p> start end coverage 0 1 1 1 3 2 3 4 1"},{"location":"grammar/transform/coverage/#interactive-example","title":"Interactive example","text":"<p>The following example demonstrates both <code>\"coverage\"</code> and <code>\"pileup\"</code> transforms.</p> <pre><code>{\n\"data\": {\n\"sequence\": {\n\"start\": 1,\n\"stop\": 100,\n\"as\": \"start\"\n}\n},\n\"transform\": [\n{\n\"type\": \"formula\",\n\"expr\": \"datum.start + ceil(random() * 20)\",\n\"as\": \"end\"\n}\n],\n\"resolve\": { \"scale\": { \"x\": \"shared\" } },\n\"vconcat\": [\n{\n\"transform\": [\n{\n\"type\": \"coverage\",\n\"start\": \"start\",\n\"end\": \"end\",\n\"as\": \"coverage\"\n}\n],\n\"mark\": \"rect\",\n\"encoding\": {\n\"x\": { \"field\": \"start\", \"type\": \"index\" },\n\"x2\": { \"field\": \"end\" },\n\"y\": { \"field\": \"coverage\", \"type\": \"quantitative\" }\n}\n},\n{\n\"transform\": [\n{\n\"type\": \"pileup\",\n\"start\": \"start\",\n\"end\": \"end\",\n\"as\": \"lane\"\n}\n],\n\"mark\": \"rect\",\n\"encoding\": {\n\"x\": { \"field\": \"start\", \"type\": \"index\" },\n\"x2\": { \"field\": \"end\" },\n\"y\": {\n\"field\": \"lane\",\n\"type\": \"index\",\n\"scale\": {\n\"padding\": 0.2,\n\"reverse\": true,\n\"zoom\": false\n}\n}\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/transform/filter-scored-labels/","title":"Filter Scored Lables","text":"<p>The <code>\"filterScoredLables\"</code> transform fits prioritized labels into the available space, and dynamically reflows the data when the scale domain is adjusted (i.e., zoomed).</p> <p>TODO: Proper documentation.</p>"},{"location":"grammar/transform/filter-scored-labels/#parameters","title":"Parameters","text":"<code>channel</code> Default: <code>\"x\"</code> <code>lane</code> An optional field representing element's lane, e.g., if transcripts are shown using a piled up layout. <code>padding</code> <p>Padding (in pixels) around the element.</p> <p>Default: <code>0</code></p> <code>pos</code> Required The field representing element's position on the domain. <code>score</code> Required The field representing the score used for prioritization. <code>width</code> Required The field representing element's width in pixels"},{"location":"grammar/transform/filter-scored-labels/#example","title":"Example","text":"<p>TODO</p>"},{"location":"grammar/transform/filter/","title":"Filter","text":"<p>The <code>\"filter\"</code> transform removes data objects based on a predicate expression.</p>"},{"location":"grammar/transform/filter/#parameters","title":"Parameters","text":"<code>expr</code> Required An expression string. The data object is removed if the expression evaluates to false."},{"location":"grammar/transform/filter/#example","title":"Example","text":"<pre><code>{\n\"type\": \"filter\",\n\"expr\": \"datum.p &lt;= 0.05\"\n}\n</code></pre> <p>The example above retains all rows for which the field <code>p</code> is less than or equal to 0.05.</p>"},{"location":"grammar/transform/flatten-compressed-exons/","title":"Flatten Compressed Exons","text":"<p>The <code>\"flattenCompressedExons\"</code> transform flattens \"delta encoded\" exons. The transform inputs the start coordinate of the gene body and a comma-delimited string of alternating intron and exon lengths. A new data object is created for each exon.</p> <p>This transform is mainly intended to be used with an optimized gene annotation track. Read more at an observable notebook.</p>"},{"location":"grammar/transform/flatten-compressed-exons/#parameters","title":"Parameters","text":"<code>as</code> <p>Field names for the flattened exons.</p> <p>Default: <code>[\"exonStart\", \"exonEnd\"]</code></p> <code>exons</code> <p>The field containing the exons.</p> <p>Default: <code>\"exons\"</code></p> <code>start</code> <p>Start coordinate of the gene body.</p> <p>Default: <code>\"start\"</code></p>"},{"location":"grammar/transform/flatten-compressed-exons/#example","title":"Example","text":"<p>TODO</p>"},{"location":"grammar/transform/flatten-delimited/","title":"Flatten Delimited","text":"<p>The <code>\"flattenDelimited\"</code> transform flattens (or normalizes) a field or a set of fields that contain delimited values. In other words, each delimited value is written into a new data object that contains a single value from the delimited field. All other fields are copied as such.</p>"},{"location":"grammar/transform/flatten-delimited/#parameters","title":"Parameters","text":"<code>as</code> <p>The output field name(s) for the flattened field.</p> <p>Default: the input fields.</p> <code>field</code> Required The field(s) to split and flatten <code>separator</code> Required Separator(s) used on the field(s) TODO: Rename to delimiter"},{"location":"grammar/transform/flatten-delimited/#example","title":"Example","text":"<p>Given the following data:</p> patient tissue value A Ova,Asc 4,2 B Adn,Asc,Ute 6,3,4 <p>... and configuration:</p> <pre><code>{\n\"type\": \"flattenDelimited\",\n\"field\": [\"tissue\", \"value\"],\n\"separator\": [\",\", \",\"]\n}\n</code></pre> <p>TODO: Rename separator to delimiter</p> <p>Flattened data is produced:</p> patient tissue value A Ova 4 A Asc 2 B Adn 6 B Asc 3 B Ute 4"},{"location":"grammar/transform/flatten-sequence/","title":"Flatten Sequence","text":"<p>The <code>\"flattenSequence\"</code> transform flattens strings such as FASTA sequences into data objecsts with position and character fields.</p>"},{"location":"grammar/transform/flatten-sequence/#parameters","title":"Parameters","text":"<code>as</code> <p>Name of the fields where the zero-based index number and flattened sequence letter are written to.</p> <p>Default: <code>[\"pos\", \"sequence\"]</code></p> <code>field</code> <p>The field to flatten.</p> <p>Default: <code>\"sequence\"</code></p>"},{"location":"grammar/transform/flatten-sequence/#example","title":"Example","text":"<p>Given the following data:</p> identifier sequence X AC Y ACTG <p>... and parameters:</p> <pre><code>{\n\"type\": \"flattenSequence\",\n\"field\": \"sequence\",\n\"as\": [\"base\", \"pos\"]\n}\n</code></pre> <p>The sequences are flattened into:</p> identifier sequence base pos X AC A 0 X AC C 1 Y ACTG A 0 Y ACTG C 1 Y ACTG T 2 Y ACTG G 3"},{"location":"grammar/transform/formula/","title":"Formula","text":"<p>The <code>\"formula\"</code> transform uses an expression to calculate and add a new field to the data objects.</p>"},{"location":"grammar/transform/formula/#parameters","title":"Parameters","text":"<code>as</code> Required The (new) field where the computed value is written to <code>expr</code> Required An expression string"},{"location":"grammar/transform/formula/#example","title":"Example","text":"<p>Given the following data:</p> x y 1 2 3 4 <p>... and configuration:</p> <pre><code>{\n\"type\": \"formula\",\n\"expr\": \"datum.x + datum.y\",\n\"as\": \"z\"\n}\n</code></pre> <p>A new field is added:</p> x y z 1 2 3 3 4 7"},{"location":"grammar/transform/linearize-genomic-coordinate/","title":"Linearize Genomic Coordinate","text":"<p>The <code>linearizeGenomicCoordinate</code> transform maps the (chromosome, position) pairs into a linear coordinate space using the chromosome sizes of the current genome assembly.</p>"},{"location":"grammar/transform/linearize-genomic-coordinate/#parameters","title":"Parameters","text":"<code>as</code> Required The output field or fields for linearized coordinates. <code>channel</code> <p>Get the genome assembly from the scale of the channel.</p> <p>Default: <code>\"x\"</code></p> <code>chrom</code> Required The chromosome/contig field <code>offset</code> <p>An offset or offsets that allow for adjusting the numbering base. The offset is subtracted from the positions.</p> <p>GenomeSpy uses internally zero-based indexing with half-open intervals. UCSC-based formats (BED, etc.) generally use this scheme. However, for example, VCF files use one-based indexing and must be adjusted by setting the offset to <code>1</code>.</p> <p>Default: <code>0</code></p> <code>pos</code> Required The field or fields that contain intra-chromosomal positions"},{"location":"grammar/transform/linearize-genomic-coordinate/#example","title":"Example","text":"<pre><code>{\n\"type\": \"linearizeGenomicCoordinate\",\n\"chrom\": \"chrom\",\n\"pos\": \"start\",\n\"as\": \"_start\"\n}\n</code></pre>"},{"location":"grammar/transform/measure-text/","title":"Measure Text","text":"<p>The <code>\"measureText\"</code> transforms measures the length of a string in pixels. The measurement can be used in downstream layout computations.</p>"},{"location":"grammar/transform/measure-text/#parameters","title":"Parameters","text":"<code>as</code> Required TODO <code>field</code> Required TODO <code>fontSize</code> Required TODO"},{"location":"grammar/transform/measure-text/#example","title":"Example","text":"<pre><code>{\n\"type\": \"measureText\",\n\"fontSize\": 11,\n\"field\": \"symbol\",\n\"as\": \"_textWidth\"\n}\n</code></pre>"},{"location":"grammar/transform/pileup/","title":"Pileup","text":"<p>The <code>\"pileup\"</code> transform computes a piled up layout for overlapping segments. The computed lane can be used to position the segments in a visualization. The segments must be sorted by their start coordinates before passing them to the pileup transform.</p>"},{"location":"grammar/transform/pileup/#parameters","title":"Parameters","text":"<code>as</code> <p>The output field name for the computed lane.</p> <p>Default: <code>\"lane\"</code>.</p> <code>end</code> Required The field representing the end coordinate of the segment (exclusive). <code>preference</code> An optional field indicating the preferred lane. Use together with the <code>preferredOrder</code> property. <code>preferredOrder</code> The order of the lane preferences. The first element contains the value that should place the segment on the first lane and so forth. If the preferred lane is occupied, the first available lane is taken. <code>spacing</code> <p>The spacing between adjacent segments on the same lane in coordinate units.</p> <p>Default: <code>1</code>.</p> <code>start</code> Required The field representing the start coordinate of the segment (inclusive)."},{"location":"grammar/transform/pileup/#example","title":"Example","text":"<p>Given the following data:</p> start end 0 4 1 3 2 6 4 8 <p>... and configuration:</p> <pre><code>{\n\"type\": \"pileup\",\n\"start\": \"start\",\n\"end\": \"end\",\n\"as\": \"lane\"\n}\n</code></pre> <p>A new field is added:</p> start end lane 0 4 0 1 3 1 2 6 2 4 8 1"},{"location":"grammar/transform/pileup/#interactive-example","title":"Interactive example","text":"<p>The following example demonstrates both <code>\"coverage\"</code> and <code>\"pileup\"</code> transforms.</p> <pre><code>{\n\"data\": {\n\"sequence\": {\n\"start\": 1,\n\"stop\": 100,\n\"as\": \"start\"\n}\n},\n\"transform\": [\n{\n\"type\": \"formula\",\n\"expr\": \"datum.start + ceil(random() * 20)\",\n\"as\": \"end\"\n}\n],\n\"resolve\": { \"scale\": { \"x\": \"shared\" } },\n\"vconcat\": [\n{\n\"transform\": [\n{\n\"type\": \"coverage\",\n\"start\": \"start\",\n\"end\": \"end\",\n\"as\": \"coverage\"\n}\n],\n\"mark\": \"rect\",\n\"encoding\": {\n\"x\": { \"field\": \"start\", \"type\": \"index\" },\n\"x2\": { \"field\": \"end\" },\n\"y\": { \"field\": \"coverage\", \"type\": \"quantitative\" }\n}\n},\n{\n\"transform\": [\n{\n\"type\": \"pileup\",\n\"start\": \"start\",\n\"end\": \"end\",\n\"as\": \"lane\"\n}\n],\n\"mark\": \"rect\",\n\"encoding\": {\n\"x\": { \"field\": \"start\", \"type\": \"index\" },\n\"x2\": { \"field\": \"end\" },\n\"y\": {\n\"field\": \"lane\",\n\"type\": \"index\",\n\"scale\": {\n\"padding\": 0.2,\n\"reverse\": true,\n\"zoom\": false\n}\n}\n}\n}\n]\n}\n</code></pre>"},{"location":"grammar/transform/project/","title":"Project","text":"<p>The <code>\"project\"</code> transform retains the specified fields of the data objects, optionally renaming them. All other fields are removed.</p>"},{"location":"grammar/transform/project/#parameters","title":"Parameters","text":"<code>as</code> New names for the projected fields. If omitted, the names of the source fields are used. <code>fields</code> Required The fields to be projected."},{"location":"grammar/transform/project/#example","title":"Example","text":""},{"location":"grammar/transform/regex-extract/","title":"Regex Extract","text":"<p>The <code>\"regexExtract\"</code> transform extracts groups from a string field and adds them to the data objects as new fields.</p>"},{"location":"grammar/transform/regex-extract/#parameters","title":"Parameters","text":"<code>as</code> Required The new field or an array of fields where the extracted values are written. <code>field</code> Required The source field <code>regex</code> Required <p>A valid JavaScript regular expression with at least one group. For example: <code>\"^Sample(\\\\d+)$\"</code>.</p> <p>Read more at: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions</p> <code>skipInvalidInput</code> <p>Do not complain about invalid input. Just skip it and leave the new fields undefined on the affected datum.</p> <p>Default: <code>false</code></p>"},{"location":"grammar/transform/regex-extract/#example","title":"Example","text":"<p>Given the following data:</p> Gene Genome Location AKT1 14:104770341-104792643 <p>... and configuration:</p> <pre><code>{\n\"type\": \"regexExtract\",\n\"field\": \"Genome Location\",\n\"regex\": \"^(X|Y|\\\\d+):(\\\\d+)-(\\\\d+)$\",\n\"as\": [\"Chrom\", \"Start\", \"End\"]\n}\n</code></pre> <p>Three new fields are added to the data:</p> Gene Genome Location Chrom Start End AKT1 14:104770341-104792643 14 104770341 104792643"},{"location":"grammar/transform/regex-fold/","title":"Regex Fold","text":"<p>The <code>\"regexFold\"</code> transform gathers columns into key-value pairs using a regular expression.</p>"},{"location":"grammar/transform/regex-fold/#parameters","title":"Parameters","text":"<code>asKey</code> Default: <code>\"sample\"</code> <code>asValue</code> Required A new column name for the extracted values. <code>columnRegex</code> Required A regular expression that matches to column names. The regex must have one capturing group that is used for extracting the key (e.g., a sample id) from the column name. <code>skipRegex</code> An optional regex that matches to fields that should not be included in the new folded data objects."},{"location":"grammar/transform/regex-fold/#example","title":"Example","text":"<p>Given the following data:</p> SNP foo.AF bar.AF baz.AF rs99924582 0.3 0.24 0.94 rs22238423 0.92 0.21 0.42 <p>... and configuration:</p> <pre><code>{\n\"type\": \"regexFold\",\n\"columnRegex\": [\"^(.*)\\\\.AF$\"],\n\"asValue\": [\"VAF\"],\n\"asKey\": \"sample\"\n}\n</code></pre> <p>The matched columns are folded into new data objects. All others are left intact:</p> SNP sample VAF rs99924582 foo 0.3 rs99924582 bar 0.24 rs99924582 baz 0.94 rs22238423 foo 0.92 rs22238423 bar 0.21 rs22238423 baz 0.42"},{"location":"grammar/transform/sample/","title":"Sample","text":"<p>The <code>\"sample\"</code> transform takes a random sample of the data objects.</p>"},{"location":"grammar/transform/sample/#parameters","title":"Parameters","text":"<code>size</code> <p>The maximum sample size.</p> <p>Default: <code>500</code></p>"},{"location":"grammar/transform/sample/#example","title":"Example","text":"<pre><code>{\n...\n\"transform\": [\n{ \"type\": \"sample\", \"size\": 100 }\n],\n...\n}\n</code></pre>"},{"location":"grammar/transform/stack/","title":"Stack","text":"<p>The <code>\"stack\"</code> transform computes a stacked layout. Stacked bar plots and sequence logos are some of its applications.</p>"},{"location":"grammar/transform/stack/#parameters","title":"Parameters","text":"<code>as</code> Required <p>Fields to write the stacked values.</p> <p>Default: <code>[\"y0\", \"y1\"]</code></p> <code>baseField</code> The field that contains the base or amino acid. Used for information content calculation when the offset is <code>\"information\"</code>. The data items that have <code>null</code> in the baseField are considered gaps and they are taken into account when scaling the the locus' information content. <code>cardinality</code> <p>Cardinality, e.g., the number if distinct bases or amino acids. Used for information content calculation when the offset is <code>\"information\"</code>.</p> <p>Default: <code>4</code>;</p> <code>field</code> The field to stack. If no field is defined, a constant value of one is assumed. <code>groupby</code> Required The fields to be used for forming groups for different stacks. <code>offset</code> How to offset the values in a stack. <code>\"zero\"</code> (default) starts stacking at 0. <code>\"center\"</code> centers the values around zero. <code>\"normalize\"</code> computes intra-stack percentages and normalizes the values to the range of <code>[0, 1]</code>. <code>\"information\"</code> computes a layout for a sequence logo. The total height of the stack reflects the group's information content. <code>sort</code> The sort order of data in each stack."},{"location":"grammar/transform/stack/#examples","title":"Examples","text":""},{"location":"grammar/transform/stack/#stacked-bar-plot","title":"Stacked bar plot","text":"<pre><code>{\n\"data\": {\n\"values\": [\n{ \"x\": 1, \"q\": \"A\", \"z\": 7 },\n{ \"x\": 1, \"q\": \"B\", \"z\": 3 },\n{ \"x\": 1, \"q\": \"C\", \"z\": 10 },\n{ \"x\": 2, \"q\": \"A\", \"z\": 8 },\n{ \"x\": 2, \"q\": \"B\", \"z\": 5 },\n{ \"x\": 3, \"q\": \"B\", \"z\": 10 }\n]\n},\n\"transform\": [\n{\n\"type\": \"stack\",\n\"field\": \"z\",\n\"groupby\": [\"x\"]\n}\n],\n\"mark\": \"rect\",\n\"encoding\": {\n\"x\": { \"field\": \"x\", \"type\": \"nominal\", \"band\": 0.8 },\n\"y\": { \"field\": \"y0\", \"type\": \"quantitative\" },\n\"y2\": { \"field\": \"y1\" },\n\"color\": { \"field\": \"q\", \"type\": \"nominal\" }\n}\n}\n</code></pre>"},{"location":"grammar/transform/stack/#sequence-logo","title":"Sequence logo","text":"<pre><code>{\n\"data\": {\n\"values\": [\n{ \"pos\": 1, \"base\": \"A\", \"count\": 2 },\n{ \"pos\": 1, \"base\": \"C\", \"count\": 3 },\n{ \"pos\": 1, \"base\": \"T\", \"count\": 5 },\n{ \"pos\": 2, \"base\": \"A\", \"count\": 7 },\n{ \"pos\": 2, \"base\": \"C\", \"count\": 3 },\n{ \"pos\": 3, \"base\": \"A\", \"count\": 10 },\n{ \"pos\": 4, \"base\": \"T\", \"count\": 9 },\n{ \"pos\": 4, \"base\": \"G\", \"count\": 1 },\n{ \"pos\": 5, \"base\": \"G\", \"count\": 8 },\n{ \"pos\": 6, \"base\": \"G\", \"count\": 7 }\n]\n},\n\"transform\": [\n{\n\"type\": \"stack\",\n\"field\": \"count\",\n\"groupby\": [\"pos\"],\n\"offset\": \"information\",\n\"as\": [\"_y0\", \"_y1\"],\n\"baseField\": \"base\",\n\"sort\": { \"field\": \"count\", \"order\": \"ascending\" }\n}\n],\n\"encoding\": {\n\"x\": { \"field\": \"pos\", \"type\": \"index\" },\n\"y\": {\n\"field\": \"_y0\",\n\"type\": \"quantitative\",\n\"scale\": { \"domain\": [0, 2] },\n\"title\": \"Information\"\n},\n\"y2\": { \"field\": \"_y1\" },\n\"text\": { \"field\": \"base\", \"type\": \"nominal\" },\n\"color\": {\n\"field\": \"base\",\n\"type\": \"nominal\",\n\"scale\": {\n\"type\": \"ordinal\",\n\"domain\": [\"A\", \"C\", \"T\", \"G\"],\n\"range\": [\"#7BD56C\", \"#FF9B9B\", \"#86BBF1\", \"#FFC56C\"]\n}\n}\n},\n\"mark\": {\n\"type\": \"text\",\n\"font\": \"Source Sans Pro\",\n\"fontWeight\": 700,\n\"size\": 100,\n\"squeeze\": true,\n\"fitToBand\": true,\n\n\"paddingX\": 0,\n\"paddingY\": 0,\n\n\"logoLetters\": true\n}\n}\n</code></pre>"},{"location":"sample-collections/","title":"Working with Sample Collections","text":"<p>The app package of the GenomeSpy toolkit enables an interactive analysis of large sample collections. It builds upon the core package, which allows developers to build tailored visualizations using the visualization grammar and GPU-accelerated rendering engine. The app extends the grammar with a facet operator that makes it possible to repeat a single visualization for thousands of samples. The end users of the visualization have access to several interactions that facilitate the exploration of such sample collections.</p> <p></p> <p>The documentation of the app package is split into two parts serving different audiences:</p> <ol> <li>Visualizing Sample Collections (for method developers)</li> <li>Analyzing Sample Collections (for end users)</li> </ol>"},{"location":"sample-collections/analyzing/","title":"Analyzing Sample Collections","text":"<p>End-User Documentation</p> <p>This page is mainly intended for end users who analyze sample collections interactively using the GenomeSpy app.</p>"},{"location":"sample-collections/analyzing/#elements-of-the-user-interface","title":"Elements of the user interface","text":"<p>Because GenomeSpy visualizations are highly customizable, the actual visualization and the available user-interface elements may differ significantly from what is shown below.</p> <p></p> <ol> <li>Location / search field shows the genomic coordinates of the current viewport    in a UCSC-style format. You can look up features such as gene symbols using the    field. In addition, you can filter the sample collection by categorical    metadata attibutes by typing a categorical value into this field.</li> <li>Undo history and provenance allows you to undo and redo actions performed on the    sample collection. The provenance () button shows    all perfomed actions, allowing you to better understand how the current    visualization state was constructed.</li> <li>View visibility menu allows for toggling the visibility of elements such as    metadata attributes or annotation tracks.</li> <li>Bookmark menu shows a list of pre-defined bookmarks and allows you to save    the visualization state as a local bookmark into your web browser. The adjacent    Share () button constructs a shareable URL, which    captures the visualization state and optional notes related to the current    visualization state.</li> <li>Fullscreen toggle opens the visualization in fullscreen mode.</li> <li>Group markers become visible when the sample collection has been stratified    using some attribute.</li> <li>Sample names identify the samples.</li> <li>Metadata such as clinical attributes or computed variables shown as a heatmap.</li> <li>Genomic data is shown here.</li> </ol>"},{"location":"sample-collections/analyzing/#navigation-interactions","title":"Navigation interactions","text":""},{"location":"sample-collections/analyzing/#navigating-around-the-genome","title":"Navigating around the genome","text":"<p>To navigate around the genome in GenomeSpy, you can use either a mouse or a touchpad. If you're using a mouse, you can zoom the genome axis in and out using the scroll wheel. To pan the view, click with the left mouse button and start dragging.</p> <p>If you're using a touchpad, you can zoom the genome axis by performing a vertical two-finger gesture. Similarly, you can pan the view by performing a horizontal gesture.</p>"},{"location":"sample-collections/analyzing/#peeking-samples","title":"Peeking samples","text":"<p>The GenomeSpy app is designed for the exploration of large datasets containing hundreds or thousands of samples. To provide a better overview of patterns across the entire sample collection, GenomeSpy displays the samples as a bird's eye view that fits them into the available vertical space. If you discover interesting patterns or outliers in the dataset, you can peek individual samples by activating a close-up view from the context menu or by pressing the E key on the keyboard.</p> <p>Once the close-up view is activated, the zooming interaction will change to vertical scrolling. However, you can still zoom in and out by holding down the Ctrl key while operating the mouse wheel or touchpad.</p>"},{"location":"sample-collections/analyzing/#manipulating-the-sample-collection","title":"Manipulating the sample collection","text":"<p>Sorting, filtering, and stratifying a large sample collection can provide valuable insights into the data by helping to identify patterns and outliers. By sorting samples based on a particular attribute or filtering out irrelevant samples, you can more easily identify patterns or trends in the data that might be difficult to see otherwise. Stratifying the sample collection by grouping samples into distinct categories can also help to identify meaningful differences between groups and reveal new insights into the data.</p> <p>The GenomeSpy app enables users to manipulate the sample collection using incremental actions that operate on abstract attributes, such as metadata variables or measured values at specific genomic loci. By applying a series of these stepwise actions, users can gradually shape the sample collection to their needs, enabling complex analyses. The applied actions are saved in an undo history, which also serves as provenance information for bookmarks and shared links.</p> <p>An example scenario</p> <p>Suppose a user has a sample collection that includes multiple tumor samples from each patient and wants to keep a single representative sample from each patient. The user defines a representative sample as having a tumor purity greater or equal to 15% and the highest copy number at the MYC locus. To form a sample collection with only the representative samples, the user performs the following actions:</p> <ol> <li>Retains samples with purity greater than or equal to 15%</li> <li>Sorts the samples in descending order by the copy number at the MYC locus</li> <li>Retains only the top sample from each patient, based on the sorting in Step 2</li> </ol> <p>Following these steps, the user is left with the representative samples.</p>"},{"location":"sample-collections/analyzing/#accessing-the-actions","title":"Accessing the actions","text":"<p>You can access the actions via a context menu, which appears when you right-click on a metadata attribute in the heatmap or a location in the genomic data panel.</p> <p>There are two types of attributes: quantitative and categorical. Each type has a different set of supported actions. For example, quantitative attributes can be filtered using a threshold, while categorical attributes support retention or removal of selected categories.</p> <p>The context menu also provides shortcuts to some actions based on the value under the cursor. For example, a context menu opened on a categorical attribute will give you actions for retaining or removing samples with the selected categorical value.</p>"},{"location":"sample-collections/analyzing/#undo-history-and-provenance","title":"Undo history and provenance","text":"<p>GenomeSpy stores the applied actions in an undo history, allowing you to easily experiment with different analyses and revert back to previous states if needed. The provenance button () reveals a menu that shows the applied actions together with the used attributes and parameters. You can jump to different states in the undo history by clicking the menu items or the adjacent previous/next buttons.</p>"},{"location":"sample-collections/analyzing/#the-actions","title":"The actions","text":""},{"location":"sample-collections/analyzing/#sort","title":"Sort","text":"<p>The Sort by action arranges the samples in a descending order based on the chosen quantitative attribute.</p>"},{"location":"sample-collections/analyzing/#filter-by-a-categorical-attribute","title":"Filter by a categorical attribute","text":"<p>The context menu provides two shortcut actions for retaining and removing samples having the chosen value in the selected attribute. The Advanced filter... option allows you to choose multiple categories to be retained or removed.</p>"},{"location":"sample-collections/analyzing/#filter-by-a-quantitative-attribute","title":"Filter by a quantitative attribute","text":"<p>For quantitative attributes, the menu offers shortcut actions for retaining samples with a value greater or equal to or less or equal to the chosen value. For more precise thresholding, you can use the Advanced filter... option, which opens a dialog with a histogram and options for choosing open or closed thresholds.</p>"},{"location":"sample-collections/analyzing/#retain-the-first-of-each","title":"Retain the first of each","text":"<p>In many analyses, it is necessary to select a single, representative sample from each category. This action retains the first, topmost sample from each category. It is not necessary to sort the samples by the categorical attribute, but rather they should be sorted according to the attributes used to select the representative samples. For a usage example, refer to the example scenario provided in the box above.</p>"},{"location":"sample-collections/analyzing/#retain-first-n-categories","title":"Retain first n categories","text":"<p>Sometimes you might be interested in a small number of categories that contain samples with the most extreme values in another attribute. For example, if each patient (the category) has multiple samples, this action allows you to retain all samples from the top-5 patients based on the highest number of mutations (the another attribute) in any of their samples.</p>"},{"location":"sample-collections/analyzing/#group-by-categorical-attribute","title":"Group by categorical attribute","text":"<p>This action stratifies the data based on the selected categorical attribute. The groups will be shown to the left of the sample names, as shown above.</p>"},{"location":"sample-collections/analyzing/#group-by-quartiles","title":"Group by quartiles","text":"<p>This action enables rapid stratification into four groups using a quantitative attribute. The implementation uses the R-7 method, the default in the R programming language and Excel.</p>"},{"location":"sample-collections/analyzing/#group-by-thresholds","title":"Group by thresholds","text":"<p>The group by thresholds action allows stratifying the samples using custom thresholds on a quantitative attribute. Upon selecting this action, you are shown a dialog with a histogram, where you can add any number of thresholds and specify which side of the threshold should be open or closed.</p>"},{"location":"sample-collections/analyzing/#retain-matched","title":"Retain matched","text":"<p>This action retains categories that are common to all of the current groups. For example, suppose you are working with a sample collection with multiple samples from each patient. You have grouped the samples into two groups based on the anatomical site of the sample. By applying this action to the categorical patient attribute, you can ensure that your sample collection comprises only those patients with samples from both anatomical sites. In other words, the patients with only a single anatomical site are removed.</p>"},{"location":"sample-collections/analyzing/#bookmarking-and-sharing","title":"Bookmarking and sharing","text":"<p>Saving a visualization state together with provenance as a bookmark is a practical way to revisit a particular visualization later or share it with others. Bookmarks store the entire state of the visualization, including the actions taken to arrive at that state. This allows for easy and reproducible sharing of findings from the data. Moreover, bookmarks support optional Markdown-formatted notes that allow communicating essential background information and possible implications related to the discovery.</p>"},{"location":"sample-collections/analyzing/#bookmarks","title":"Bookmarks","text":"<p>GenomeSpy supports two types of bookmarks: pre-defined bookmarks that the visualization author may have included with the visualization and local bookmarks that you can save in your web browser. You can access both types of bookmarks from the bookmark menu (). Additionally, you can remove or edit existing bookmarks through a submenu that appears when you click the ellipsis button ().</p>"},{"location":"sample-collections/analyzing/#sharing","title":"Sharing","text":"<p>The current visualization state is constantly updated to the web browser's address bar, allowing you to quickly share the state with others. However, for better context, GenomeSpy's sharing function provides the option to include a name and notes with the shared state. Additionally, recipients can conveniently import the shared link into their local GenomeSpy bookmarks. You can share the current state by clicking on the Share () button, or share an existing bookmark by selecting the Share option from the bookmark's submenu.</p>"},{"location":"sample-collections/visualizing/","title":"Visualizing Sample Collections","text":"<p>Developer Documentation</p> <p>This page is intended for users who develop tailored visualizations using the GenomeSpy app.</p>"},{"location":"sample-collections/visualizing/#getting-started","title":"Getting started","text":"<p>The app has its own NPM package. To get started, follow the generic Getting Started documentation, but replace the <code>@genome-spy/core</code> package with the <code>@genome-spy/app</code> package, and use <code>genomeSpyApp.embed(...)</code> instead of <code>genomeSpyEmbed.embed(...)</code>.</p> <p>For a complete example, check the website-examples repository on GitHub.</p>"},{"location":"sample-collections/visualizing/#specifying-a-sample-view","title":"Specifying a Sample View","text":"<p>The GenomeSpy app extends the core library with a new view composition operator that allows visualization of multiple samples. In this context, a sample means a set of data objects representing an organism, a piece of tissue, a cell line, a single cell, etc. Each sample gets its own track in the visualization, and the behavior resembles the facet operator of Vega-Lite. However, there are subtle differences in the behavior.</p> <p>A sample view is defined by the <code>samples</code> and <code>spec</code> properties. To assign a track for a data object, define a sample-identifier field using the <code>sample</code> channel. More complex visualizations can be created using the <code>layer</code> operator. Each composed view may have a different data source, enabling concurrent visualization of multiple data types. For instance, the bottom layer could display segmented copy-number data, while the top layer might show single-nucleotide variants.</p> <pre><code>{\n\"samples\": {\n// Optional sample identifiers and metadata\n...\n},\n\"spec\": {\n// A single or layer specification\n...,\n\"encoding\": {\n...,\n// The sample channel identifies the track\n\"sample\": {\n\"field\": \"sampleId\",\n\"type\": \"nominal\"\n}\n}\n}\n}\n</code></pre> <p>Y axis ticks</p> <p>The Y axis ticks are not available in sample views at the moment. Will be fixed at a later time. However, they would not be particularly practical with high number of samples.</p> <p>But we have Band scale?</p> <p>Superficially similar results can be achieved by using the \"band\" scale on the <code>y</code> channel. However, you can not adjust the intra-band y-position, as the <code>y</code> channel is already reserved for assigning a band for a datum. On the other hand, with the band scale, the graphical marks can span multiple bands. You could, for example, draw lines between the bands.</p>"},{"location":"sample-collections/visualizing/#implicit-sample-identifiers","title":"Implicit sample identifiers","text":"<p>By default, the identifiers of the samples are extracted from the data, and each sample gets its own track.</p>"},{"location":"sample-collections/visualizing/#explicit-sample-identifiers-and-metadata-attributes","title":"Explicit sample identifiers and metadata attributes","text":"<p>Genomic data is commonly supplemented with metadata that contains various clinical and computational annotations. To show such metadata alongside the genomic data as a color-coded heat map, you can provide a <code>data</code> source with sample identifiers and metadata columns.</p> Explicit sample identifiers<pre><code>{\n\"samples\": {\n\"data\": { \"url\": \"samples.tsv\" }\n},\n\"spec\": {\n...\n}\n}\n</code></pre> <p>The data source must have a <code>sample</code> field matching the sample identifiers used in the genomic data. In addition, an optional <code>displayName</code> field can be provided if the sample names should be shown, for example, in a shortened form. All other fields are shown as metadata attributes, and their data types are inferred automatically from the data: numeric attributes are interpreted as <code>\"quantitative\"</code> data, all others as <code>\"nominal\"</code>.</p> <p>An example of a metadata file (<code>samples.tsv</code>):</p> sample displayName treatment ploidy purity EOC52_pPer_DNA4 EOC52_pPer NACT 3.37 0.29 EOC702_pOme1_DNA1 EOC702_pOme1 PDS 3.74 0.155 EOC912_p2Bow2_DNA1 EOC912_p2Bow2 PDS 3.29 0.53"},{"location":"sample-collections/visualizing/#specifying-data-types-of-metadata-attributes","title":"Specifying data types of metadata attributes","text":"<p>To adjust the data types, scales, and default visibility of the attributes, they can be specified explicitly using the <code>attributes</code> object, as shown in the example below:</p> Specifying a purity attribute<pre><code>{\n\"samples\": {\n\"data\": { \"url\": \"samples.tsv\" },\n\"attributes\": {\n\"purity\": {\n\"type\": \"quantitative\",\n\"scale\": {\n\"domain\": [0, 1],\n\"scheme\": \"yellowgreenblue\"\n},\n\"barScale\": { },\n\"visible\": false\n},\n...\n}\n},\n...\n}\n</code></pre> <p>The <code>scale</code> property specifies a scale for the <code>color</code> channel used to encode the values on the metadata heatmap. The optional <code>barScale</code> property enables positional encoding, changing the heatmap cells into a horizontal bar chart. The <code>visible</code> property configures the default visibility for the attribute.</p>"},{"location":"sample-collections/visualizing/#aggregation","title":"Aggregation","text":"<p>TODO</p>"},{"location":"sample-collections/visualizing/#bookmarking","title":"Bookmarking","text":"<p>With the GenomeSpy app, users can save the current visualization state, including scale domains and view visibilities, as bookmarks. These bookmarks are stored in the IndexedDB of the user's web browser. Each database is unique to an origin, which typically refers to the hostname and domain of the web server hosting the visualization. Since the server may host multiple visualizations, each visualization must have a unique ID assigned to it. To enable bookmarking, simply add the <code>specId</code> property with an arbitrary but unique string value to the top-level view. Example:</p> <pre><code>{\n\"specId\": \"My example visualization\",\n\n\"vconcat\": { ... },\n...\n}\n</code></pre>"},{"location":"sample-collections/visualizing/#pre-defined-bookmarks-and-bookmark-tour","title":"Pre-defined bookmarks and bookmark tour","text":"<p>You may want to provide users with a few pre-defined bookmarks that showcase interesting findings from the data. Since bookmarks support Markdown-formatted notes, you can also explain the implications of the findings and present essential background information.</p> <p>The remote bookmarks feature allows for storing bookmarks in a JSON file on a web server and provides them to users through the bookmark menu. In addition, you can optionally enable the <code>tour</code> function, which automatically opens the first bookmark in the file and allows the user navigate the tour using previous/next buttons.</p>"},{"location":"sample-collections/visualizing/#enabling-remote-bookmarks","title":"Enabling remote bookmarks","text":"View specification<pre><code>{\n\"bookmarks\": {\n\"remote\": {\n\"url\": \"tour.json\",\n\"tour\": true\n}\n},\n\n\"vconcat\": { ... },\n...\n}\n</code></pre> <p>The <code>remote</code> object accepts the following properties:</p> <code>url</code> (string) A URL to the remote bookmark file. <code>initialBookmark</code> (string) Name of the bookmark that should be loaded as the initial state. The bookmark description dialog is shown only if the <code>tour</code> property is set to <code>true</code>. <code>tour</code> (boolean, optional) <p>Should the user be shown a tour of the remote bookmarks when the visualization is launched? If the <code>initialBookmark</code> property is not defined, the tour starts from the first bookmark.</p> <p>Default: <code>false</code></p> <code>afterTourBookmark</code> (string, optional) Name of the bookmark that should be loaded when the user ends the tour. If <code>null</code>, the dialog will be closed and the current state is retained. If undefined, the default state without any performed actions will be loaded."},{"location":"sample-collections/visualizing/#the-bookmark-file","title":"The bookmark file","text":"<p>The remote bookmark file consists of an array of bookmark objects. The easiest way to create such bookmark objects is to create a bookmark in the app and choose Share from the submenu () of the bookmark item. The sharing dialog provides the bookmark in an URL-encoded format and as a JSON object. Just copy-paste the JSON object into the bookmark file to make it available to all users. A simplified example:</p> Bookmark file (tour.json)<pre><code>[\n{\n\"name\": \"First bookmark\",\n\"actions\": [ ... ],\n...\n},\n{\n\"name\": \"Second bookmark\",\n\"actions\": [ ... ],\n...\n}\n]\n</code></pre>"},{"location":"sample-collections/visualizing/#toggleable-view-visibility","title":"Toggleable View Visibility","text":"<p>When working with a complex visualization that includes multiple tracks and extensive metadata, it may not always be necessary to display all views simultaneously. The GenomeSpy app offers users the ability to toggle the visibility of nodes within the view hierarchy. This visibility state is also included in shareable links and bookmarks, allowing users to easily access their preferred configurations.</p> <p>Views have two properties for controlling the visibility:</p> <code>visible</code> (boolean) <p>If true, the view is visible. This property can be used to set the default visibility.</p> <p>Default: <code>true</code></p> <code>configurableVisibility</code> (boolean) <p>If true, the visibility is configurable from a menu in the app</p> <p>Configurability requires that the view has an explicitly specified <code>name</code> that is unique within the view specification.</p> <p>Default: <code>false</code> for children of <code>layer</code>, <code>true</code> for others</p>"},{"location":"sample-collections/visualizing/#search","title":"Search","text":"<p>The location/search field in the toolbar allows users to quickly navigate to features in the data. To make features searchable, use the <code>search</code> channel on marks that represent the searchable data objects. Example:</p> <pre><code>{\n...,\n\"mark\": \"rect\",\n\"encoding\": {\n\"search\": {\n\"field\": \"geneSymbol\"\n},\n...,\n},\n...\n}\n</code></pre>"},{"location":"sample-collections/visualizing/#a-practical-example","title":"A practical example","text":"<p>Work in progress</p> <p>This part of the documentation is still under construction.  For a live example, check the PARPiCL visualization, which is also available for interactive exploration</p>"}]}